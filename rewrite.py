#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Restore project files from a TXT prompt generated by pack_project_prompt.py.
- Parses the tree of "----- BEGIN/END FILE: <relpath> -----"
- Extracts content (prefers fenced block, falls back to all lines between markers)
- Recreates directories and writes .py/.html files under a chosen output root
- Uses input() for a dead-simple UX
"""

from __future__ import annotations
import os
import sys
from typing import List, Tuple

BEGIN_TAG = "----- BEGIN FILE:"
END_TAG   = "----- END FILE:"

def ask(prompt: str, default: str | None = None) -> str:
    if default is None:
        return input(prompt + " ").strip()
    val = input(f"{prompt} [é»˜è®¤: {default}] ").strip()
    return val or default

def confirm(prompt: str, default: bool = False) -> bool:
    d = "Y/n" if default else "y/N"
    val = input(f"{prompt} [{d}] ").strip().lower()
    if not val:
        return default
    return val in ("y", "yes", "1", "true", "t")

def read_text(path: str) -> str:
    with open(path, "r", encoding="utf-8", errors="replace") as f:
        return f.read()

def parse_blocks(text: str) -> List[Tuple[str, str]]:
    """
    Parse the packed TXT into (relpath, content) tuples.
    Prefers fenced code blocks if present; otherwise uses raw lines between markers.
    """
    lines = text.splitlines()
    n = len(lines)
    i = 0
    results: List[Tuple[str, str]] = []

    while i < n:
        line = lines[i]
        if line.startswith(BEGIN_TAG):
            # Extract relpath between BEGIN and trailing dashes
            rel = line[len(BEGIN_TAG):].strip()
            if rel.endswith("-----"):
                rel = rel[:-5].rstrip()
            # Gather lines until END_TAG
            i += 1
            start_i = i
            while i < n and not lines[i].startswith(END_TAG):
                i += 1
            if i >= n:
                raise ValueError(f"æœªæ‰¾åˆ°åŒ¹é…çš„ END æ ‡è®°ï¼ˆèµ·å§‹äºç¬¬ {start_i+1} è¡Œï¼Œæ–‡ä»¶ {rel}ï¼‰ã€‚")
            end_i = i  # line with END_TAG is at i
            block = lines[start_i:end_i]

            # Strip optional "# Size: ..." metadata line at top
            k = 0
            if k < len(block) and block[k].lstrip().startswith("# Size:"):
                k += 1

            content_lines: List[str] | None = None

            # Prefer fenced content if present
            if k < len(block) and block[k].strip().startswith("```"):
                # find closing fence line "```"
                k += 1
                j = k
                while j < len(block) and block[j].strip() != "```":
                    j += 1
                if j < len(block) and block[j].strip() == "```":
                    content_lines = block[k:j]
                else:
                    # fence not closed properly; fall back to all lines after possible header
                    content_lines = block[k:]
            else:
                # No fence; treat everything after header as content
                content_lines = block[k:]

            content = "\n".join(content_lines)
            results.append((rel, content))

            # Move past END line
            i += 1
        else:
            i += 1

    return results

def is_safe_relative_path(rel: str) -> bool:
    # Disallow absolute paths and drive letters
    if os.path.isabs(rel):
        return False
    # Normalize and ensure it doesn't escape via ..
    norm = os.path.normpath(rel)
    parts = norm.split(os.sep)
    return not any(p in ("..", "") for p in parts if p != ".")

def ensure_within_root(root: str, rel: str) -> str:
    # Join and ensure path stays within root
    target = os.path.normpath(os.path.join(root, rel))
    root_norm = os.path.normpath(os.path.abspath(root))
    target_abs = os.path.normpath(os.path.abspath(target))
    if not target_abs.startswith(root_norm + os.sep) and target_abs != root_norm:
        raise ValueError(f"è·¯å¾„é€ƒé€¸è¢«é˜»æ­¢: {rel}")
    return target_abs

def write_files(blocks: List[Tuple[str, str]], out_root: str, overwrite: bool) -> Tuple[int, int]:
    written = 0
    skipped = 0
    for rel, content in blocks:
        # only restore .py/.html
        low = rel.lower()
        if not (low.endswith(".py") or low.endswith(".html")):
            skipped += 1
            continue
        if not is_safe_relative_path(rel):
            print(f"âš ï¸ è·³è¿‡ä¸å®‰å…¨è·¯å¾„: {rel}")
            skipped += 1
            continue
        target = ensure_within_root(out_root, rel)
        os.makedirs(os.path.dirname(target), exist_ok=True)
        if os.path.exists(target) and not overwrite:
            print(f"â­ï¸ å·²å­˜åœ¨ï¼Œæœªè¦†ç›–: {rel}")
            skipped += 1
            continue
        with open(target, "w", encoding="utf-8", errors="replace", newline="") as f:
            f.write(content)
        print(f"âœ… å†™å…¥: {rel}  ({len(content.splitlines())} è¡Œ)")
        written += 1
    return written, skipped

def main():
    print("ğŸ§¯ å›å¡«é¡¹ç›®æ–‡ä»¶ï¼ˆä» TXT Prompt è¿˜åŸ .py / .htmlï¼‰")
    src_txt = ask("è¯·è¾“å…¥æ‰“åŒ…ç”Ÿæˆçš„ TXT æ–‡ä»¶è·¯å¾„")
    if not os.path.isfile(src_txt):
        print("âŒ æ‰¾ä¸åˆ°è¯¥ TXT æ–‡ä»¶ã€‚")
        sys.exit(1)

    out_root = ask("è¯·é€‰æ‹©å›å¡«è¾“å‡ºæ ¹ç›®å½•", os.path.join(os.getcwd(), "restored_project"))
    os.makedirs(out_root, exist_ok=True)

    overwrite = confirm("è‹¥æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ", default=False)

    # Load and parse
    print("ğŸ“– è¯»å–å¹¶è§£æ TXT...")
    text = read_text(src_txt)
    blocks = parse_blocks(text)
    if not blocks:
        print("ğŸ˜¶ æ²¡è§£æåˆ°ä»»ä½•æ–‡ä»¶å—ã€‚ç¡®è®¤æ˜¯å¦ç”±é…å¥—æ‰“åŒ…è„šæœ¬ç”Ÿæˆã€‚")
        sys.exit(2)

    # Summary preview
    print(f"ğŸ” è§£æç»“æœï¼š{len(blocks)} ä¸ªæ–‡ä»¶å—ã€‚ç¤ºä¾‹ï¼š")
    for i, (rel, _) in enumerate(blocks[:5], 1):
        print(f"  {i:>2}. {rel}")
    if len(blocks) > 5:
        print(f"  ... ä»¥åŠå…¶ä»– {len(blocks)-5} ä¸ªã€‚")

    # Write
    print("ğŸ› ï¸ æ­£åœ¨å›å¡«...")
    written, skipped = write_files(blocks, out_root, overwrite)

    print("\nğŸ“¦ å®Œæˆ")
    print(f"  âœ”ï¸ å†™å…¥: {written} æ–‡ä»¶")
    print(f"  â†ªï¸ è·³è¿‡: {skipped} æ–‡ä»¶")
    print(f"  ğŸ“ è¾“å‡ºç›®å½•: {os.path.abspath(out_root)}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"âŒ å¼‚å¸¸: {e}")
        sys.exit(3)
