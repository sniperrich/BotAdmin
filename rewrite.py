#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Restore project files from a TXT prompt generated by pack_project_prompt.py.
- Parses the tree of "----- BEGIN/END FILE: <relpath> -----"
- Extracts content (prefers fenced block, falls back to all lines between markers)
- Recreates directories and writes .py/.html files under a chosen output root
- Uses input() for a dead-simple UX
"""

from __future__ import annotations
import os
import sys
from typing import List, Tuple

BEGIN_TAG = "----- BEGIN FILE:"
END_TAG   = "----- END FILE:"

def ask(prompt: str, default: str | None = None) -> str:
    if default is None:
        return input(prompt + " ").strip()
    val = input(f"{prompt} [默认: {default}] ").strip()
    return val or default

def confirm(prompt: str, default: bool = False) -> bool:
    d = "Y/n" if default else "y/N"
    val = input(f"{prompt} [{d}] ").strip().lower()
    if not val:
        return default
    return val in ("y", "yes", "1", "true", "t")

def read_text(path: str) -> str:
    with open(path, "r", encoding="utf-8", errors="replace") as f:
        return f.read()

def parse_blocks(text: str) -> List[Tuple[str, str]]:
    """
    Parse the packed TXT into (relpath, content) tuples.
    Prefers fenced code blocks if present; otherwise uses raw lines between markers.
    """
    lines = text.splitlines()
    n = len(lines)
    i = 0
    results: List[Tuple[str, str]] = []

    while i < n:
        line = lines[i]
        if line.startswith(BEGIN_TAG):
            # Extract relpath between BEGIN and trailing dashes
            rel = line[len(BEGIN_TAG):].strip()
            if rel.endswith("-----"):
                rel = rel[:-5].rstrip()
            # Gather lines until END_TAG
            i += 1
            start_i = i
            while i < n and not lines[i].startswith(END_TAG):
                i += 1
            if i >= n:
                raise ValueError(f"未找到匹配的 END 标记（起始于第 {start_i+1} 行，文件 {rel}）。")
            end_i = i  # line with END_TAG is at i
            block = lines[start_i:end_i]

            # Strip optional "# Size: ..." metadata line at top
            k = 0
            if k < len(block) and block[k].lstrip().startswith("# Size:"):
                k += 1

            content_lines: List[str] | None = None

            # Prefer fenced content if present
            if k < len(block) and block[k].strip().startswith("```"):
                # find closing fence line "```"
                k += 1
                j = k
                while j < len(block) and block[j].strip() != "```":
                    j += 1
                if j < len(block) and block[j].strip() == "```":
                    content_lines = block[k:j]
                else:
                    # fence not closed properly; fall back to all lines after possible header
                    content_lines = block[k:]
            else:
                # No fence; treat everything after header as content
                content_lines = block[k:]

            content = "\n".join(content_lines)
            results.append((rel, content))

            # Move past END line
            i += 1
        else:
            i += 1

    return results

def is_safe_relative_path(rel: str) -> bool:
    # Disallow absolute paths and drive letters
    if os.path.isabs(rel):
        return False
    # Normalize and ensure it doesn't escape via ..
    norm = os.path.normpath(rel)
    parts = norm.split(os.sep)
    return not any(p in ("..", "") for p in parts if p != ".")

def ensure_within_root(root: str, rel: str) -> str:
    # Join and ensure path stays within root
    target = os.path.normpath(os.path.join(root, rel))
    root_norm = os.path.normpath(os.path.abspath(root))
    target_abs = os.path.normpath(os.path.abspath(target))
    if not target_abs.startswith(root_norm + os.sep) and target_abs != root_norm:
        raise ValueError(f"路径逃逸被阻止: {rel}")
    return target_abs

def write_files(blocks: List[Tuple[str, str]], out_root: str, overwrite: bool) -> Tuple[int, int]:
    written = 0
    skipped = 0
    for rel, content in blocks:
        # only restore .py/.html
        low = rel.lower()
        if not (low.endswith(".py") or low.endswith(".html")):
            skipped += 1
            continue
        if not is_safe_relative_path(rel):
            print(f"⚠️ 跳过不安全路径: {rel}")
            skipped += 1
            continue
        target = ensure_within_root(out_root, rel)
        os.makedirs(os.path.dirname(target), exist_ok=True)
        if os.path.exists(target) and not overwrite:
            print(f"⏭️ 已存在，未覆盖: {rel}")
            skipped += 1
            continue
        with open(target, "w", encoding="utf-8", errors="replace", newline="") as f:
            f.write(content)
        print(f"✅ 写入: {rel}  ({len(content.splitlines())} 行)")
        written += 1
    return written, skipped

def main():
    print("🧯 回填项目文件（从 TXT Prompt 还原 .py / .html）")
    src_txt = ask("请输入打包生成的 TXT 文件路径")
    if not os.path.isfile(src_txt):
        print("❌ 找不到该 TXT 文件。")
        sys.exit(1)

    out_root = ask("请选择回填输出根目录", os.path.join(os.getcwd(), "restored_project"))
    os.makedirs(out_root, exist_ok=True)

    overwrite = confirm("若文件已存在，是否覆盖？", default=False)

    # Load and parse
    print("📖 读取并解析 TXT...")
    text = read_text(src_txt)
    blocks = parse_blocks(text)
    if not blocks:
        print("😶 没解析到任何文件块。确认是否由配套打包脚本生成。")
        sys.exit(2)

    # Summary preview
    print(f"🔍 解析结果：{len(blocks)} 个文件块。示例：")
    for i, (rel, _) in enumerate(blocks[:5], 1):
        print(f"  {i:>2}. {rel}")
    if len(blocks) > 5:
        print(f"  ... 以及其他 {len(blocks)-5} 个。")

    # Write
    print("🛠️ 正在回填...")
    written, skipped = write_files(blocks, out_root, overwrite)

    print("\n📦 完成")
    print(f"  ✔️ 写入: {written} 文件")
    print(f"  ↪️ 跳过: {skipped} 文件")
    print(f"  📁 输出目录: {os.path.abspath(out_root)}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"❌ 异常: {e}")
        sys.exit(3)
