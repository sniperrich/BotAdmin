# Project Prompt Export
# Time: 2025-10-10 18:19:49
# Root: /Users/rich/PycharmProjects/BotAdmin
# Include: *.py, *.html
# Excluded dirs: .git, .idea, .vscode, __pycache__, dist, build, node_modules, venv, .venv
# Per-file size cap: 512.0KB

## Project Structure (ä»…åŒ…å«è¢«æ‰“åŒ…çš„æ–‡ä»¶)
```
â”œâ”€â”€ config
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ settings.py
â”œâ”€â”€ core
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ ai.py
â”‚   â”œâ”€â”€ flows.py
â”‚   â”œâ”€â”€ pseudo.py
â”‚   â””â”€â”€ runtime.py
â”œâ”€â”€ data
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ database.py
â”œâ”€â”€ interact
â”‚   â”œâ”€â”€ routes
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ ai.py
â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â”œâ”€â”€ bots.py
â”‚   â”‚   â”œâ”€â”€ commands.py
â”‚   â”‚   â”œâ”€â”€ flows.py
â”‚   â”‚   â”œâ”€â”€ pro_scripts.py
â”‚   â”‚   â”œâ”€â”€ pseudocode.py
â”‚   â”‚   â””â”€â”€ runtime.py
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ security.py
â”‚   â”œâ”€â”€ socket.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ static
â”‚   â”œâ”€â”€ blocks.html
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ ai_client.py
â”œâ”€â”€ app.py
â”œâ”€â”€ bot_registry.py
â”œâ”€â”€ db.py
â”œâ”€â”€ flow_engine.py
â”œâ”€â”€ ftp.py
â”œâ”€â”€ main.py
â”œâ”€â”€ pseudo_convert.py
â””â”€â”€ rewrite.py
```

## Files


----- BEGIN FILE: ai_client.py -----
# Size: 126B | Lines: 5
```python
"""Legacy shim for AI helpers."""
from core.ai import *  # noqa: F401,F403
import core.ai as _ai

__all__ = list(_ai.__all__)

```
----- END FILE: ai_client.py -----


----- BEGIN FILE: app.py -----
# Size: 250B | Lines: 8
```python
"""Compatibility entrypoint; prefer `main.py`."""
from interact import create_app, socketio

app = create_app()


if __name__ == "__main__":  # pragma: no cover
    socketio.run(app, host="0.0.0.0", port=8000, debug=True, allow_unsafe_werkzeug=True)

```
----- END FILE: app.py -----


----- BEGIN FILE: bot_registry.py -----
# Size: 158B | Lines: 5
```python
"""Legacy shim for bot runtime management."""
from core.runtime import *  # noqa: F401,F403
import core.runtime as _runtime

__all__ = list(_runtime.__all__)

```
----- END FILE: bot_registry.py -----


----- BEGIN FILE: config/__init__.py -----
# Size: 137B | Lines: 4
```python
"""Config package exports."""
from .settings import Settings, get_settings, BASE_DIR

__all__ = ["Settings", "get_settings", "BASE_DIR"]

```
----- END FILE: config/__init__.py -----


----- BEGIN FILE: config/settings.py -----
# Size: 974B | Lines: 37
```python
"""Application configuration helpers."""
from __future__ import annotations

import os
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent


@dataclass(frozen=True)
class Settings:
    base_dir: Path
    db_path: Path
    static_dir: Path
    secret_key: str

    @property
    def db_path_str(self) -> str:
        return str(self.db_path)

    @property
    def static_dir_str(self) -> str:
        return str(self.static_dir)


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    base_dir = BASE_DIR
    db_path = Path(os.environ.get("BOT_ADMIN_DB") or (base_dir / "bot_admin.db"))
    static_dir = Path(os.environ.get("STATIC_ROOT") or (base_dir / "static"))
    secret_key = os.environ.get("APP_SECRET", "dev-secret")
    return Settings(base_dir=base_dir, db_path=db_path, static_dir=static_dir, secret_key=secret_key)


__all__ = ["Settings", "get_settings", "BASE_DIR"]

```
----- END FILE: config/settings.py -----


----- BEGIN FILE: core/__init__.py -----
# Size: 609B | Lines: 24
```python
"""Expose core runtime helpers."""
from .ai import generate_pseudocode, generate_command
from .flows import FlowVM, load_vms_for_bot
from .pseudo import (
    generate_flow_from_pseudocode,
    simulate_flow,
    ai_generate_pseudocode,
    ai_generate_command_skeleton,
)
from .runtime import BotProcess, BotRegistry, registry

__all__ = [
    "generate_pseudocode",
    "generate_command",
    "FlowVM",
    "load_vms_for_bot",
    "generate_flow_from_pseudocode",
    "simulate_flow",
    "ai_generate_pseudocode",
    "ai_generate_command_skeleton",
    "BotProcess",
    "BotRegistry",
    "registry",
]

```
----- END FILE: core/__init__.py -----


----- BEGIN FILE: core/ai.py -----
# Size: 4.6KB | Lines: 120
```python
"""DeepSeek AI integration with graceful fallback to local templates."""
from __future__ import annotations

import json
import os
from typing import Any, Dict, Tuple

try:
    from openai import OpenAI
except ImportError:  # pragma: no cover
    OpenAI = None  # type: ignore

from .pseudo import (
    ai_generate_pseudocode as _fallback_pseudo,
    ai_generate_command_skeleton as _fallback_command,
)

_client_cache: Tuple[str, str, Any] | None = None


def _get_client():
    if OpenAI is None:
        return None, "æœªå®‰è£… openai SDK (pip install openai)"
    key = os.environ.get("DEEPSEEK_API_KEY") or os.environ.get("AI_API_KEY")
    if not key:
        return None, "ç¼ºå°‘ DEEPSEEK_API_KEY æˆ– AI_API_KEY"
    base_url = os.environ.get("DEEPSEEK_BASE_URL") or os.environ.get("AI_BASE_URL") or "https://api.deepseek.com"
    global _client_cache
    if _client_cache and _client_cache[0] == key and _client_cache[1] == base_url:
        return _client_cache[2], None
    client = OpenAI(api_key=key, base_url=base_url)
    _client_cache = (key, base_url, client)
    return client, None


def _chat(client, messages, max_tokens=800, temperature=0.4):
    model = os.environ.get("DEEPSEEK_MODEL", "deepseek-chat")
    return client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=temperature,
        max_tokens=max_tokens,
        response_format={"type": "json_object"},
    )


def generate_pseudocode(prompt: str) -> Tuple[Dict[str, str], Dict[str, Any]]:
    fallback_meta = {"source": "fallback", "api_key_configured": False}
    client, err = _get_client()
    if not client:
        result = _fallback_pseudo(prompt)
        fallback_meta["error"] = err
        return result, fallback_meta

    meta = {"source": "deepseek", "api_key_configured": True}
    system_msg = (
        "ä½ æ˜¯ä¸€åè‡ªåŠ¨åŒ–æµç¨‹è®¾è®¡å¸ˆï¼Œè¿”å›ž JSON å¯¹è±¡ {title, command, steps}ã€‚"\
        "steps æ˜¯å­—ç¬¦ä¸²æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯è¯¦ç»†çš„ä¸­æ–‡ä¼ªä»£ç æ­¥éª¤ã€‚å‘½ä»¤ä»¥ / å¼€å¤´ã€‚"
    )
    user_prompt = prompt.strip() or "æ¬¢è¿Žæµç¨‹"
    try:
        resp = _chat(client, [
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_prompt},
        ], max_tokens=900, temperature=0.5)
        content = resp.choices[0].message.content or "{}"
        data = json.loads(content)
        title = data.get("title") or f"{user_prompt} è‡ªåŠ¨åŒ–æµç¨‹"
        command = data.get("command") or "/auto"
        steps = data.get("steps") or []
        if isinstance(steps, str):
            steps = steps.splitlines()
        steps = [str(s).strip() for s in steps if str(s).strip()]
        pseudo_text = "\n".join(f"{i+1}. {step}" for i, step in enumerate(steps)) or "1. æœºå™¨äººå‘é€æ¬¢è¿Žæ¶ˆæ¯"
        return {"title": title, "content": pseudo_text, "command": command}, meta
    except Exception as exc:  # pragma: no cover
        meta = {"source": "fallback", "api_key_configured": True, "error": str(exc)}
        result = _fallback_pseudo(prompt)
        return result, meta


def generate_command(prompt: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    fallback_meta = {"source": "fallback", "api_key_configured": False}
    client, err = _get_client()
    if not client:
        result = _fallback_command(prompt)
        fallback_meta["error"] = err
        return result, fallback_meta

    meta = {"source": "deepseek", "api_key_configured": True}
    system_msg = (
        "ä½ æ˜¯ä¸€åèŠå¤©æœºå™¨äººçš„æŒ‡ä»¤ç¼–å†™åŠ©æ‰‹ï¼Œè¿”å›ž JSON {command, reply, parse_mode, disable_preview}."
        "command å¿…é¡»ä»¥ / å¼€å¤´ï¼Œreply æ˜¯æ–‡æœ¬å›žå¤ï¼Œå¯åŒ…å« {{args}} å˜é‡ã€‚"
    )
    user_prompt = prompt.strip() or "æ¬¢è¿Žè®¿å®¢"
    try:
        resp = _chat(client, [
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_prompt},
        ], max_tokens=400, temperature=0.4)
        content = resp.choices[0].message.content or "{}"
        data = json.loads(content)
        command = data.get("command") or "/auto"
        reply = data.get("reply") or f"{user_prompt}: æ„Ÿè°¢å…³æ³¨ï¼"
        parse_mode = data.get("parse_mode") or ""
        disable_preview = bool(data.get("disable_preview", False))
        return {
            "command": command,
            "kind": "text",
            "reply": reply,
            "parse_mode": parse_mode,
            "disable_preview": disable_preview,
        }, meta
    except Exception as exc:  # pragma: no cover
        meta = {"source": "fallback", "api_key_configured": True, "error": str(exc)}
        result = _fallback_command(prompt)
        return result, meta


__all__ = ["generate_pseudocode", "generate_command"]
```
----- END FILE: core/ai.py -----


----- BEGIN FILE: core/flows.py -----
# Size: 15.9KB | Lines: 326
```python
"""Flow runtime helpers."""
import asyncio, json, re, time
from typing import List, Dict, Any, Optional

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, Application

from data.database import list_flows as _list_flows, kv_get, kv_set

# ... (æ¨¡æ¿æ¸²æŸ“éƒ¨åˆ†ä¸å˜)
_token_pat = re.compile(r"\{\{\s*([\w\.]+)\s*\}\}")


def _resolve_path(d: Any, path: str):
    cur = d
    for part in path.split("."):
        if isinstance(cur, dict) and part in cur:
            cur = cur[part]
        else:
            return ""
    return "" if cur is None else cur


def _render_with_vars(tpl: str | None, base_ctx: dict, bot_id: int, chat_id: str | None, user_id: str | None,
                      kv_cache: dict):
    if not tpl: return ""

    def _sub(m):
        key = m.group(1).strip()
        if key.startswith("vars."):
            parts = key.split(".")
            if len(parts) >= 3:
                scope, k = parts[1], ".".join(parts[2:])
                cache_bucket = kv_cache.setdefault(scope, {})
                if k not in cache_bucket:
                    cache_bucket[k] = kv_get(bot_id, scope, chat_id if scope != "bot" else None,
                                             user_id if scope == "user" else None, k)
                return "" if cache_bucket[k] is None else str(cache_bucket[k])
        return str(_resolve_path(base_ctx, key))

    return _token_pat.sub(_sub, tpl)


class FlowVM:
    def __init__(self, bot_id: int, blocks: dict):
        self.bot_id = bot_id
        self.blocks = blocks or {"entries": []}

    async def run_entry(self, app: Application, update: Update, ctx: ContextTypes.DEFAULT_TYPE, entry: dict):
        message = update.effective_message
        user = update.effective_user
        chat = update.effective_chat
        args = (ctx.args or [])
        chat_id = str(chat.id) if chat else None
        user_id = str(user.id) if user else None

        locals_map: Dict[str, Any] = {}
        kv_cache: Dict[str, dict] = {}

        base_ctx = {
            "args": " ".join(args),
            "arg0": args[0] if args else "",
            "input": {"text": message.text if message else ""},
            "user": {"id": user.id if user else "", "username": user.username if user else "",
                     "first_name": user.first_name if user else "", "last_name": user.last_name if user else ""},
            "chat": {"id": chat.id if chat else "", "type": chat.type if chat else ""},
            "local": locals_map
        }

        async def send_text(text: str, parse_mode: Optional[str], no_preview: bool):
            t = _render_with_vars(text, base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            await message.reply_text(t, parse_mode=parse_mode or None, disable_web_page_preview=bool(no_preview))

        def _build_keyboard(raw: Any):
            # ... (è¿™éƒ¨åˆ†ä¸å˜)
            if raw is None: return None
            data = raw
            if isinstance(raw, str):
                rendered = _render_with_vars(raw, base_ctx, self.bot_id, chat_id, user_id, kv_cache)
                txt = (rendered or "").strip()
                if not txt: return None
                try:
                    data = json.loads(txt)
                except Exception:
                    return None
            if not isinstance(data, list): return None
            rows: List[List[InlineKeyboardButton]] = []
            for row in data:
                if not isinstance(row, list): continue
                btns: List[InlineKeyboardButton] = []
                for btn in row:
                    if not isinstance(btn, dict): continue
                    text_raw = btn.get("text") or ""
                    text_val = _render_with_vars(str(text_raw), base_ctx, self.bot_id, chat_id, user_id,
                                                 kv_cache).strip()
                    if not text_val: continue
                    url_raw = btn.get("url")
                    cb_raw = btn.get("callback_data")
                    url_val = _render_with_vars(str(url_raw), base_ctx, self.bot_id, chat_id, user_id,
                                                kv_cache).strip() if url_raw else None
                    cb_val = _render_with_vars(str(cb_raw), base_ctx, self.bot_id, chat_id, user_id,
                                               kv_cache).strip() if cb_raw else None
                    if url_val:
                        btns.append(InlineKeyboardButton(text=text_val, url=url_val))
                    else:
                        if not cb_val: cb_val = text_val[:64]
                        btns.append(InlineKeyboardButton(text=text_val, callback_data=cb_val[:64]))
                if btns: rows.append(btns)
            if rows: return InlineKeyboardMarkup(rows)
            return None

        async def send_text_keyboard(text: str, parse_mode: Optional[str], no_preview: bool, keyboard_raw: Any):
            t = _render_with_vars(text, base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            markup = _build_keyboard(keyboard_raw)
            await message.reply_text(t, parse_mode=parse_mode or None, disable_web_page_preview=bool(no_preview),
                                     reply_markup=markup)

        # Bug ä¿®å¤ï¼šä½¿ç”¨ app.bot è€Œä¸æ˜¯ message.bot
        async def send_media(kind: str, url: str, caption: str, parse_mode: Optional[str]):
            u = _render_with_vars(url, base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            c = _render_with_vars(caption, base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            if kind == "photo":
                await app.bot.send_photo(chat_id=chat.id, photo=u, caption=c, parse_mode=parse_mode or None)
            elif kind == "document":
                await app.bot.send_document(chat_id=chat.id, document=u, caption=c, parse_mode=parse_mode or None)
            elif kind == "animation":
                await app.bot.send_animation(chat_id=chat.id, animation=u, caption=c, parse_mode=parse_mode or None)
            elif kind == "voice":
                await app.bot.send_voice(chat_id=chat.id, voice=u, caption=c, parse_mode=parse_mode or None)
            elif kind == "sticker":
                await app.bot.send_sticker(chat_id=chat.id, sticker=u)

        # ... (å…¶ä½™é€»è¾‘å¦‚ http_call, é¡ºåºæ‰§è¡ŒèŠ‚ç‚¹ç­‰åŸºæœ¬ä¸å˜ï¼Œé™¤äº† send_media çš„è°ƒç”¨)
        async def http_call(node: dict):
            import aiohttp
            method = (node.get("method") or "GET").upper()
            url = _render_with_vars(node.get("url", ""), base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            headers_txt = _render_with_vars(node.get("headers") or "", base_ctx, self.bot_id, chat_id, user_id,
                                            kv_cache)
            body_txt = _render_with_vars(node.get("body") or "", base_ctx, self.bot_id, chat_id, user_id, kv_cache)
            try:
                headers = json.loads(headers_txt) if headers_txt else {}
            except Exception:
                headers = {}
            try:
                data = json.loads(body_txt) if body_txt else None
            except Exception:
                data = body_txt.encode("utf-8") if body_txt else None

            async with aiohttp.ClientSession() as sess:
                async with sess.request(method, url, headers=headers or None,
                                        json=(data if isinstance(data, dict) else None),
                                        data=(data if isinstance(data, (bytes, str)) else None), timeout=15) as resp:
                    raw = await resp.text()
                    val: Any = raw
                    try:
                        j = json.loads(raw)
                        jpath = (node.get("json_path") or "").strip()
                        if jpath:
                            cur = j
                            for part in jpath.split("."):
                                if part == "": continue
                                if isinstance(cur, dict) and part in cur:
                                    cur = cur[part]
                                else:
                                    cur = None; break
                            val = cur
                        else:
                            val = j
                    except Exception:
                        pass
            save = node.get("save_to") or {};
            scope = save.get("scope") or "chat";
            key = save.get("key") or "resp"
            kv_set(self.bot_id, scope, chat_id if scope != "bot" else None, user_id if scope == "user" else None, key,
                   val)
            kv_cache.setdefault(scope, {})[key] = val

        for n in (entry.get("nodes") or []):
            t = n.get("type")
            if t == "send_text":
                await send_text(n.get("text") or "", n.get("parse_mode") or None, bool(n.get("disable_preview")))
            elif t in ("send_photo", "send_document", "send_animation"):
                await send_media(t.split("_", 1)[1], n.get("url") or "", n.get("caption") or "", n.get("parse_mode"))
            elif t == "send_voice":
                await send_media("voice", n.get("url") or "", n.get("caption") or "", n.get("parse_mode"))
            elif t == "send_sticker":
                await send_media("sticker", n.get("file_id") or n.get("sticker") or "", "", None)
            elif t == "send_text_keyboard":
                await send_text_keyboard(n.get("text") or "", n.get("parse_mode") or None,
                                         bool(n.get("disable_preview")),
                                         n.get("keyboard") or n.get("keyboard_json") or n.get("buttons"))
            # ... (å˜é‡ã€æ¡ä»¶ã€å»¶è¿Ÿç­‰é€»è¾‘ä¸å˜)
            elif t == "set_var":
                mode = n.get("mode") or "text";
                scope, key = (n.get("scope") or "chat"), (n.get("key") or "k")
                if mode == "random":
                    lo = int(n.get("random", {}).get("min", 1));
                    hi = int(n.get("random", {}).get("max", 100))
                    val = int(lo + (time.time_ns() % (max(1, hi - lo + 1))))
                else:
                    val = _render_with_vars(n.get("value") or "", base_ctx, self.bot_id, chat_id, user_id, kv_cache)
                kv_set(self.bot_id, scope, chat_id if scope != "bot" else None, user_id if scope == "user" else None,
                       key, val);
                kv_cache.setdefault(scope, {})[key] = val
            elif t == "inc_var":
                scope, key = (n.get("scope") or "chat"), (n.get("key") or "count");
                step = int(n.get("step") or 1)
                cur = kv_get(self.bot_id, scope, chat_id if scope != "bot" else None,
                             user_id if scope == "user" else None, key)
                try:
                    cur = int(cur or 0)
                except Exception:
                    cur = 0
                val = cur + step
                kv_set(self.bot_id, scope, chat_id if scope != "bot" else None, user_id if scope == "user" else None,
                       key, val);
                kv_cache.setdefault(scope, {})[key] = val
            elif t == "get_var":
                scope, key, alias = (n.get("scope") or "chat"), (n.get("key") or "k"), (n.get("alias") or "x")
                val = kv_get(self.bot_id, scope, chat_id if scope != "bot" else None,
                             user_id if scope == "user" else None, key);
                locals_map[alias] = val
            elif t == "set_local_from_input":
                alias = n.get("alias") or "x";
                locals_map[alias] = base_ctx["input"]["text"]
            elif t == "if_var":
                def _asnum(x):
                    try:
                        if isinstance(x, str) and x.strip() != '' and re.fullmatch(r"-?\d+(\.\d+)?",
                                                                                   x.strip()): return float(
                            x) if "." in x else int(x)
                        return float(x) if isinstance(x, (int, float)) else x
                    except Exception:
                        return x

                left = locals_map.get((n.get("left") or {}).get("var", "x"));
                right_raw = (n.get("right") or {}).get("text", "");
                right = _render_with_vars(str(right_raw), base_ctx, self.bot_id, chat_id, user_id, kv_cache)
                L = _asnum(left);
                R = _asnum(right);
                op = n.get("op") or "eq";
                ok = False
                if op == "eq":
                    ok = (L == R)
                elif op == "ne":
                    ok = (L != R)
                elif op == "contains":
                    ok = (str(left) in str(right)) if False else (str(right) in str(left))
                elif op == "gt":
                    try:
                        ok = (float(L) > float(R))
                    except:
                        ok = False
                elif op == "lt":
                    try:
                        ok = (float(L) < float(R))
                    except:
                        ok = False
                branch = (n.get("then") if ok else n.get("else")) or []
                for bn in branch:
                    bt = bn.get("type")
                    if bt == "send_text":
                        await send_text(bn.get("text") or "", bn.get("parse_mode") or None,
                                        bool(bn.get("disable_preview")))
                    elif bt in ("send_photo", "send_document", "send_animation"):
                        await send_media(bt.split("_", 1)[1], bn.get("url") or "", bn.get("caption") or "", None)
            elif t == "http":
                await http_call(n)
            elif t == "delay":
                try:
                    sec = float(n.get("seconds") or 0)
                except Exception:
                    sec = 0
                if sec > 0: await asyncio.sleep(min(sec, 300))
            elif t == "wait_next":
                await_key = f"await_{entry.get('id')}";
                kv_set(self.bot_id, "chat", chat_id, None, await_key,
                       {"expect": (n.get("expect") or "any"), "next": n.get("next") or []})
                prompt = n.get("prompt") or ""
                if prompt: await send_text(prompt, None, False)
                break

    # ... (maybe_resume ä¸å˜)
    async def maybe_resume(self, app: Application, update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        message = update.effective_message;
        user = update.effective_user;
        chat = update.effective_chat
        chat_id = str(chat.id) if chat else None;
        user_id = str(user.id) if user else None

        for entry in (self.blocks.get("entries") or []):
            await_key = f"await_{entry.get('id')}"
            st = kv_get(self.bot_id, "chat", chat_id, None, await_key)
            if not st: continue

            st = json.loads(st) if isinstance(st, str) else st  # kv_store returns string
            expect = st.get("expect") or "any";
            nxt: List[dict] = st.get("next") or []
            text = message.text or ""

            if expect == "number" and not re.fullmatch(r"-?\d+", text.strip() or ""): return False

            kv_set(self.bot_id, "chat", chat_id, None, await_key, None)

            fake_entry = {"id": entry.get("id"), "nodes": nxt}
            ctx.args = (message.text or "").split()[1:] if (message.text or "").startswith("/") else (
                        message.text or "").split()
            await self.run_entry(app, update, ctx, fake_entry)
            return True
        return False


def load_vms_for_bot(bot_id: int) -> List[FlowVM]:
    vms: List[FlowVM] = []
    for row in _list_flows(bot_id):
        if int(row.get("active", 1)) != 1: continue
        try:
            blocks = json.loads(row.get("blocks_json") or "{}")
            if isinstance(blocks, str): blocks = json.loads(blocks)
        except Exception:
            blocks = {"entries": []}
        vms.append(FlowVM(bot_id, blocks))
    return vms

__all__ = ["FlowVM", "load_vms_for_bot"]

```
----- END FILE: core/flows.py -----


----- BEGIN FILE: core/pseudo.py -----
# Size: 8.7KB | Lines: 228
```python
"""Pseudocode parsing and simulation utilities."""
from __future__ import annotations

import re
from typing import Any, Dict, List


def _clean_line(line: str) -> str:
    line = line.strip()
    line = re.sub(r"^[-\d\.)\s]+", "", line)
    return line.strip()


def _extract_command(tokens: List[str]) -> str | None:
    for tok in tokens:
        match = re.search(r"/(?:[a-zA-Z0-9_]+)", tok)
        if match:
            return match.group(0)
    return None


def _extract_between(text: str, left: str, right: str) -> str | None:
    try:
        start = text.index(left) + len(left)
        end = text.index(right, start)
        return text[start:end].strip()
    except ValueError:
        return None


def _split_options(text: str) -> List[str]:
    if not text:
        return []
    options: List[str] = []
    options.extend(re.findall(r"ã€Œ([^ã€]+)ã€", text))
    if options:
        return [opt.strip() for opt in options if opt.strip()]
    for sep in ("/", "ã€", "ï¼Œ", " "):
        if sep in text:
            parts = [piece.strip() for piece in text.split(sep) if piece.strip()]
            if len(parts) > 1:
                return parts
    return [text.strip()]


def generate_flow_from_pseudocode(title: str, content: str) -> Dict[str, Any]:
    lines = [ln for ln in (content or "").splitlines() if ln.strip()]
    nodes: List[Dict[str, Any]] = []
    command = None
    summary: List[str] = []

    for raw in lines:
        line = _clean_line(raw)
        if not line:
            continue
        lower = line.lower()
        tokens = line.split()
        if command is None and ("ç”¨æˆ·" in line or "å‘½ä»¤" in line):
            cmd = _extract_command(tokens)
            if cmd:
                command = cmd
                summary.append(f"âœ… è¯†åˆ«å‘½ä»¤ {cmd}")
                continue
        if "æœºå™¨äºº" in line and ("å‘é€" in line or "å›žå¤" in line):
            text = _extract_between(line, "ã€Œ", "ã€")
            if not text:
                parts = re.split(r"[:,ï¼š]", line, 1)
                text = parts[-1].strip() if parts else ""
            nodes.append({
                "type": "send_text",
                "text": text or line,
                "parse_mode": "",
                "disable_preview": False,
            })
            summary.append("ðŸ“ æ·»åŠ å‘é€æ–‡æœ¬åŠ¨ä½œ")
            continue
        if "æŒ‰é’®" in line or "é€‰é¡¹" in line or "èœå•" in line:
            options = _split_options(
                _extract_between(line, "[", "]")
                or _extract_between(line, "ã€Œ", "ã€")
                or line
            )
            if not options:
                options = ["åŠŸèƒ½ä»‹ç»", "è”ç³»å®¢æœ", "å¸¸è§é—®é¢˜"]
            keyboard = [[{"text": opt, "callback_data": opt[:32]}] for opt in options]
            text = _extract_between(line, "ï¼š", "") or "è¯·é€‰æ‹©æœåŠ¡"
            nodes.append({
                "type": "send_text_keyboard",
                "text": text or "è¯·é€‰æ‹©æœåŠ¡",
                "keyboard": keyboard,
                "parse_mode": "",
                "disable_preview": False,
            })
            summary.append("ðŸ”˜ æ·»åŠ æŒ‰é’®èœå•")
            continue
        if "ç­‰å¾…" in line:
            expect = "number" if ("æ•°å­—" in line or "è¯„åˆ†" in line) else "any"
            prompt = _extract_between(line, "ã€Œ", "ã€") or re.split(r"[:,ï¼š]", line, 1)[-1].strip()
            nodes.append({
                "type": "wait_next",
                "expect": expect,
                "prompt": prompt or "è¯·å›žå¤æ¶ˆæ¯",
                "next": [],
            })
            summary.append("â³ æ·»åŠ ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯")
            continue
        if "å»¶è¿Ÿ" in line or ("ç­‰å¾…" in line and "ç§’" in line):
            match = re.search(r"(\d+(?:\.\d+)?)", line)
            seconds = float(match.group(1)) if match else 1.5
            nodes.append({"type": "delay", "seconds": seconds})
            summary.append(f"â±ï¸ å»¶è¿Ÿ {seconds} ç§’")
            continue
        if "è´´çº¸" in line:
            nodes.append({"type": "send_sticker", "file_id": "CAACAgUAAxkBAAIDlmDemoSticker"})
            summary.append("ðŸŽŸï¸ å‘é€è´´çº¸")
            continue
        if "è¯­éŸ³" in line:
            nodes.append({"type": "send_voice", "url": "https://example.com/demo.ogg", "caption": "", "parse_mode": ""})
            summary.append("ðŸŽ¤ å‘é€è¯­éŸ³")
            continue
        if "http" in lower or "è¯·æ±‚" in line:
            url = _extract_between(line, "http", "") or "https://api.example.com"
            nodes.append({
                "type": "http",
                "method": "GET",
                "url": url.strip() or "https://api.example.com",
                "headers": "{}",
                "body": "",
                "save_to": {"scope": "chat", "key": "resp"},
            })
            summary.append("ðŸŒ æ·»åŠ  HTTP è¯·æ±‚")
            continue

    if not nodes:
        nodes.append({"type": "send_text", "text": "ä½ å¥½ï¼Œæˆ‘æ˜¯æœºå™¨äººï½ž", "parse_mode": "", "disable_preview": False})
        summary.append("âš ï¸ æœªè¯†åˆ«ä¼ªä»£ç ï¼Œç”Ÿæˆé»˜è®¤æ¬¢è¿Žæ–‡æœ¬")

    command = command or "/auto"
    compiled = {
        "version": 1,
        "entries": [
            {
                "id": "auto1",
                "type": "on_command",
                "command": command,
                "nodes": nodes,
            }
        ],
    }
    flow_name = title.strip() or f"ä¼ªä»£ç æµç¨‹ {command}"
    explanation = "\n".join(summary)
    return {"name": flow_name, "compiled": compiled, "summary": explanation, "command": command}


def simulate_flow(compiled: Dict[str, Any], user_text: str = "/demo") -> Dict[str, Any]:
    entries = (compiled or {}).get("entries") or []
    if not entries:
        return {"actions": [], "summary": "æœªæ‰¾åˆ°å…¥å£ï¼Œæ— æ³•æ¨¡æ‹Ÿã€‚"}
    nodes = entries[0].get("nodes") or []
    actions: List[Dict[str, Any]] = []
    for node in nodes:
        ntype = (node or {}).get("type")
        if ntype == "send_text":
            actions.append({"type": "send_text", "text": node.get("text", "")})
        elif ntype == "send_text_keyboard":
            actions.append({
                "type": "send_text_keyboard",
                "text": node.get("text", ""),
                "buttons": node.get("keyboard", []),
            })
        elif ntype == "send_voice":
            actions.append({"type": "send_voice", "url": node.get("url"), "caption": node.get("caption", "")})
        elif ntype == "send_sticker":
            actions.append({"type": "send_sticker", "file_id": node.get("file_id")})
        elif ntype == "wait_next":
            actions.append({"type": "wait_next", "expect": node.get("expect", "any"), "prompt": node.get("prompt", "")})
        elif ntype == "delay":
            actions.append({"type": "delay", "seconds": node.get("seconds", 1)})
        elif ntype == "http":
            actions.append({"type": "http", "method": node.get("method"), "url": node.get("url")})
        else:
            actions.append({"type": ntype or "unknown", "detail": node})
    summary = f"å…±æ¨¡æ‹Ÿ {len(actions)} æ­¥åŠ¨ä½œã€‚"
    return {"actions": actions, "summary": summary}


def _slugify(text: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", text.lower()) or "flow"


def ai_generate_pseudocode(prompt: str) -> Dict[str, str]:
    base = prompt.strip() or "æ™ºèƒ½åŠ©æ‰‹"
    slug = _slugify(base)[:10]
    command = f"/{slug or 'auto'}"
    title = f"{base} è‡ªåŠ¨åŒ–æµç¨‹"
    buttons = ["åŠŸèƒ½ä»‹ç»", "ä»·æ ¼æ–¹æ¡ˆ", "è½¬äººå·¥"]
    pseudo = [
        f"1. å½“ç”¨æˆ·å‘é€ {command}",
        f"2. æœºå™¨äººå‘é€æ–‡æœ¬ã€Œä½ å¥½ï¼Œæ„Ÿè°¢å…³æ³¨{base}ã€",
        "3. æœºå™¨äººå‘é€æ–‡æœ¬å¹¶é™„å¸¦æŒ‰é’®ï¼ŒæŒ‰é’®åŒ…æ‹¬ã€ŒåŠŸèƒ½ä»‹ç»ã€ã€Œä»·æ ¼æ–¹æ¡ˆã€ã€Œè½¬äººå·¥ã€",
        "4. ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆæ•°å­—ï¼‰ï¼Œæç¤ºã€Œè¯·å›žå¤ 1-3 é€‰æ‹©æœåŠ¡ã€",
        "5. å¦‚æžœç”¨æˆ·è¾“å…¥ 1ï¼Œæœºå™¨äººå‘é€æ–‡æœ¬ã€Œè¿™é‡Œæ˜¯åŠŸèƒ½ä»‹ç»ã€",
        "6. å¦‚æžœç”¨æˆ·è¾“å…¥ 2ï¼Œæœºå™¨äººå‘é€æ–‡æœ¬ã€Œæˆ‘ä»¬çš„é”€å”®å›¢é˜Ÿä¼šè”ç³»ä½ ã€",
        "7. å¦‚æžœç”¨æˆ·è¾“å…¥ 3ï¼Œæœºå™¨äººå‘é€æ–‡æœ¬ã€Œæ­£åœ¨ä¸ºä½ è½¬æŽ¥äººå·¥ã€",
    ]
    return {"title": title, "content": "\n".join(pseudo), "command": command, "buttons": buttons}


def ai_generate_command_skeleton(prompt: str) -> Dict[str, Any]:
    base = prompt.strip() or "ç¤ºä¾‹æŒ‡ä»¤"
    slug = _slugify(base)[:12]
    command = f"/{slug or 'cmd'}"
    reply = f"{base}ï¼šè¿™æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„å›žå¤ï¼ŒåŒ…å«å…³é”®è¯ {{args}}"
    return {
        "command": command,
        "kind": "text",
        "reply": reply,
        "parse_mode": "",
        "disable_preview": False,
    }


__all__ = [
    "generate_flow_from_pseudocode",
    "simulate_flow",
    "ai_generate_pseudocode",
    "ai_generate_command_skeleton",
]

```
----- END FILE: core/pseudo.py -----


----- BEGIN FILE: core/runtime.py -----
# Size: 17.9KB | Lines: 448
```python
"""Bot runtime management."""
import asyncio, threading, time, json, re
from typing import Dict, Optional, List
from collections import deque

from telegram import Update, BotCommand
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters

from .flows import load_vms_for_bot
from data.database import list_pro_scripts


def _resolve_path(ctx: dict, path: str):
    cur = ctx
    for part in path.split("."):
        if isinstance(cur, dict) and part in cur:
            cur = cur[part]
        else:
            return ""
    return "" if cur is None else cur


def _render(tpl: str | None, ctx: dict) -> str:
    if not tpl:
        return ""

    def _sub(m):
        key = m.group(1).strip()
        val = _resolve_path(ctx, key)
        return str(val)

    return re.sub(r"\{\{\s*([\w\.]+)\s*\}\}", _sub, tpl)


class BotProcess:
    """å•ä¸ª Bot çš„è¿è¡Œè¿›ç¨‹ï¼ˆçº¿ç¨‹+äº‹ä»¶å¾ªçŽ¯ï¼‰ï¼Œæ”¯æŒå›ºå®šå‘½ä»¤ + Flow + Pro è„šæœ¬ã€‚"""

    def __init__(self, bot_id: int, token: str, command_specs: List[dict], *, auto_restart: bool = True):
        self.bot_id = bot_id
        self.token = token
        self.specs = list(command_specs)
        self.state = "stopped"
        self.last_error: Optional[str] = None
        self.started_at: Optional[float] = None
        self.auto_restart = auto_restart

        self._thread: Optional[threading.Thread] = None
        self._loop: Optional[asyncio.AbstractEventLoop] = None
        self._app: Optional[Application] = None
        self._stop_evt: Optional[asyncio.Event] = None

        self._vms = []
        self._pro_scripts = []

        self.events = deque(maxlen=200)
        self.stats = {"messages": 0, "errors": 0}
        self._log("process created")

    def _log(self, msg: str, level: str = "info"):
        self.events.append({"ts": time.time(), "level": level, "msg": msg})

    def snapshot(self):
        uptime = (time.time() - self.started_at) if (self.started_at and self.state == "running") else 0
        return {
            "bot_id": self.bot_id,
            "state": self.state,
            "started_at": self.started_at,
            "uptime": int(uptime),
            "last_error": self.last_error,
            "stats": dict(self.stats),
            "specs_count": len(self.specs),
            "flows_count": len(getattr(self, "_vms", [])),
            "pro_scripts_count": len(getattr(self, "_pro_scripts", [])),
        }

    def recent_logs(self, n: int = 100):
        return list(self.events)[-n:]

    def _make_handlers(self):
        handlers: List[CommandHandler] = []

        async def start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
            await update.message.reply_text("Bot å·²ä¸Šçº¿ï½ž /help æŸ¥çœ‹å‘½ä»¤")

        async def help_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
            lines = [f"{s['command']} â†’ {s.get('reply') or s.get('kind', 'text')}" for s in self.specs]
            for vm in self._vms:
                for entry in vm.blocks.get("entries", []):
                    if entry.get("type") == "on_command" and entry.get("command"):
                        lines.append(f"{entry['command']} â†’ flow")
            for script in self._pro_scripts:
                lines.append(f"{script['command']} â†’ pro_script")

            txt = "å¯ç”¨å‘½ä»¤ï¼š\n" + ("\n".join(sorted(set(lines))) if lines else "æš‚æ— ")
            await update.message.reply_text(txt)

        handlers.append(CommandHandler("start", start))
        handlers.append(CommandHandler("help", help_cmd))

        for spec in self.specs:
            cmd = spec["command"].lstrip("/")
            kind = (spec.get("kind") or "text").lower()
            reply = spec.get("reply") or ""
            payload_raw = spec.get("payload")
            parse_mode = spec.get("parse_mode") or None
            disable_preview = bool(spec.get("disable_preview", 0))
            try:
                payload = json.loads(payload_raw) if (payload_raw and isinstance(payload_raw, str)) else (
                            payload_raw or {})
            except Exception:
                payload = {}

            async def _h(update: Update, ctx: ContextTypes.DEFAULT_TYPE,
                         _kind=kind, _reply=reply, _payload=payload,
                         _parse=parse_mode, _no_preview=disable_preview):
                self.stats["messages"] += 1
                try:
                    message = update.message or update.effective_message
                    user = update.effective_user
                    chat = update.effective_chat
                    args = ctx.args or []
                    context = {
                        "args": " ".join(args), "arg0": args[0] if args else "",
                        "user": {"id": user.id, "username": user.username, "first_name": user.first_name,
                                 "last_name": user.last_name} if user else {},
                        "chat": {"id": chat.id, "type": chat.type} if chat else {},
                    }

                    if _kind == "text":
                        text = _render((_payload.get("text") if isinstance(_payload, dict) else None) or _reply,
                                       context)
                        await message.reply_text(text, parse_mode=_parse, disable_web_page_preview=_no_preview)
                    elif _kind == "photo":
                        url = _render(_payload.get("url"), context)
                        caption = _render(_payload.get("caption"), context)
                        await ctx.bot.send_photo(chat_id=chat.id, photo=url, caption=caption, parse_mode=_parse)
                    elif _kind == "document":
                        url = _render(_payload.get("url"), context)
                        caption = _render(_payload.get("caption"), context)
                        await ctx.bot.send_document(chat_id=chat.id, document=url, caption=caption, parse_mode=_parse)
                    elif _kind == "animation":
                        url = _render(_payload.get("url"), context)
                        caption = _render(_payload.get("caption"), context)
                        await ctx.bot.send_animation(chat_id=chat.id, animation=url, caption=caption, parse_mode=_parse)
                    else:
                        await message.reply_text(f"æœªçŸ¥å›žåº”ç±»åž‹ï¼š{_kind}")
                except Exception as e:
                    self.stats["errors"] += 1;
                    self.last_error = repr(e)
                    self._log(self.last_error, level="error");
                    raise

            handlers.append(CommandHandler(cmd, _h))
        return handlers

    async def _make_pro_script_handlers(self):
        handlers = []
        self._pro_scripts = [s for s in list_pro_scripts(self.bot_id) if s.get('active')]
        self._log(f"pro scripts loaded: {len(self._pro_scripts)}")

        for script in self._pro_scripts:
            cmd = script["command"].lstrip("/")
            code = script["code"]

            async def make_handler(user_code):
                sandbox_log = lambda msg: self._log(f"[script:{cmd}] {msg}")
                wrapped_code = f"async def user_handler(bot, update, context, log):\n"
                for line in user_code.splitlines():
                    wrapped_code += f"    {line}\n"

                local_scope = {}

                # ä¿®å¤: æä¾›ä¸€ä¸ªæ›´å®Œæ•´çš„ã€å®‰å…¨çš„å…¨å±€çŽ¯å¢ƒ
                sandbox_globals = {
                    "__builtins__": __builtins__,  # å…è®¸æ‰€æœ‰å®‰å…¨çš„å†…å»ºå‡½æ•°
                    "asyncio": asyncio,
                    "aiohttp": __import__("aiohttp"),
                    "json": __import__("json"),
                }

                exec(wrapped_code, sandbox_globals, local_scope)

                async def final_handler(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
                    self.stats["messages"] += 1
                    try:
                        await local_scope['user_handler'](ctx.bot, update, ctx, sandbox_log)
                    except Exception as e:
                        self.stats["errors"] += 1;
                        self.last_error = f"Script {cmd} error: {repr(e)}"
                        self._log(self.last_error, level="error")
                        try:
                            await update.effective_message.reply_text(f"è„šæœ¬æ‰§è¡Œå‡ºé”™ï¼š{e}")
                        except Exception:
                            pass

                return final_handler

            try:
                handler_func = await make_handler(code)
                handlers.append(CommandHandler(cmd, handler_func))
            except Exception as e:
                self._log(f"Failed to compile script for /{cmd}: {e}", level="error")
        return handlers

    async def _build_app(self):
        app = Application.builder().token(self.token).build()

        self._vms = load_vms_for_bot(self.bot_id)
        self._log(f"flows loaded: {len(self._vms)}")

        for h in self._make_handlers():
            app.add_handler(h)

        # æ ¸å¿ƒä¿®å¤: åœ¨è°ƒç”¨ async def å‡½æ•°æ—¶æ·»åŠ  await
        for h in await self._make_pro_script_handlers():
            app.add_handler(h)

        flow_cmds = {entry["command"].lstrip("/") for vm in self._vms for entry in vm.blocks.get("entries", []) if
                     entry.get("type") == "on_command" and entry.get("command")}

        async def _dynamic_command(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
            self.stats["messages"] += 1
            try:
                cmd = (update.effective_message.text or "").split()[0].lstrip("/")
                for vm in self._vms:
                    for entry in vm.blocks.get("entries", []):
                        if entry.get("type") == "on_command" and entry.get("command", "").lstrip("/") == cmd:
                            await vm.run_entry(app, update, ctx, entry)
            except Exception as e:
                self.stats["errors"] += 1;
                self.last_error = repr(e)
                self._log(self.last_error, level="error");
                raise

        if flow_cmds:
            app.add_handler(CommandHandler(list(flow_cmds), _dynamic_command))
        self._log(f"flow commands: {sorted(list(flow_cmds))}")

        async def _resume(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
            self.stats["messages"] += 1
            try:
                for vm in self._vms:
                    if await vm.maybe_resume(app, update, ctx): return
            except Exception as e:
                self.stats["errors"] += 1;
                self.last_error = repr(e)
                self._log(self.last_error, level="error");
                raise

        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), _resume))

        async def _on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
            self.stats["errors"] += 1;
            self.last_error = repr(context.error)
            self._log(self.last_error, level="error")

        app.add_error_handler(_on_error)

        all_cmds: Dict[str, str] = {}
        for s in self.specs: all_cmds[s["command"].lstrip("/")] = (s.get("reply") or s.get("kind") or "cmd")[:32]
        for c in flow_cmds: all_cmds.setdefault(c, "flow")
        for s in self._pro_scripts: all_cmds.setdefault(s["command"].lstrip("/"), s.get("name", "pro_script")[:32])

        cmds = [BotCommand(k, v) for k, v in list(all_cmds.items())[:100]]
        await app.bot.set_my_commands(cmds)
        self._log(f"commands set: {len(cmds)}")

        return app

    async def _runner(self):
        self.state = "starting";
        self.last_error = None
        self._stop_evt = asyncio.Event()
        self._log("starting")
        self._app = await self._build_app()
        try:
            await self._app.initialize()
            await self._app.start()
            await self._app.updater.start_polling(drop_pending_updates=True)
            self.state = "running";
            self.started_at = time.time()
            self._log("running")
            await self._stop_evt.wait()
        except Exception as e:
            self.last_error = repr(e);
            self.state = "errored"
            self._log(self.last_error, level="error")
            raise
        finally:
            try:
                if self._app:
                    await self._app.updater.stop()
                    await self._app.stop()
                    await self._app.shutdown()
            finally:
                self.state = "stopped";
                self.started_at = None
                self._app = None;
                self._stop_evt = None
                self._log("stopped")

    # --- start, stop, reload, sync ç­‰ç”Ÿå‘½å‘¨æœŸå‡½æ•°ä¿æŒä¸å˜ ---
    def start(self):
        if self._thread and self._thread.is_alive(): return True, "å·²åœ¨è¿è¡Œ"
        self._loop = asyncio.new_event_loop()
        self._log("start requested")

        def _target():
            asyncio.set_event_loop(self._loop)
            try:
                self._loop.run_until_complete(self._runner())
            finally:
                tasks = asyncio.all_tasks(loop=self._loop)
                for t in tasks: t.cancel()
                try:
                    self._loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))
                except:
                    pass
                self._loop.close()

        self._thread = threading.Thread(target=_target, daemon=True)
        self._thread.start()
        return True, "å·²å¯åŠ¨"

    def reload(self, token: str, specs: List[dict]):
        self._log("reload requested")
        self.stop()
        self.token = token
        self.specs = list(specs)
        return self.start()

    def stop(self, timeout=6.0):
        self._log("stop requested")
        if not (self._thread and self._thread.is_alive()):
            self.state = "stopped";
            return True, "æœªåœ¨è¿è¡Œ"
        if self._loop and self._stop_evt:
            self._loop.call_soon_threadsafe(self._stop_evt.set)
        self._thread.join(timeout=timeout)
        if self._thread.is_alive():
            self.state = "stopping";
            return False, "åœæ­¢è¶…æ—¶"
        self._thread = None;
        self._loop = None
        return True, "å·²åœæ­¢"

    def sync_commands(self):
        if not (self._loop and self._app): return False, "æœªåœ¨è¿è¡Œ"

        async def _set():
            all_cmds: Dict[str, str] = {}
            for s in self.specs: all_cmds[s["command"].lstrip("/")] = (s.get("reply") or s.get("kind") or "cmd")[:32]
            flow_cmds = {e["command"].lstrip("/") for vm in self._vms for e in vm.blocks.get("entries", []) if
                         e.get("type") == "on_command" and e.get("command")}
            for c in flow_cmds: all_cmds.setdefault(c, "flow")
            for s in self._pro_scripts: all_cmds.setdefault(s["command"].lstrip("/"), s.get("name", "pro_script")[:32])
            cmds = [BotCommand(k, v) for k, v in list(all_cmds.items())[:100]]
            await self._app.bot.set_my_commands(cmds)
            self._log(f"commands synced: {len(cmds)}")

        fut = asyncio.run_coroutine_threadsafe(_set(), self._loop)
        fut.result(timeout=5);
        return True, "å·²åŒæ­¥"

    def is_thread_alive(self) -> bool:
        return bool(self._thread and self._thread.is_alive())

    def needs_restart(self) -> bool:
        if not self.auto_restart: return False
        if self.state in ("errored", "stopped"): return True
        if self.state == "running" and not self.is_thread_alive(): return True
        return False

    def restart(self):
        self._log("auto restart triggered")
        if self.is_thread_alive(): self.stop()
        return self.start()


class BotRegistry:
    def __init__(self):
        self._lock = threading.Lock()
        self._procs: Dict[int, BotProcess] = {}

    def status(self, bot_id: int):
        with self._lock:
            self._ensure_process_health(bot_id)
            p = self._procs.get(bot_id)
            if not p:
                return {
                    "bot_id": bot_id, "state": "stopped", "started_at": None, "uptime": 0,
                    "last_error": None, "stats": {"messages": 0, "errors": 0},
                    "specs_count": 0, "flows_count": 0, "pro_scripts_count": 0,
                }
            snap = p.snapshot()
            snap.setdefault("bot_id", bot_id)
            if "stats" not in snap or not isinstance(snap.get("stats"), dict):
                snap["stats"] = {"messages": 0, "errors": 0}
            snap.setdefault("uptime", 0)
            return snap

    def start(self, bot_id: int, token: str, specs: List[dict]):
        with self._lock:
            p = self._procs.get(bot_id)
            if p: return p.reload(token, specs)
            p = BotProcess(bot_id, token, specs)
            self._procs[bot_id] = p
            return p.start()

    def stop(self, bot_id: int):
        with self._lock:
            p = self._procs.get(bot_id)
            if not p: return True, "æœªåœ¨è¿è¡Œ"
            ok, msg = p.stop()
            if ok: self._procs.pop(bot_id, None)
            return ok, msg

    def sync(self, bot_id: int):
        with self._lock:
            p = self._procs.get(bot_id)
            if not p: return False, "æœªåœ¨è¿è¡Œ"
            return p.sync_commands()

    def status_all(self):
        with self._lock:
            self._ensure_process_health()
            return {bid: p.snapshot() for bid, p in self._procs.items()}

    def logs(self, bot_id: int, lines: int = 100):
        with self._lock:
            p = self._procs.get(bot_id)
            if not p: return []
            return p.recent_logs(lines)

    def _ensure_process_health(self, bot_id: Optional[int] = None):
        items = [(bot_id, self._procs.get(bot_id))] if bot_id is not None else list(self._procs.items())
        for bid, proc in items:
            if not proc: continue
            if proc.needs_restart():
                ok, msg = proc.restart()
                if not ok:
                    proc._log(f"auto restart failed: {msg}", level="error")


registry = BotRegistry()


__all__ = ["BotProcess", "BotRegistry", "registry"]

```
----- END FILE: core/runtime.py -----


----- BEGIN FILE: data/__init__.py -----
# Size: 176B | Lines: 6
```python
"""Public data-layer exports."""
from . import database as _database

__all__ = list(_database.__all__)

globals().update({name: getattr(_database, name) for name in __all__})

```
----- END FILE: data/__init__.py -----


----- BEGIN FILE: data/database.py -----
# Size: 15.0KB | Lines: 465
```python
"""SQLite access helpers for the BotAdmin project."""
from __future__ import annotations

import hashlib
import sqlite3
from contextlib import contextmanager
from typing import Dict, List, Optional, Tuple

from config import get_settings

SETTINGS = get_settings()


def _row_factory(cursor, row):
    mapped = {}
    for idx, col in enumerate(cursor.description):
        mapped[col[0]] = row[idx]
    return mapped


@contextmanager
def get_conn():
    settings = SETTINGS
    settings.db_path.parent.mkdir(parents=True, exist_ok=True)
    con = sqlite3.connect(settings.db_path_str)
    con.row_factory = _row_factory
    con.execute("PRAGMA foreign_keys = ON;")
    try:
        yield con
        con.commit()
    finally:
        con.close()


def init_db() -> bool:
    with get_conn() as con:
        con.executescript(
            """
            CREATE TABLE IF NOT EXISTS users(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );

            CREATE TABLE IF NOT EXISTS bots(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                token TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS commands(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_id INTEGER NOT NULL,
                command TEXT NOT NULL,
                kind TEXT DEFAULT 'text',
                reply TEXT,
                payload TEXT,
                parse_mode TEXT,
                disable_preview INTEGER DEFAULT 0,
                UNIQUE(bot_id, command),
                FOREIGN KEY(bot_id) REFERENCES bots(id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS flows(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                blocks_json TEXT NOT NULL,
                active INTEGER DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(bot_id) REFERENCES bots(id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS pro_scripts(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                command TEXT NOT NULL,
                code TEXT NOT NULL,
                active INTEGER DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(bot_id, command),
                FOREIGN KEY(bot_id) REFERENCES bots(id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS kv_store(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_id INTEGER NOT NULL,
                scope TEXT NOT NULL,
                chat_id TEXT DEFAULT '',
                user_id TEXT DEFAULT '',
                key TEXT NOT NULL,
                value TEXT,
                UNIQUE(bot_id, scope, chat_id, user_id, key),
                FOREIGN KEY(bot_id) REFERENCES bots(id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS pseudocode(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_id INTEGER NOT NULL,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(bot_id) REFERENCES bots(id) ON DELETE CASCADE
            );
            """
        )
    return True


def hash_password(pw: str) -> str:
    return hashlib.sha256(pw.encode("utf-8")).hexdigest()


def create_user(username: str, password: str) -> Tuple[bool, Optional[str]]:
    username = (username or "").strip()
    password = (password or "").strip()
    if not username or not password:
        return False, "ç”¨æˆ·å/å¯†ç ä¸èƒ½ä¸ºç©º"
    with get_conn() as con:
        try:
            con.execute(
                "INSERT INTO users(username, password_hash) VALUES (?,?)",
                (username, hash_password(password)),
            )
            return True, None
        except sqlite3.IntegrityError:
            return False, "ç”¨æˆ·åå·²å­˜åœ¨"


def get_user_by_username(username: str) -> Optional[Dict]:
    with get_conn() as con:
        cur = con.execute("SELECT * FROM users WHERE username=?", (username,))
        return cur.fetchone()


def get_user_by_id(uid: int) -> Optional[Dict]:
    with get_conn() as con:
        cur = con.execute("SELECT * FROM users WHERE id=?", (uid,))
        return cur.fetchone()


def create_bot(user_id: int, name: str, token: str) -> Tuple[bool, Optional[str]]:
    if not name or not token:
        return False, "name/token å¿…å¡«"
    with get_conn() as con:
        con.execute(
            "INSERT INTO bots(user_id,name,token) VALUES (?,?,?)",
            (user_id, name, token),
        )
    return True, None


def list_bots(user_id: int) -> List[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id,name,token,created_at FROM bots WHERE user_id=? ORDER BY id DESC",
            (user_id,),
        )
        return cur.fetchall() or []


def get_bot(user_id: int, bot_id: int) -> Optional[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT * FROM bots WHERE id=? AND user_id=?",
            (bot_id, user_id),
        )
        return cur.fetchone()


def get_bot_by_id(bot_id: int) -> Optional[Dict]:
    with get_conn() as con:
        cur = con.execute("SELECT * FROM bots WHERE id=?", (bot_id,))
        return cur.fetchone()


def delete_bot(user_id: int, bot_id: int) -> Tuple[bool, Optional[str]]:
    with get_conn() as con:
        cur = con.execute("DELETE FROM bots WHERE id=? AND user_id=?", (bot_id, user_id))
        if cur.rowcount == 0:
            return False, "æ— æ­¤ bot æˆ–æ— æƒé™"
    return True, None


def list_commands(bot_id: int) -> List[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id,command,kind,reply,payload,parse_mode,disable_preview "
            "FROM commands WHERE bot_id=? ORDER BY command",
            (bot_id,),
        )
        return cur.fetchall() or []


def upsert_command(
    bot_id: int,
    command: str,
    kind: str,
    reply: Optional[str],
    payload: Optional[str],
    parse_mode: Optional[str],
    disable_preview: int,
) -> Tuple[bool, Optional[str]]:
    if not command:
        return False, "command ä¸èƒ½ä¸ºç©º"
    if not command.startswith("/"):
        command = "/" + command
    with get_conn() as con:
        con.execute(
            """
            INSERT INTO commands(bot_id,command,kind,reply,payload,parse_mode,disable_preview)
            VALUES (?,?,?,?,?,?,?)
            ON CONFLICT(bot_id,command) DO UPDATE SET
              kind=excluded.kind,
              reply=excluded.reply,
              payload=excluded.payload,
              parse_mode=excluded.parse_mode,
              disable_preview=excluded.disable_preview
            """,
            (bot_id, command, kind or "text", reply, payload, parse_mode, int(bool(disable_preview))),
        )
    return True, None


def delete_command(bot_id: int, command: str) -> Tuple[bool, Optional[str]]:
    if not command:
        return False, "command ä¸èƒ½ä¸ºç©º"
    if not command.startswith("/"):
        command = "/" + command
    with get_conn() as con:
        cur = con.execute(
            "DELETE FROM commands WHERE bot_id=? AND command=?",
            (bot_id, command),
        )
        if cur.rowcount == 0:
            return False, "æœªæ‰¾åˆ°è¯¥å‘½ä»¤"
    return True, None


def erase_commands(bot_id: int) -> Tuple[bool, Optional[str]]:
    with get_conn() as con:
        con.execute("DELETE FROM commands WHERE bot_id=?", (bot_id,))
    return True, None


def list_flows(bot_id: int) -> List[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id,name,blocks_json,active,created_at,updated_at "
            "FROM flows WHERE bot_id=? ORDER BY id DESC",
            (bot_id,),
        )
        return cur.fetchall() or []


def upsert_flow(
    bot_id: int,
    name: str,
    blocks_json: str,
    flow_id: Optional[int] = None,
    active: int = 1,
) -> Tuple[bool, Optional[str], Optional[int]]:
    if not name or not blocks_json:
        return False, "name/blocks_json ä¸èƒ½ä¸ºç©º", None
    with get_conn() as con:
        if flow_id:
            con.execute(
                "UPDATE flows SET name=?, blocks_json=?, active=?, updated_at=CURRENT_TIMESTAMP WHERE id=? AND bot_id=?",
                (name, blocks_json, int(bool(active)), flow_id, bot_id),
            )
            return True, None, flow_id
        cur = con.execute(
            "INSERT INTO flows(bot_id,name,blocks_json,active) VALUES(?,?,?,?)",
            (bot_id, name, blocks_json, int(bool(active))),
        )
        return True, None, cur.lastrowid


def delete_flow(bot_id: int, flow_id: int) -> Tuple[bool, Optional[str]]:
    with get_conn() as con:
        cur = con.execute("DELETE FROM flows WHERE id=? AND bot_id=?", (flow_id, bot_id))
        if cur.rowcount == 0:
            return False, "æœªæ‰¾åˆ°è¯¥æµç¨‹"
    return True, None


def list_pro_scripts(bot_id: int) -> List[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id, name, command, code, active, created_at, updated_at "
            "FROM pro_scripts WHERE bot_id=? ORDER BY command",
            (bot_id,),
        )
        return cur.fetchall() or []


def upsert_pro_script(
    bot_id: int,
    name: str,
    command: str,
    code: str,
    script_id: Optional[int] = None,
    active: int = 1,
) -> Tuple[bool, Optional[str], Optional[int]]:
    name = (name or "").strip()
    command = (command or "").strip()
    code = (code or "").strip()
    if not all([name, command, code]):
        return False, "åç§°ã€å‘½ä»¤å’Œä»£ç éƒ½ä¸èƒ½ä¸ºç©º", None
    if not command.startswith("/"):
        command = "/" + command

    with get_conn() as con:
        try:
            if script_id:
                cur = con.execute(
                    "UPDATE pro_scripts SET name=?, command=?, code=?, active=?, updated_at=CURRENT_TIMESTAMP WHERE id=? AND bot_id=?",
                    (name, command, code, int(bool(active)), script_id, bot_id),
                )
                if cur.rowcount == 0:
                    return False, "æœªæ‰¾åˆ°è¯¥è„šæœ¬æˆ–æ— æƒé™", script_id
                return True, None, script_id
            cur = con.execute(
                "INSERT INTO pro_scripts(bot_id, name, command, code, active) VALUES(?,?,?,?,?)",
                (bot_id, name, command, code, int(bool(active))),
            )
            return True, None, cur.lastrowid
        except sqlite3.IntegrityError:
            return False, f"å‘½ä»¤ '{command}' å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–å‘½ä»¤", None


def delete_pro_script(bot_id: int, script_id: int) -> Tuple[bool, Optional[str]]:
    with get_conn() as con:
        cur = con.execute("DELETE FROM pro_scripts WHERE id=? AND bot_id=?", (script_id, bot_id))
        if cur.rowcount == 0:
            return False, "æœªæ‰¾åˆ°è¯¥è„šæœ¬"
    return True, None


def list_pseudocode(bot_id: int) -> List[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id, title, content, created_at, updated_at FROM pseudocode "
            "WHERE bot_id=? ORDER BY id DESC",
            (bot_id,),
        )
        return cur.fetchall() or []


def upsert_pseudocode(
    bot_id: int,
    title: str,
    content: str,
    pseudo_id: Optional[int] = None,
) -> Tuple[bool, Optional[str], Optional[int]]:
    title = (title or "").strip()
    content = (content or "").strip()
    if not title or not content:
        return False, "æ ‡é¢˜/å†…å®¹ä¸èƒ½ä¸ºç©º", None
    with get_conn() as con:
        if pseudo_id:
            cur = con.execute(
                "UPDATE pseudocode SET title=?, content=?, updated_at=CURRENT_TIMESTAMP WHERE id=? AND bot_id=?",
                (title, content, pseudo_id, bot_id),
            )
            if cur.rowcount == 0:
                return False, "æœªæ‰¾åˆ°è¯¥ä¼ªä»£ç ", None
            return True, None, pseudo_id
        cur = con.execute(
            "INSERT INTO pseudocode(bot_id, title, content) VALUES (?,?,?)",
            (bot_id, title, content),
        )
        return True, None, cur.lastrowid


def delete_pseudocode(bot_id: int, pseudo_id: int) -> Tuple[bool, Optional[str]]:
    with get_conn() as con:
        cur = con.execute(
            "DELETE FROM pseudocode WHERE id=? AND bot_id=?",
            (pseudo_id, bot_id),
        )
        if cur.rowcount == 0:
            return False, "æœªæ‰¾åˆ°è¯¥ä¼ªä»£ç "
    return True, None


def get_pseudocode(bot_id: int, pseudo_id: int) -> Optional[Dict]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT id, title, content, created_at, updated_at FROM pseudocode WHERE id=? AND bot_id=?",
            (pseudo_id, bot_id),
        )
        return cur.fetchone()


def _nz(value: Optional[str]) -> str:
    return "" if value is None else str(value)


def kv_get(bot_id: int, scope: str, chat_id: Optional[str], user_id: Optional[str], key: str) -> Optional[str]:
    with get_conn() as con:
        cur = con.execute(
            "SELECT value FROM kv_store WHERE bot_id=? AND scope=? AND chat_id=? AND user_id=? AND key=?",
            (bot_id, scope, _nz(chat_id), _nz(user_id), key),
        )
        row = cur.fetchone()
        return None if not row else row["value"]


def kv_set(bot_id: int, scope: str, chat_id: Optional[str], user_id: Optional[str], key: str, value) -> None:
    with get_conn() as con:
        if value is None:
            con.execute(
                "DELETE FROM kv_store WHERE bot_id=? AND scope=? AND chat_id=? AND user_id=? AND key=?",
                (bot_id, scope, _nz(chat_id), _nz(user_id), key),
            )
            return
        con.execute(
            """
            INSERT INTO kv_store(bot_id,scope,chat_id,user_id,key,value)
            VALUES (?,?,?,?,?,?)
            ON CONFLICT(bot_id,scope,chat_id,user_id,key) DO UPDATE SET
              value=excluded.value
            """,
            (bot_id, scope, _nz(chat_id), _nz(user_id), key, str(value)),
        )


__all__ = [
    "get_conn",
    "init_db",
    "hash_password",
    "create_user",
    "get_user_by_username",
    "get_user_by_id",
    "create_bot",
    "list_bots",
    "get_bot",
    "get_bot_by_id",
    "delete_bot",
    "list_commands",
    "upsert_command",
    "delete_command",
    "erase_commands",
    "list_flows",
    "upsert_flow",
    "delete_flow",
    "list_pro_scripts",
    "upsert_pro_script",
    "delete_pro_script",
    "list_pseudocode",
    "upsert_pseudocode",
    "delete_pseudocode",
    "get_pseudocode",
    "kv_get",
    "kv_set",
]

```
----- END FILE: data/database.py -----


----- BEGIN FILE: db.py -----
# Size: 180B | Lines: 5
```python
"""Legacy shim for data access; use `data.database` instead."""
from data.database import *  # noqa: F401,F403
import data.database as _database

__all__ = list(_database.__all__)

```
----- END FILE: db.py -----


----- BEGIN FILE: flow_engine.py -----
# Size: 147B | Lines: 5
```python
"""Legacy shim for flow engine helpers."""
from core.flows import *  # noqa: F401,F403
import core.flows as _flows

__all__ = list(_flows.__all__)

```
----- END FILE: flow_engine.py -----


----- BEGIN FILE: ftp.py -----
# Size: 6.1KB | Lines: 180
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Pack a project's .py and .html files into a single TXT prompt.
- Shows a tree (only included file types)
- Appends each file's content with clear delimiters
- Uses input() for a simple, zero-deps UX
"""

from __future__ import annotations
import os
import sys
import time
from typing import Dict, List, Tuple

SEP = os.sep

def ask(prompt: str, default: str | None = None) -> str:
    if default is None:
        return input(prompt).strip()
    val = input(f"{prompt} [é»˜è®¤: {default}] ").strip()
    return val or default

def human_bytes(n: int) -> str:
    for unit in ["B", "KB", "MB", "GB"]:
        if n < 1024.0:
            return f"{n:.1f}{unit}" if unit != "B" else f"{n}{unit}"
        n /= 1024.0
    return f"{n:.1f}TB"

def build_tree(paths: List[str]) -> Dict:
    """
    Build a nested dict tree from a list of relative file paths.
    Directories are dicts; files are stored as None values.
    """
    root: Dict = {}
    for rel in paths:
        parts = rel.split(SEP)
        cur = root
        for i, p in enumerate(parts):
            if i == len(parts) - 1:
                cur.setdefault("__files__", set()).add(p)
            else:
                cur = cur.setdefault(p, {})
    return root

def render_tree(tree: Dict, prefix: str = "") -> str:
    """
    Render the nested dict into an ASCII tree (only included files).
    """
    lines: List[str] = []
    # separate directories and files
    dirs = sorted([k for k in tree.keys() if k != "__files__"])
    files = sorted(list(tree.get("__files__", [])))

    def draw(items, pref: str):
        for idx, (name, is_dir) in enumerate(items):
            is_last = idx == len(items) - 1
            branch = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            lines.append(pref + branch + name)
            if is_dir:
                child = tree[name]
                continuation = pref + ("    " if is_last else "â”‚   ")
                sub = render_tree(child, continuation)
                if sub:
                    lines.append(sub)

    mixed = [(d, True) for d in dirs] + [(f, False) for f in files]
    draw(mixed, prefix)
    return "\n".join([s for s in lines if s != ""])

def collect_files(root_dir: str, ex_dirs: List[str], max_bytes: int) -> List[str]:
    chosen: List[str] = []
    ex_set = set(d.strip() for d in ex_dirs if d.strip())
    for cur, dirs, files in os.walk(root_dir):
        # prune excluded directories by name match at each depth
        dirs[:] = [d for d in dirs if d not in ex_set]
        for fn in files:
            low = fn.lower()
            if not (low.endswith(".py") or low.endswith(".html")):
                continue
            path = os.path.join(cur, fn)
            try:
                if os.path.getsize(path) > max_bytes:
                    continue
            except OSError:
                continue
            rel = os.path.relpath(path, root_dir)
            chosen.append(rel)
    chosen.sort()
    return chosen

def read_text(path: str) -> Tuple[str, int]:
    """
    Read text as UTF-8 with replacement to avoid crashes on odd encodings.
    Returns (content, line_count)
    """
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            txt = f.read()
    except Exception as e:
        txt = f"<<è¯»å–å¤±è´¥: {e}>>"
    return txt, txt.count("\n") + (1 if txt and not txt.endswith("\n") else 0)

def main():
    print("ðŸ§° é¡¹ç›®æ‰“åŒ…ä¸º TXT Promptï¼ˆä»… .py / .htmlï¼‰")
    root_dir = ask("è¯·è¾“å…¥é¡¹ç›®æ ¹ç›®å½•è·¯å¾„", os.getcwd())
    out_path = ask("è¾“å‡ºæ–‡ä»¶åï¼ˆå«è·¯å¾„ï¼‰", "project_prompt.txt")
    ex_default = ".git,.idea,.vscode,__pycache__,dist,build,node_modules,venv,.venv"
    ex_dirs = [s.strip() for s in ask("è¦æŽ’é™¤çš„ç›®å½•åï¼ˆé€—å·åˆ†éš”ï¼‰", ex_default).split(",")]
    max_kb = ask("å•æ–‡ä»¶å¤§å°ä¸Šé™ï¼ˆKBï¼‰", "512")
    try:
        max_bytes = int(float(max_kb) * 1024)
    except ValueError:
        print("âš ï¸ å¤§å°ä¸Šé™æ— æ•ˆï¼Œä½¿ç”¨ 512KB")
        max_bytes = 512 * 1024

    if not os.path.isdir(root_dir):
        print("âŒ æ ¹ç›®å½•ä¸å­˜åœ¨ã€‚")
        sys.exit(1)

    print("ðŸ”Ž æ‰«æä¸­â€¦â€¦")
    files = collect_files(root_dir, ex_dirs, max_bytes)
    if not files:
        print("ðŸ˜¶ æ²¡æ‰¾åˆ°éœ€è¦æ‰“åŒ…çš„æ–‡ä»¶ï¼ˆåªåŒ…å« .py / .html ä¸”ä¸è¶…è¿‡å¤§å°ä¸Šé™ï¼‰ã€‚")
        sys.exit(0)

    # Build structure tree
    tree = build_tree(files)
    tree_txt = render_tree(tree)

    total_bytes = 0
    total_lines = 0

    tstamp = time.strftime("%Y-%m-%d %H:%M:%S")
    header_lines = [
        f"# Project Prompt Export",
        f"# Time: {tstamp}",
        f"# Root: {os.path.abspath(root_dir)}",
        f"# Include: *.py, *.html",
        f"# Excluded dirs: {', '.join(ex_dirs)}",
        f"# Per-file size cap: {human_bytes(max_bytes)}",
        "",
        "## Project Structure (ä»…åŒ…å«è¢«æ‰“åŒ…çš„æ–‡ä»¶)",
        "```",
        tree_txt,
        "```",
        "",
        "## Files",
        ""
    ]

    with open(out_path, "w", encoding="utf-8", errors="replace") as out:
        out.write("\n".join(header_lines))
        for rel in files:
            abs_path = os.path.join(root_dir, rel)
            try:
                size = os.path.getsize(abs_path)
            except OSError:
                size = -1
            content, n_lines = read_text(abs_path)
            total_bytes += max(0, size)
            total_lines += n_lines

            out.write(f"\n\n----- BEGIN FILE: {rel} -----\n")
            out.write(f"# Size: {human_bytes(size if size >=0 else 0)} | Lines: {n_lines}\n")
            fence = "```html" if rel.lower().endswith(".html") else "```python"
            out.write(f"{fence}\n{content}\n```\n")
            out.write(f"----- END FILE: {rel} -----\n")

        out.write("\n\n## Summary\n")
        out.write(f"Total files: {len(files)}\n")
        out.write(f"Total size: {human_bytes(total_bytes)}\n")
        out.write(f"Total lines: {total_lines}\n")

    print(f"âœ… å®Œæˆï¼š{out_path}")
    print(f"ðŸ“¦ å…± {len(files)} ä¸ªæ–‡ä»¶ï¼Œ{human_bytes(total_bytes)}ï¼Œçº¦ {total_lines} è¡Œã€‚")

if __name__ == "__main__":
    main()

```
----- END FILE: ftp.py -----


----- BEGIN FILE: interact/__init__.py -----
# Size: 982B | Lines: 43
```python
"""Flask application factory."""
from __future__ import annotations

from flask import Flask, g, send_from_directory, session

from config import get_settings
from data import get_user_by_id, init_db

from .routes import api_bp
from .socket import init_socketio, socketio


def create_app() -> Flask:
    settings = get_settings()
    app = Flask(
        __name__,
        static_folder=settings.static_dir_str,
        static_url_path="/static",
    )
    app.secret_key = settings.secret_key
    app.config.update(
        SESSION_COOKIE_SAMESITE="Lax",
        SESSION_COOKIE_HTTPONLY=True,
    )

    init_db()

    @app.before_request
    def load_user():
        uid = session.get("user_id")
        g.user = get_user_by_id(uid) if uid else None

    @app.get("/")
    def index_html():
        return send_from_directory(settings.static_dir_str, "index.html")

    app.register_blueprint(api_bp)

    init_socketio(app)
    return app


__all__ = ["create_app", "socketio"]

```
----- END FILE: interact/__init__.py -----


----- BEGIN FILE: interact/routes/__init__.py -----
# Size: 564B | Lines: 18
```python
"""API blueprint and route registrations."""
from __future__ import annotations

from flask import Blueprint

api_bp = Blueprint("api", __name__, url_prefix="/api")

# Import modules to register routes on the blueprint
from . import auth  # noqa: E402,F401
from . import bots  # noqa: E402,F401
from . import commands  # noqa: E402,F401
from . import flows  # noqa: E402,F401
from . import pseudocode  # noqa: E402,F401
from . import pro_scripts  # noqa: E402,F401
from . import ai  # noqa: E402,F401
from . import runtime  # noqa: E402,F401

__all__ = ["api_bp"]

```
----- END FILE: interact/routes/__init__.py -----


----- BEGIN FILE: interact/routes/ai.py -----
# Size: 1.0KB | Lines: 28
```python
"""AI integration endpoints."""
from __future__ import annotations

import os

from flask import jsonify, request

from core.ai import generate_command as ai_generate_command
from core.ai import generate_pseudocode as ai_generate_pseudocode
from interact.security import login_required

from . import api_bp


@api_bp.post("/ai/generate")
@login_required
def api_ai_generate():
    data = request.get_json(silent=True) or {}
    mode = (data.get("mode") or "pseudocode").strip().lower()
    prompt = (data.get("prompt") or "").strip()
    if mode == "pseudocode":
        result, meta = ai_generate_pseudocode(prompt)
        return jsonify({"ok": True, "result": result, "meta": meta})
    if mode == "command":
        result, meta = ai_generate_command(prompt)
        return jsonify({"ok": True, "result": result, "meta": meta})
    configured = bool(os.environ.get("AI_API_KEY") or os.environ.get("DEEPSEEK_API_KEY"))
    return jsonify({"ok": False, "error": "æš‚ä¸æ”¯æŒçš„ç”Ÿæˆæ¨¡å¼", "meta": {"api_key_configured": configured}}), 400

```
----- END FILE: interact/routes/ai.py -----


----- BEGIN FILE: interact/routes/auth.py -----
# Size: 1.3KB | Lines: 47
```python
"""Authentication related routes."""
from __future__ import annotations

from flask import jsonify, request, session

from data.database import create_user, get_user_by_username, hash_password

from . import api_bp


@api_bp.get("/me")
def api_me():
    from flask import g

    user = getattr(g, "user", None)
    if user:
        return jsonify({"user": {"id": user["id"], "username": user["username"]}})
    return jsonify({"user": None})


@api_bp.post("/register")
def api_register():
    data = request.get_json(silent=True) or {}
    username = data.get("username", "").strip()
    password = data.get("password", "").strip()
    ok, err = create_user(username, password)
    return jsonify({"ok": ok, "error": err})


@api_bp.post("/login")
def api_login():
    data = request.get_json(silent=True) or {}
    username = data.get("username", "").strip()
    password = data.get("password", "").strip()
    user = get_user_by_username(username)
    if not user:
        return jsonify({"ok": False, "error": "ç”¨æˆ·ä¸å­˜åœ¨"})
    if user["password_hash"] != hash_password(password):
        return jsonify({"ok": False, "error": "å¯†ç é”™è¯¯"})
    session["user_id"] = user["id"]
    return jsonify({"ok": True})


@api_bp.post("/logout")
def api_logout():
    session.clear()
    return jsonify({"ok": True})

```
----- END FILE: interact/routes/auth.py -----


----- BEGIN FILE: interact/routes/bots.py -----
# Size: 1.5KB | Lines: 60
```python
"""Bot CRUD endpoints."""
from __future__ import annotations

from flask import jsonify, request

from core.runtime import registry
from data import create_bot, delete_bot, get_bot, list_bots
from interact.security import login_required
from interact.socket import push_status_for_user
from interact.utils import mask_token

from . import api_bp


@api_bp.get("/bots")
@login_required
def api_list_bots():
    from flask import g

    bots = list_bots(g.user["id"])
    items = []
    for bot in bots:
        items.append(
            {
                "id": bot["id"],
                "name": bot["name"],
                "token_mask": mask_token(bot.get("token")),
                "created_at": bot["created_at"],
            }
        )
    return jsonify({"items": items})


@api_bp.post("/bots")
@login_required
def api_add_bot():
    from flask import g

    data = request.get_json(silent=True) or {}
    name = data.get("name", "").strip()
    token = data.get("token", "").strip()
    user_id = g.user["id"]
    ok, err = create_bot(user_id, name, token)
    if ok:
        push_status_for_user(user_id)
    return jsonify({"ok": ok, "error": err})


@api_bp.delete("/bots/<int:bot_id>")
@login_required
def api_delete_bot(bot_id: int):
    from flask import g

    registry.stop(bot_id)
    user_id = g.user["id"]
    ok, err = delete_bot(user_id, bot_id)
    if ok:
        push_status_for_user(user_id)
    status = 200 if ok else 404
    return jsonify({"ok": ok, "error": err}), status

```
----- END FILE: interact/routes/bots.py -----


----- BEGIN FILE: interact/routes/commands.py -----
# Size: 2.2KB | Lines: 69
```python
"""Fixed command management endpoints."""
from __future__ import annotations

import json

from flask import jsonify, request

from data.database import delete_command, erase_commands, get_bot, list_commands, upsert_command
from interact.security import login_required

from . import api_bp


@api_bp.get("/bots/<int:bot_id>/commands")
@login_required
def api_list_commands(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"items": []})
    return jsonify({"items": list_commands(bot_id)})


@api_bp.post("/bots/<int:bot_id>/commands")
@login_required
def api_upsert_command(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    data = request.get_json(silent=True) or {}
    command = (data.get("command") or "").strip()
    kind = (data.get("kind") or "text").strip()
    reply = data.get("reply")
    payload_obj = data.get("payload")
    if isinstance(payload_obj, (dict, list)):
        payload = json.dumps(payload_obj, ensure_ascii=False)
    elif isinstance(payload_obj, str):
        payload = payload_obj
    else:
        payload = None
    parse_mode = (data.get("parse_mode") or None)
    disable_preview = 1 if data.get("disable_preview") else 0
    ok, err = upsert_command(bot_id, command, kind, reply, payload, parse_mode, disable_preview)
    status = 200 if ok else 400
    return jsonify({"ok": ok, "error": err}), status


@api_bp.delete("/bots/<int:bot_id>/commands/<command>")
@login_required
def api_delete_command(bot_id: int, command: str):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, err = delete_command(bot_id, "/" + command.lstrip("/"))
    status = 200 if ok else 404
    return jsonify({"ok": ok, "error": err}), status


@api_bp.delete("/bots/<int:bot_id>/commands")
@login_required
def api_erase_commands(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, err = erase_commands(bot_id)
    return jsonify({"ok": ok, "error": err})

```
----- END FILE: interact/routes/commands.py -----


----- BEGIN FILE: interact/routes/flows.py -----
# Size: 2.1KB | Lines: 68
```python
"""Flow management endpoints."""
from __future__ import annotations

import json

from flask import jsonify, request

from data.database import delete_flow, get_bot, list_flows, upsert_flow
from interact.security import login_required
from interact.utils import normalize_flow_blocks

from . import api_bp


@api_bp.get("/bots/<int:bot_id>/flows")
@login_required
def api_list_flows(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"items": []})
    items = list_flows(bot_id)
    for item in items:
        blocks_json = item.get("blocks_json")
        parsed = None
        if isinstance(blocks_json, str) and blocks_json.strip():
            try:
                parsed = json.loads(blocks_json)
                if isinstance(parsed, str):
                    parsed = json.loads(parsed)
            except Exception:
                parsed = None
        item["blocks_compiled"] = parsed
    return jsonify({"items": items})


@api_bp.post("/bots/<int:bot_id>/flows")
@login_required
def api_upsert_flow(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    data = request.get_json(silent=True) or {}
    flow_id = data.get("id")
    name = (data.get("name") or "").strip()
    try:
        normalized = normalize_flow_blocks(data.get("blocks_json"))
    except ValueError as exc:
        return jsonify({"ok": False, "error": str(exc)}), 400
    if not normalized:
        return jsonify({"ok": False, "error": "blocks_json ä¸èƒ½ä¸ºç©º"}), 400
    active = int(bool(data.get("active", 1)))
    ok, err, fid = upsert_flow(bot_id, name, normalized, flow_id, active)
    status = 200 if ok else 400
    return jsonify({"ok": ok, "error": err, "id": fid}), status


@api_bp.delete("/bots/<int:bot_id>/flows/<int:flow_id>")
@login_required
def api_delete_flow(bot_id: int, flow_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, err = delete_flow(bot_id, flow_id)
    status = 200 if ok else 404
    return jsonify({"ok": ok, "error": err}), status

```
----- END FILE: interact/routes/flows.py -----


----- BEGIN FILE: interact/routes/pro_scripts.py -----
# Size: 1.6KB | Lines: 49
```python
"""Pro script management endpoints."""
from __future__ import annotations

from flask import jsonify, request

from data.database import delete_pro_script, get_bot, list_pro_scripts, upsert_pro_script
from interact.security import login_required

from . import api_bp


@api_bp.get("/bots/<int:bot_id>/pro_scripts")
@login_required
def api_list_pro_scripts(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™", "items": []}), 403
    return jsonify({"ok": True, "items": list_pro_scripts(bot_id)})


@api_bp.post("/bots/<int:bot_id>/pro_scripts")
@login_required
def api_upsert_pro_script(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    data = request.get_json(silent=True) or {}
    script_id = data.get("id")
    name = (data.get("name") or "").strip()
    command = (data.get("command") or "").strip()
    code = (data.get("code") or "").strip()
    active = int(bool(data.get("active", True)))
    ok, err, sid = upsert_pro_script(bot_id, name, command, code, script_id, active)
    status = 200 if ok else 400
    return jsonify({"ok": ok, "error": err, "id": sid}), status


@api_bp.delete("/bots/<int:bot_id>/pro_scripts/<int:script_id>")
@login_required
def api_delete_pro_script(bot_id: int, script_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, err = delete_pro_script(bot_id, script_id)
    status = 200 if ok else 404
    return jsonify({"ok": ok, "error": err}), status

```
----- END FILE: interact/routes/pro_scripts.py -----


----- BEGIN FILE: interact/routes/pseudocode.py -----
# Size: 3.4KB | Lines: 108
```python
"""Pseudocode endpoints."""
from __future__ import annotations

import json

from flask import jsonify, request

from core.pseudo import generate_flow_from_pseudocode, simulate_flow
from data.database import (
    get_bot,
    get_pseudocode,
    list_pseudocode,
    upsert_flow,
    upsert_pseudocode,
    delete_pseudocode,
)
from interact.security import login_required

from . import api_bp


@api_bp.get("/bots/<int:bot_id>/pseudocode")
@login_required
def api_list_pseudocode(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"items": []})
    return jsonify({"items": list_pseudocode(bot_id)})


@api_bp.post("/bots/<int:bot_id>/pseudocode")
@login_required
def api_upsert_pseudocode(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    data = request.get_json(silent=True) or {}
    pseudo_id = data.get("id")
    title = data.get("title") or ""
    content = data.get("content") or ""
    ok, err, pid = upsert_pseudocode(bot_id, title, content, pseudo_id)
    status = 200 if ok else 400
    return jsonify({"ok": ok, "error": err, "id": pid}), status


@api_bp.delete("/bots/<int:bot_id>/pseudocode/<int:item_id>")
@login_required
def api_delete_pseudocode(bot_id: int, item_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, err = delete_pseudocode(bot_id, item_id)
    status = 200 if ok else 404
    return jsonify({"ok": ok, "error": err}), status


@api_bp.post("/bots/<int:bot_id>/pseudocode/<int:item_id>/generate_flow")
@login_required
def api_generate_flow_from_pseudo(bot_id: int, item_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    pseudo = get_pseudocode(bot_id, item_id)
    if not pseudo:
        return jsonify({"ok": False, "error": "ä¼ªä»£ç ä¸å­˜åœ¨"}), 404
    result = generate_flow_from_pseudocode(pseudo["title"], pseudo["content"])
    compiled_json = json.dumps(result["compiled"], ensure_ascii=False)
    ok, err, fid = upsert_flow(bot_id, result["name"], compiled_json, None, 1)
    if not ok:
        return jsonify({"ok": False, "error": err or "ä¿å­˜æµç¨‹å¤±è´¥"}), 400
    return jsonify(
        {
            "ok": True,
            "id": fid,
            "flow": result["compiled"],
            "summary": result["summary"],
            "command": result["command"],
            "name": result["name"],
        }
    )


@api_bp.post("/bots/<int:bot_id>/pseudocode/<int:item_id>/sandbox")
@login_required
def api_sandbox_pseudocode(bot_id: int, item_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    pseudo = get_pseudocode(bot_id, item_id)
    if not pseudo:
        return jsonify({"ok": False, "error": "ä¼ªä»£ç ä¸å­˜åœ¨"}), 404
    data = request.get_json(silent=True) or {}
    result = generate_flow_from_pseudocode(pseudo["title"], pseudo["content"])
    sim = simulate_flow(result["compiled"], data.get("input", "/demo"))
    return jsonify(
        {
            "ok": True,
            "actions": sim["actions"],
            "summary": sim["summary"],
            "analysis": result["summary"],
            "command": result["command"],
        }
    )

```
----- END FILE: interact/routes/pseudocode.py -----


----- BEGIN FILE: interact/routes/runtime.py -----
# Size: 3.0KB | Lines: 103
```python
"""Bot runtime orchestration endpoints."""
from __future__ import annotations

from flask import jsonify, request

from core.runtime import registry
from data import get_bot, list_bots, list_commands
from interact.security import login_required
from interact.socket import push_status_for_user
from interact.utils import mask_token

from . import api_bp


@api_bp.post("/bots/<int:bot_id>/start")
@login_required
def api_bot_start(bot_id: int):
    from flask import g

    bot = get_bot(g.user["id"], bot_id)
    if not bot:
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    specs = list_commands(bot_id)
    ok, msg = registry.start(bot_id, bot["token"], specs)
    push_status_for_user(g.user["id"])
    return jsonify({"ok": ok, "msg": msg})


@api_bp.post("/bots/<int:bot_id>/stop")
@login_required
def api_bot_stop(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, msg = registry.stop(bot_id)
    push_status_for_user(g.user["id"])
    return jsonify({"ok": ok, "msg": msg})


@api_bp.post("/bots/<int:bot_id>/sync")
@login_required
def api_bot_sync(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "error": "æ— æƒé™"}), 403
    ok, msg = registry.sync(bot_id)
    push_status_for_user(g.user["id"])
    return jsonify({"ok": ok, "msg": msg})


@api_bp.get("/bots/<int:bot_id>/status")
@login_required
def api_bot_status(bot_id: int):
    from flask import g

    bot = get_bot(g.user["id"], bot_id)
    status = dict(registry.status(bot_id))
    if bot:
        status.setdefault("bot_id", bot["id"])
        status.setdefault("name", bot["name"])
    return jsonify({"status": status})


@api_bp.get("/bots/<int:bot_id>/logs")
@login_required
def api_bot_logs(bot_id: int):
    from flask import g

    if not get_bot(g.user["id"], bot_id):
        return jsonify({"ok": False, "items": [], "error": "æ— æƒé™"}), 403
    try:
        lines = int(request.args.get("lines", 100))
    except (TypeError, ValueError):
        lines = 100
    lines = max(10, min(lines, 500))
    items = [dict(evt) for evt in registry.logs(bot_id, lines) or []]
    return jsonify({"ok": True, "items": items})


@api_bp.get("/bots/status_all")
@login_required
def api_bot_status_all():
    from flask import g

    bots = list_bots(g.user["id"])
    running = registry.status_all()
    items = []
    for bot in bots:
        bot_id = bot["id"]
        snapshot = running.get(bot_id)
        if snapshot is None:
            snapshot = registry.status(bot_id)
        snapshot = dict(snapshot)
        snapshot.setdefault("bot_id", bot_id)
        snapshot.setdefault("state", "stopped")
        snapshot.setdefault("uptime", 0)
        snapshot.setdefault("stats", {"messages": 0, "errors": 0})
        snapshot["name"] = bot["name"]
        snapshot["token_mask"] = mask_token(bot.get("token")) if bot.get("token") else ""
        items.append(snapshot)
    return jsonify({"items": items})

```
----- END FILE: interact/routes/runtime.py -----


----- BEGIN FILE: interact/security.py -----
# Size: 569B | Lines: 22
```python
"""Authentication helpers for the Flask interface."""
from __future__ import annotations

from functools import wraps
from typing import Callable, TypeVar

from flask import g, jsonify

F = TypeVar("F", bound=Callable[..., object])


def login_required(func: F) -> F:
    @wraps(func)
    def wrapper(*args, **kwargs):  # type: ignore[misc]
        if not getattr(g, "user", None):
            return jsonify({"ok": False, "error": "æœªç™»å½•"}), 401
        return func(*args, **kwargs)

    return wrapper  # type: ignore[return-value]


__all__ = ["login_required"]

```
----- END FILE: interact/security.py -----


----- BEGIN FILE: interact/socket.py -----
# Size: 3.3KB | Lines: 111
```python
"""WebSocket (Socket.IO) helpers for real-time bot state updates."""
from __future__ import annotations

import time
from collections import defaultdict
from threading import Lock
from typing import Dict, Iterable, Optional

from flask import request, session
from flask_socketio import SocketIO, emit

from core.runtime import registry
from data import list_bots
from interact.utils import mask_token

socketio = SocketIO(async_mode="threading", cors_allowed_origins="*")

_subscriptions: Dict[int, set[str]] = defaultdict(set)
_lock = Lock()
_background_started = False


def init_socketio(app) -> None:
    """Attach Socket.IO to the Flask app and spawn the status updater."""
    global _background_started
    socketio.init_app(app)
    if not _background_started:
        socketio.start_background_task(_status_loop)
        _background_started = True


def _status_loop():  # pragma: no cover - background thread
    while True:
        socketio.sleep(4)
        with _lock:
            user_ids = list(_subscriptions.keys())
        for user_id in user_ids:
            push_status_for_user(user_id)


def _build_payload(user_id: int) -> Dict[str, object]:
    bots = list_bots(user_id)
    global_status = registry.status_all()
    items = []
    for bot in bots:
        bot_id = bot["id"]
        snapshot = dict(global_status.get(bot_id) or registry.status(bot_id))
        snapshot["bot_id"] = bot_id
        snapshot["name"] = bot["name"]
        snapshot["token_mask"] = mask_token(bot.get("token")) if bot.get("token") else ""
        snapshot["created_at"] = bot.get("created_at")
        snapshot.setdefault("stats", {"messages": 0, "errors": 0})
        snapshot.setdefault("state", "stopped")
        snapshot.setdefault("uptime", 0)
        items.append(snapshot)
    return {"items": items, "ts": time.time()}


def push_status_for_user(user_id: int, *, room: Optional[str] = None) -> None:
    payload = _build_payload(user_id)
    targets: Iterable[str]
    if room:
        targets = [room]
    else:
        with _lock:
            targets = list(_subscriptions.get(user_id, set()))
    for sid in targets:
        socketio.emit("bot_status", payload, room=sid)


@socketio.on("connect")
def handle_connect():
    user_id = session.get("user_id")
    if not user_id:
        emit("auth_error", {"error": "æœªç™»å½•ï¼Œæ— æ³•è®¢é˜…å®žæ—¶çŠ¶æ€"})
        return
    emit("connected", {"ok": True})


@socketio.on("subscribe_status")
def handle_subscribe(data):  # noqa: D401 - event handler
    user_id = session.get("user_id")
    if not user_id:
        emit("auth_error", {"error": "æœªç™»å½•ï¼Œæ— æ³•è®¢é˜…å®žæ—¶çŠ¶æ€"})
        return
    sid = request.sid
    with _lock:
        _subscriptions[user_id].add(sid)
    emit("subscribed", {"ok": True})
    push_status_for_user(user_id, room=sid)


@socketio.on("unsubscribe_status")
def handle_unsubscribe():
    sid = request.sid
    with _lock:
        for user_id, sids in list(_subscriptions.items()):
            if sid in sids:
                sids.remove(sid)
                if not sids:
                    _subscriptions.pop(user_id, None)
                break
    emit("unsubscribed", {"ok": True})


@socketio.on("disconnect")
def handle_disconnect():
    handle_unsubscribe()


__all__ = ["socketio", "init_socketio", "push_status_for_user"]

```
----- END FILE: interact/socket.py -----


----- BEGIN FILE: interact/utils.py -----
# Size: 1.1KB | Lines: 39
```python
"""Shared utility helpers for Flask routes."""
from __future__ import annotations

import json
from typing import Any, Dict


def mask_token(token: str) -> str:
    if not token:
        return ""
    value = token.strip()
    if len(value) <= 12:
        return value[:2] + "****" + value[-2:]
    return value[:8] + "****" + value[-4:]


def normalize_flow_blocks(raw: Any) -> str | None:
    if raw is None:
        return None
    obj = raw
    if isinstance(raw, str):
        text = raw.strip()
        if not text:
            return None
        try:
            obj = json.loads(text)
        except json.JSONDecodeError as exc:
            raise ValueError(f"invalid blocks_json: {exc}") from exc
    if isinstance(obj, str):
        try:
            obj = json.loads(obj)
        except json.JSONDecodeError as exc:
            raise ValueError(f"invalid blocks_json inner string: {exc}") from exc
    if not isinstance(obj, Dict):
        raise ValueError("blocks_json must be a JSON object")
    return json.dumps(obj, ensure_ascii=False)


__all__ = ["mask_token", "normalize_flow_blocks"]

```
----- END FILE: interact/utils.py -----


----- BEGIN FILE: main.py -----
# Size: 203B | Lines: 8
```python
"""WSGI entrypoint."""
from interact import create_app, socketio

app = create_app()


if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=8000, debug=True, allow_unsafe_werkzeug=True)

```
----- END FILE: main.py -----


----- BEGIN FILE: pseudo_convert.py -----
# Size: 150B | Lines: 5
```python
"""Legacy shim for pseudocode helpers."""
from core.pseudo import *  # noqa: F401,F403
import core.pseudo as _pseudo

__all__ = list(_pseudo.__all__)

```
----- END FILE: pseudo_convert.py -----


----- BEGIN FILE: rewrite.py -----
# Size: 6.2KB | Lines: 180
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Restore project files from a TXT prompt generated by pack_project_prompt.py.
- Parses the tree of "----- BEGIN/END FILE: <relpath> -----"
- Extracts content (prefers fenced block, falls back to all lines between markers)
- Recreates directories and writes .py/.html files under a chosen output root
- Uses input() for a dead-simple UX
"""

from __future__ import annotations
import os
import sys
from typing import List, Tuple

BEGIN_TAG = "----- BEGIN FILE:"
END_TAG   = "----- END FILE:"

def ask(prompt: str, default: str | None = None) -> str:
    if default is None:
        return input(prompt + " ").strip()
    val = input(f"{prompt} [é»˜è®¤: {default}] ").strip()
    return val or default

def confirm(prompt: str, default: bool = False) -> bool:
    d = "Y/n" if default else "y/N"
    val = input(f"{prompt} [{d}] ").strip().lower()
    if not val:
        return default
    return val in ("y", "yes", "1", "true", "t")

def read_text(path: str) -> str:
    with open(path, "r", encoding="utf-8", errors="replace") as f:
        return f.read()

def parse_blocks(text: str) -> List[Tuple[str, str]]:
    """
    Parse the packed TXT into (relpath, content) tuples.
    Prefers fenced code blocks if present; otherwise uses raw lines between markers.
    """
    lines = text.splitlines()
    n = len(lines)
    i = 0
    results: List[Tuple[str, str]] = []

    while i < n:
        line = lines[i]
        if line.startswith(BEGIN_TAG):
            # Extract relpath between BEGIN and trailing dashes
            rel = line[len(BEGIN_TAG):].strip()
            if rel.endswith("-----"):
                rel = rel[:-5].rstrip()
            # Gather lines until END_TAG
            i += 1
            start_i = i
            while i < n and not lines[i].startswith(END_TAG):
                i += 1
            if i >= n:
                raise ValueError(f"æœªæ‰¾åˆ°åŒ¹é…çš„ END æ ‡è®°ï¼ˆèµ·å§‹äºŽç¬¬ {start_i+1} è¡Œï¼Œæ–‡ä»¶ {rel}ï¼‰ã€‚")
            end_i = i  # line with END_TAG is at i
            block = lines[start_i:end_i]

            # Strip optional "# Size: ..." metadata line at top
            k = 0
            if k < len(block) and block[k].lstrip().startswith("# Size:"):
                k += 1

            content_lines: List[str] | None = None

            # Prefer fenced content if present
            if k < len(block) and block[k].strip().startswith("```"):
                # find closing fence line "```"
                k += 1
                j = k
                while j < len(block) and block[j].strip() != "```":
                    j += 1
                if j < len(block) and block[j].strip() == "```":
                    content_lines = block[k:j]
                else:
                    # fence not closed properly; fall back to all lines after possible header
                    content_lines = block[k:]
            else:
                # No fence; treat everything after header as content
                content_lines = block[k:]

            content = "\n".join(content_lines)
            results.append((rel, content))

            # Move past END line
            i += 1
        else:
            i += 1

    return results

def is_safe_relative_path(rel: str) -> bool:
    # Disallow absolute paths and drive letters
    if os.path.isabs(rel):
        return False
    # Normalize and ensure it doesn't escape via ..
    norm = os.path.normpath(rel)
    parts = norm.split(os.sep)
    return not any(p in ("..", "") for p in parts if p != ".")

def ensure_within_root(root: str, rel: str) -> str:
    # Join and ensure path stays within root
    target = os.path.normpath(os.path.join(root, rel))
    root_norm = os.path.normpath(os.path.abspath(root))
    target_abs = os.path.normpath(os.path.abspath(target))
    if not target_abs.startswith(root_norm + os.sep) and target_abs != root_norm:
        raise ValueError(f"è·¯å¾„é€ƒé€¸è¢«é˜»æ­¢: {rel}")
    return target_abs

def write_files(blocks: List[Tuple[str, str]], out_root: str, overwrite: bool) -> Tuple[int, int]:
    written = 0
    skipped = 0
    for rel, content in blocks:
        # only restore .py/.html
        low = rel.lower()
        if not (low.endswith(".py") or low.endswith(".html")):
            skipped += 1
            continue
        if not is_safe_relative_path(rel):
            print(f"âš ï¸ è·³è¿‡ä¸å®‰å…¨è·¯å¾„: {rel}")
            skipped += 1
            continue
        target = ensure_within_root(out_root, rel)
        os.makedirs(os.path.dirname(target), exist_ok=True)
        if os.path.exists(target) and not overwrite:
            print(f"â­ï¸ å·²å­˜åœ¨ï¼Œæœªè¦†ç›–: {rel}")
            skipped += 1
            continue
        with open(target, "w", encoding="utf-8", errors="replace", newline="") as f:
            f.write(content)
        print(f"âœ… å†™å…¥: {rel}  ({len(content.splitlines())} è¡Œ)")
        written += 1
    return written, skipped

def main():
    print("ðŸ§¯ å›žå¡«é¡¹ç›®æ–‡ä»¶ï¼ˆä»Ž TXT Prompt è¿˜åŽŸ .py / .htmlï¼‰")
    src_txt = ask("è¯·è¾“å…¥æ‰“åŒ…ç”Ÿæˆçš„ TXT æ–‡ä»¶è·¯å¾„")
    if not os.path.isfile(src_txt):
        print("âŒ æ‰¾ä¸åˆ°è¯¥ TXT æ–‡ä»¶ã€‚")
        sys.exit(1)

    out_root = ask("è¯·é€‰æ‹©å›žå¡«è¾“å‡ºæ ¹ç›®å½•", os.path.join(os.getcwd(), "restored_project"))
    os.makedirs(out_root, exist_ok=True)

    overwrite = confirm("è‹¥æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ", default=False)

    # Load and parse
    print("ðŸ“– è¯»å–å¹¶è§£æž TXT...")
    text = read_text(src_txt)
    blocks = parse_blocks(text)
    if not blocks:
        print("ðŸ˜¶ æ²¡è§£æžåˆ°ä»»ä½•æ–‡ä»¶å—ã€‚ç¡®è®¤æ˜¯å¦ç”±é…å¥—æ‰“åŒ…è„šæœ¬ç”Ÿæˆã€‚")
        sys.exit(2)

    # Summary preview
    print(f"ðŸ” è§£æžç»“æžœï¼š{len(blocks)} ä¸ªæ–‡ä»¶å—ã€‚ç¤ºä¾‹ï¼š")
    for i, (rel, _) in enumerate(blocks[:5], 1):
        print(f"  {i:>2}. {rel}")
    if len(blocks) > 5:
        print(f"  ... ä»¥åŠå…¶ä»– {len(blocks)-5} ä¸ªã€‚")

    # Write
    print("ðŸ› ï¸ æ­£åœ¨å›žå¡«...")
    written, skipped = write_files(blocks, out_root, overwrite)

    print("\nðŸ“¦ å®Œæˆ")
    print(f"  âœ”ï¸ å†™å…¥: {written} æ–‡ä»¶")
    print(f"  â†ªï¸ è·³è¿‡: {skipped} æ–‡ä»¶")
    print(f"  ðŸ“ è¾“å‡ºç›®å½•: {os.path.abspath(out_root)}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"âŒ å¼‚å¸¸: {e}")
        sys.exit(3)

```
----- END FILE: rewrite.py -----


----- BEGIN FILE: static/blocks.html -----
# Size: 25.7KB | Lines: 551
```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ç§¯æœ¨ç¼–æŽ’</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body class="bg-gray-50">
  <div class="max-w-6xl mx-auto p-4 space-y-3">
    <div class="flex items-center justify-between">
      <h1 class="text-xl font-semibold">ðŸ§± ç§¯æœ¨ç¼–æŽ’</h1>
      <div class="space-x-2">
        <button id="saveBtn" class="px-3 py-1.5 rounded-md bg-amber-500 text-white">ä¿å­˜å¹¶å‘å¸ƒ</button>
        <button onclick="window.close()" class="px-3 py-1.5 rounded-md bg-gray-200">å…³é—­</button>
      </div>
    </div>
    <div id="hint" class="text-sm text-gray-500"></div>
    <div id="blocklyArea" class="h-[72vh] bg-white rounded-xl shadow"></div>
  </div>

<script>
// ---------------- URL å‚æ•° ----------------
const params = new URLSearchParams(location.search);
const botId = params.get('bot_id');
const flowId = params.get('flow_id');
document.getElementById('hint').innerText = botId ? `ç›®æ ‡ Bot: #${botId}${flowId? 'ï¼Œç¼–è¾‘ Flow #'+flowId : 'ï¼Œæ–°å»º Flow'}` : 'ç¼ºå°‘ bot_id å‚æ•°';

// ---------------- è‡ªå®šä¹‰å—ï¼ˆå…ˆå®šä¹‰ï¼Œå†æ³¨å…¥ï¼‰ ----------------
Blockly.defineBlocksWithJsonArray([
  // å…¥å£
  {"type":"on_command","message0":"å½“æ”¶åˆ°å‘½ä»¤ /%1","args0":[{"type":"field_input","name":"CMD","text":"guess"}],
   "nextStatement":null, "colour":210, "tooltip":"å…¥å£å—ï¼ˆä¸€ä¸ªå‘½ä»¤ä¸€ä¸ªå…¥å£ï¼‰"},

  // å‘é€æ–‡æœ¬ï¼ˆå¸¦ ParseMode & é¢„è§ˆï¼‰
  {"type":"send_text","message0":"å‘é€æ–‡æœ¬ %1","args0":[{"type":"field_input","name":"TEXT","text":"ä½ å¥½ï¼Œ{{user.first_name}}"}],
   "message1":"ParseMode %1  ç¦ç”¨é“¾æŽ¥é¢„è§ˆ %2",
   "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},
            {"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
   "previousStatement":null, "nextStatement":null, "colour":160},

  // åª’ä½“
  {"type":"send_photo","message0":"å‘é€å›¾ç‰‡ URL %1 è¯´æ˜Ž %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_document","message0":"å‘é€æ–‡æ¡£ URL %1 è¯´æ˜Ž %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_animation","message0":"å‘é€åŠ¨ç”»/GIF URL %1 è¯´æ˜Ž %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_voice","message0":"å‘é€è¯­éŸ³ URL %1 è¯´æ˜Ž %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "message1":"ParseMode %1",
   "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_sticker","message0":"å‘é€è´´çº¸ file_id %1",
   "args0":[{"type":"field_input","name":"FILE","text":"CAACAgUAAxkBAAIDlmT63..."}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_text_keyboard","message0":"å‘é€æ–‡æœ¬+æŒ‰é’® %1",
   "args0":[{"type":"field_input","name":"TEXT","text":"è¯·é€‰æ‹©æ“ä½œ"}],
   "message1":"æŒ‰é’® JSON %1",
   "args1":[{"type":"field_input","name":"KB","text":"[[{\"text\":\"æŒ‰é’®\",\"callback_data\":\"ping\"}]]"}],
   "message2":"ParseMode %1  ç¦ç”¨é¢„è§ˆ %2",
   "args2":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},
            {"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
   "previousStatement":null, "nextStatement":null, "colour":160},

  // å˜é‡ï¼šå†™å…¥ï¼ˆéšæœº/æ–‡æœ¬ï¼‰ã€è¯»å–åˆ°ä¸´æ—¶å˜é‡ã€è‡ªå¢ž
  {"type":"set_var_rand","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = éšæœº %3 åˆ° %4",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"secret"},
            {"type":"field_number","name":"MIN","value":1},
            {"type":"field_number","name":"MAX","value":100}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"set_var_val","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = æ–‡æœ¬ %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"name"},
            {"type":"field_input","name":"VAL","text":"{{user.username}}"}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"inc_var","message0":"è‡ªå¢ž ä½œç”¨åŸŸ %1 å˜é‡ %2 æ­¥é•¿ %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"count"},
            {"type":"field_number","name":"STEP","value":1}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"get_var","message0":"è¯»å– ä½œç”¨åŸŸ %1 å˜é‡ %2 â†’ ä¸´æ—¶å %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"secret"},
            {"type":"field_input","name":"ALIAS","text":"x"}],
   "previousStatement":null, "nextStatement":null, "colour":200},
  {"type":"set_local_from_input","message0":"ä»¤ ä¸´æ—¶å˜é‡ %1 = å½“å‰æ¶ˆæ¯æ–‡æœ¬",
   "args0":[{"type":"field_input","name":"ALIAS","text":"guess"}],
   "previousStatement":null, "nextStatement":null, "colour":200},

  // æ¡ä»¶ï¼ˆç”¨ä¸´æ—¶å˜é‡ï¼‰
  {"type":"if_var","message0":"å¦‚æžœ ä¸´æ—¶å˜é‡ %1 %2 %3",
   "args0":[{"type":"field_input","name":"LHS","text":"x"},
            {"type":"field_dropdown","name":"OP","options":[["=","eq"],["â‰ ","ne"],["åŒ…å«","contains"],[">","gt"],["<","lt"]]},
            {"type":"field_input","name":"RHS","text":"42"}],
   "message1":"é‚£ä¹ˆ %1","args1":[{"type":"input_statement","name":"THEN"}],
   "message2":"å¦åˆ™ %1","args2":[{"type":"input_statement","name":"ELSE"}],
   "previousStatement":null, "nextStatement":null, "colour":20},

  // ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯
  {"type":"wait_next","message0":"ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆ%1ï¼‰ å¹¶æç¤º %2",
   "args0":[{"type":"field_dropdown","name":"EXPECT","options":[["ä»»æ„","any"],["æ•°å­—","number"]]},
            {"type":"field_input","name":"PROMPT","text":"è¯·è¾“å…¥â€¦"}],
   "previousStatement":null, "nextStatement":null, "colour":290},

  // å»¶è¿Ÿæ‰§è¡Œ
  {"type":"delay_seconds","message0":"ç­‰å¾… %1 ç§’",
   "args0":[{"type":"field_number","name":"SEC","value":3,"min":0,"max":300,"precision":0.5}],
   "previousStatement":null, "nextStatement":null, "colour":290},

  // HTTPï¼ˆheaders/body + ä¿å­˜ JSON è·¯å¾„ï¼‰
  {"type":"http_block","message0":"HTTP %1 %2",
   "args0":[{"type":"field_dropdown","name":"METHOD","options":[["GET","GET"],["POST","POST"]]},
            {"type":"field_input","name":"URL","text":"https://api.github.com/zen"}],
   "message1":"Headers(JSON) %1","args1":[{"type":"field_input","name":"HEAD","text":"{}"}],
   "message2":"Body(JSON) %1","args2":[{"type":"field_input","name":"BODY","text":""}],
   "message3":"ä¿å­˜åˆ° %1.%2ï¼ˆJSONè·¯å¾„å¯é€‰ %3 ï¼‰",
   "args3":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"resp"},
            {"type":"field_input","name":"JPATH","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":300}
]);

// ---------------- æ³¨å…¥ ----------------
const workspace = Blockly.inject('blocklyArea', {
  toolbox: {
    "kind": "flyoutToolbox",
    "contents": [
      { "kind":"label","text":"è§¦å‘" },
      { "kind":"block","type":"on_command" },

      { "kind":"label","text":"åŠ¨ä½œ" },
      { "kind":"block","type":"send_text" },
      { "kind":"block","type":"send_photo" },
      { "kind":"block","type":"send_document" },
      { "kind":"block","type":"send_animation" },
      { "kind":"block","type":"send_voice" },
      { "kind":"block","type":"send_sticker" },
      { "kind":"block","type":"send_text_keyboard" },

      { "kind":"label","text":"å˜é‡" },
      { "kind":"block","type":"set_var_val" },
      { "kind":"block","type":"set_var_rand" },
      { "kind":"block","type":"inc_var" },
      { "kind":"block","type":"get_var" },
      { "kind":"block","type":"set_local_from_input" },

      { "kind":"label","text":"é€»è¾‘" },
      { "kind":"block","type":"if_var" },
      { "kind":"block","type":"wait_next" },
      { "kind":"block","type":"delay_seconds" },

      { "kind":"label","text":"ç½‘ç»œ" },
      { "kind":"block","type":"http_block" }
    ]
  },
  scrollbars: true,
  trashcan: true,
});

// ---------------- å·¥å…·ï¼šç¨³å¥è§£æž & æ—§æ•°æ®é‡å»º ----------------
function safeParseBlocksJson(raw) {
  try {
    let x = raw;
    if (typeof x === 'string') {
      x = JSON.parse(x);
      if (typeof x === 'string') x = JSON.parse(x);
    }
    return (x && typeof x === 'object') ? x : null;
  } catch(e) {
    console.warn('safeParseBlocksJson failed:', e);
    return null;
  }
}

function rebuildFromCompiled(compiled){
  if(!compiled || !Array.isArray(compiled.entries)) return;
  workspace.clear();

  let offsetX = 20;
  const chainTo = (prev, block) => {
    block.initSvg(); block.render();
    if(prev && prev.nextConnection && block.previousConnection){
      prev.nextConnection.connect(block.previousConnection);
    }
    return block;
  };

  compiled.entries.forEach((entry)=>{
    // å…¥å£
    const on = workspace.newBlock('on_command');
    on.setFieldValue((entry.command||'/cmd').replace(/^\//,''), 'CMD');
    on.initSvg(); on.render(); on.moveBy(offsetX, 20);

    let prev = on;

    const applyBasicSend = (node) => {
      let b = null;
      if(node.type==='send_text'){
        b = workspace.newBlock('send_text');
        b.setFieldValue(node.text || '', 'TEXT');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
        b.setFieldValue(node.disable_preview ? 'TRUE' : 'FALSE', 'NOPREVIEW');
      } else if(node.type==='send_photo'){
        b = workspace.newBlock('send_photo');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_document'){
        b = workspace.newBlock('send_document');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_animation'){
        b = workspace.newBlock('send_animation');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_voice'){
        b = workspace.newBlock('send_voice');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
      } else if(node.type==='send_sticker'){
        b = workspace.newBlock('send_sticker');
        b.setFieldValue(node.file_id || node.sticker || '', 'FILE');
      } else if(node.type==='send_text_keyboard'){
        b = workspace.newBlock('send_text_keyboard');
        b.setFieldValue(node.text || '', 'TEXT');
        const kbRaw = node.keyboard || node.keyboard_json || node.buttons;
        b.setFieldValue(typeof kbRaw === 'string' ? kbRaw : (kbRaw ? JSON.stringify(kbRaw) : ''), 'KB');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
        b.setFieldValue(node.disable_preview ? 'TRUE' : 'FALSE', 'NOPREVIEW');
      } else if(node.type==='delay'){
        b = workspace.newBlock('delay_seconds');
        b.setFieldValue(String(node.seconds || 0), 'SEC');
      }
      if (b) {
        prev = chainTo(prev, b);
      }
    };

    const nodes = entry.nodes || [];
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      switch(n.type){
        case 'send_text':
        case 'send_photo':
        case 'send_document':
        case 'send_animation':
        case 'send_voice':
        case 'send_sticker':
        case 'send_text_keyboard':
        case 'delay':
          applyBasicSend(n);
          break;

        case 'set_var': {
          const mode = n.mode || (n.random ? 'random' : 'text');
          if(mode==='random'){
            const b = workspace.newBlock('set_var_rand');
            b.setFieldValue(n.scope || 'chat', 'SCOPE');
            b.setFieldValue(n.key || 'k', 'KEY');
            const rr = n.random || {};
            b.setFieldValue(String(rr.min ?? 1), 'MIN');
            b.setFieldValue(String(rr.max ?? 100), 'MAX');
            prev = chainTo(prev, b);
          }else{
            const b = workspace.newBlock('set_var_val');
            b.setFieldValue(n.scope || 'chat', 'SCOPE');
            b.setFieldValue(n.key || 'k', 'KEY');
            b.setFieldValue(n.value || '', 'VAL');
            prev = chainTo(prev, b);
          }
          break;
        }

        case 'inc_var': {
          const b = workspace.newBlock('inc_var');
          b.setFieldValue(n.scope || 'chat', 'SCOPE');
          b.setFieldValue(n.key || 'count', 'KEY');
          b.setFieldValue(String(n.step ?? 1), 'STEP');
          prev = chainTo(prev, b);
          break;
        }

        case 'get_var': {
          const b = workspace.newBlock('get_var');
          b.setFieldValue(n.scope || 'chat', 'SCOPE');
          b.setFieldValue(n.key || 'k', 'KEY');
          b.setFieldValue(n.alias || 'x', 'ALIAS');
          prev = chainTo(prev, b);
          break;
        }

        case 'set_local_from_input': {
          const b = workspace.newBlock('set_local_from_input');
          b.setFieldValue(n.alias || 'x', 'ALIAS');
          prev = chainTo(prev, b);
          break;
        }

        // æ—§ç‰ˆ ifï¼ˆæ— å˜é‡ï¼‰ï¼Œå°½åŠ›æ˜ å°„æˆ if_varï¼ˆç”¨ä¸´æ—¶å˜é‡ xï¼‰
        case 'if':
        case 'if_var': {
          const b = workspace.newBlock('if_var');
          if (n.type === 'if_var') {
             b.setFieldValue((n.left && n.left.var) || 'x', 'LHS');
             b.setFieldValue(n.op || 'eq', 'OP');
             b.setFieldValue((n.right && n.right.text) || '', 'RHS');
          } else { // 'if'
            b.setFieldValue('x', 'LHS');
            b.setFieldValue(n.op || 'eq', 'OP');
            b.setFieldValue((n.right && (n.right.text||'')) || '', 'RHS');
          }

          const buildBranch = (branchNodes, inputName) => {
              let branchPrev = null;
              (branchNodes||[]).forEach(nn=>{
                let nb=null;
                if(nn.type==='send_text'){ nb=workspace.newBlock('send_text'); nb.setFieldValue(nn.text||'','TEXT'); }
                else if(nn.type==='send_photo'){ nb=workspace.newBlock('send_photo'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_document'){ nb=workspace.newBlock('send_document'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_animation'){ nb=workspace.newBlock('send_animation'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_voice'){ nb=workspace.newBlock('send_voice'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); nb.setFieldValue(nn.parse_mode||'','PARSE'); }
                else if(nn.type==='send_sticker'){ nb=workspace.newBlock('send_sticker'); nb.setFieldValue(nn.file_id||nn.sticker||'','FILE'); }
                else if(nn.type==='send_text_keyboard'){ nb=workspace.newBlock('send_text_keyboard'); nb.setFieldValue(nn.text||'','TEXT'); nb.setFieldValue(typeof nn.keyboard==='string'?nn.keyboard:(nn.keyboard?JSON.stringify(nn.keyboard): (nn.keyboard_json||'')),'KB'); nb.setFieldValue(nn.parse_mode||'','PARSE'); nb.setFieldValue(nn.disable_preview?'TRUE':'FALSE','NOPREVIEW'); }
                else if(nn.type==='delay'){ nb=workspace.newBlock('delay_seconds'); nb.setFieldValue(String(nn.seconds||0),'SEC'); }
                if(nb){
                  nb.initSvg(); nb.render();
                  if(!branchPrev){ b.getInput(inputName).connection.connect(nb.previousConnection); }
                  else{ branchPrev.nextConnection.connect(nb.previousConnection); }
                  branchPrev = nb;
                }
              });
          };

          buildBranch(n.then, 'THEN');
          buildBranch(n.else, 'ELSE');

          prev = chainTo(prev, b);
          break;
        }

        case 'http': {
          const b = workspace.newBlock('http_block');
          b.setFieldValue(n.method || 'GET', 'METHOD');
          b.setFieldValue(n.url || '', 'URL');
          b.setFieldValue(
            (typeof n.headers==='string') ? n.headers : (n.headers? JSON.stringify(n.headers):''),
            'HEAD'
          );
          b.setFieldValue(
            (typeof n.body==='string') ? n.body : (n.body? JSON.stringify(n.body):''),
            'BODY'
          );
          b.setFieldValue((n.save_to && n.save_to.scope) || 'chat', 'SCOPE');
          b.setFieldValue((n.save_to && n.save_to.key) || 'resp', 'KEY');
          b.setFieldValue(n.json_path || '', 'JPATH');
          prev = chainTo(prev, b);
          break;
        }

        case 'wait_next': {
          const b = workspace.newBlock('wait_next');
          // ä¿®å¤ï¼šä¸‹æ‹‰èœå•çš„å€¼æ˜¯ 'any' æˆ– 'number'ï¼Œè€Œä¸æ˜¯ä¸­æ–‡
          b.setFieldValue(n.expect === 'number' ? 'number' : 'any', 'EXPECT');
          b.setFieldValue(n.prompt || '', 'PROMPT');
          prev = chainTo(prev, b);

          // ç­‰å¾…åŽçš„ next é¡ºç€ä¸»é“¾æ‹¼ä¸Šï¼ˆç¼–è¾‘æ€å¯è§æ€§æ›´å¥½ï¼‰
          (n.next||[]).forEach(nn => applyBasicSend(nn));

          // å…³é”®ä¿®å¤ï¼šåœ¨è¿™é‡Œè·³å‡ºä¸»å¾ªçŽ¯ï¼Œå› ä¸ºåŽç»­èŠ‚ç‚¹éƒ½å±žäºŽ next çš„èŒƒç•´
          i = nodes.length; // è®¾ç½® i åˆ°æœ«å°¾æ¥ç»ˆæ­¢å¾ªçŽ¯
          break;
        }

        default:
          console.warn('Unknown node type in rebuild:', n.type, n);
      }
    }

    offsetX += 340;
  });

  try{
    const hint = document.getElementById('hint');
    if(hint && !hint.innerText.includes('è¿‘ä¼¼è¿˜åŽŸ')) {
        hint.innerHTML += ' ï½œ æœ¬æ¬¡ä»Ž <code>entries</code> è¿‘ä¼¼è¿˜åŽŸï¼Œä¿å­˜ä¸€æ¬¡åŽå°†ç²¾ç¡®è¿˜åŽŸã€‚';
    }
  }catch(e){}
}

// ---------------- ç¼–è¯‘ JSON ----------------
function toFlowJSON() {
  const blocks = workspace.getTopBlocks(true);
  const entries = [];
  blocks.forEach((b, bi)=>{
    if(b.type!=='on_command') return;
    const cmd = b.getFieldValue('CMD') || ('cmd'+(bi+1));
    const nodes = [];
    let cur = b; // ä»Žå…¥å£å—å¼€å§‹

    // Helper to process a chain of blocks
    const processChain = (startBlock) => {
        let chainNodes = [];
        let current = startBlock;
        while(current){
            switch(current.type){
                case 'send_text':
                  chainNodes.push({type:'send_text', text: current.getFieldValue('TEXT'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'send_photo':
                  chainNodes.push({type:'send_photo', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_document':
                  chainNodes.push({type:'send_document', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_animation':
                  chainNodes.push({type:'send_animation', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_voice':
                  chainNodes.push({type:'send_voice', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP'), parse_mode: current.getFieldValue('PARSE') || ''});
                  break;
                case 'send_sticker':
                  chainNodes.push({type:'send_sticker', file_id: current.getFieldValue('FILE')});
                  break;
                case 'send_text_keyboard':
                  chainNodes.push({type:'send_text_keyboard', text: current.getFieldValue('TEXT'), keyboard: current.getFieldValue('KB'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'set_var_rand':
                  chainNodes.push({type:'set_var', mode:'random', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), random:{min:Number(current.getFieldValue('MIN')), max:Number(current.getFieldValue('MAX'))}});
                  break;
                case 'set_var_val':
                  chainNodes.push({type:'set_var', mode:'text', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), value: current.getFieldValue('VAL')});
                  break;
                case 'inc_var':
                  chainNodes.push({type:'inc_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), step: Number(current.getFieldValue('STEP')||1)});
                  break;
                case 'get_var':
                  chainNodes.push({type:'get_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), alias: current.getFieldValue('ALIAS')});
                  break;
                case 'set_local_from_input':
                  chainNodes.push({type:'set_local_from_input', alias: current.getFieldValue('ALIAS')});
                  break;
                case 'if_var':
                  const thenBranch = processChain(current.getInputTargetBlock('THEN'));
                  const elseBranch = processChain(current.getInputTargetBlock('ELSE'));
                  chainNodes.push({type:'if_var', op: current.getFieldValue('OP'), left:{var:current.getFieldValue('LHS')}, right:{text:current.getFieldValue('RHS')}, then: thenBranch, else: elseBranch});
                  break;
                case 'wait_next':
                  // This is a terminal block for this chain
                  const nextBranch = processChain(current.getNextBlock());
                  chainNodes.push({type:'wait_next', expect: (current.getFieldValue('EXPECT')==='number'?'number':'any'), prompt: current.getFieldValue('PROMPT'), next: nextBranch});
                  return chainNodes; // End the chain here
                case 'http_block':
                  chainNodes.push({type:'http', method:current.getFieldValue('METHOD'), url:current.getFieldValue('URL'), headers:current.getFieldValue('HEAD'), body:current.getFieldValue('BODY'), save_to:{scope:current.getFieldValue('SCOPE'), key:current.getFieldValue('KEY')}, json_path:current.getFieldValue('JPATH')});
                  break;
                case 'delay_seconds':
                  chainNodes.push({type:'delay', seconds: Number(current.getFieldValue('SEC')||0)});
                  break;
            }
            current = current.getNextBlock();
        }
        return chainNodes;
    };

    const nodes_list = processChain(b.getNextBlock());

    entries.push({id:`e${entries.length+1}`, type:'on_command', command:`/${cmd}`, nodes: nodes_list});
  });

  // å…³é”®ä¿®å¤ï¼šä½¿ç”¨æ–°çš„JSONåºåˆ—åŒ–APIæ¥ä¿å­˜å·¥ä½œåŒºçŠ¶æ€
  const workspaceState = Blockly.serialization.workspaces.save(workspace);
  return {version:1, entries, __workspaceState: workspaceState};
}


// ---------------- ä¿å­˜ & å‘å¸ƒ ----------------
async function saveFlow(){
  if(!botId){ alert('ç¼ºå°‘ bot_id'); return; }
  const name = prompt('æµç¨‹åç§°ï¼š', 'è‡ªå®šä¹‰æµç¨‹');
  if(!name) return;

  const compiled = toFlowJSON();
  const r = await fetch(`/api/bots/${botId}/flows`,{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    credentials:'same-origin',
    body: JSON.stringify({ id: flowId ? Number(flowId) : undefined, name, blocks_json: JSON.stringify(compiled) })
  });
  const j = await r.json();
  if(!j.ok){ alert('ä¿å­˜å¤±è´¥: ' + (j.error || 'æœªçŸ¥é”™è¯¯')); return; }

  await fetch(`/api/bots/${botId}/start`, { method:'POST', credentials:'same-origin' });
  alert('å·²ä¿å­˜å¹¶å‘å¸ƒ');
  if(window.opener && !window.opener.closed){
    try{ window.opener.loadFlows && window.opener.loadFlows(); }catch(e){}
  }
}

// ---------------- æ‰“å¼€æ—¶å›žå¡« ----------------
async function loadFlowForEdit(){
  if(!botId) {
     const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
     return;
  }
  if(!flowId){
    const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
    return;
  }

  const r = await fetch(`/api/bots/${botId}/flows`, { credentials:'same-origin' });
  const j = await r.json();
  const item = (j.items||[]).find(x=>String(x.id)===String(flowId));
  if(!item){
     console.warn('æ‰¾ä¸åˆ° flow è®°å½•');
     const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
     return;
  }

  let compiled = item.blocks_compiled || safeParseBlocksJson(item.blocks_json);

  // å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨æ–°çš„ __workspaceState (JSON) æ¥åŠ è½½
  if(compiled && compiled.__workspaceState){
    try{
      Blockly.serialization.workspaces.load(compiled.__workspaceState, workspace);
      return;
    } catch(e){
      console.warn('JSONå·¥ä½œåŒºçŠ¶æ€è¿˜åŽŸå¤±è´¥ï¼Œé€€å›ž entries è¿‘ä¼¼è¿˜åŽŸï¼š', e);
    }
  }

  // åŽå¤‡æ–¹æ¡ˆï¼šå¦‚æžœåªæœ‰æ—§çš„ entries æ•°æ®ï¼Œåˆ™å°è¯•è¿‘ä¼¼é‡å»º
  if(compiled && compiled.entries){
    rebuildFromCompiled(compiled);
    return;
  }

  // å¦‚æžœå®Œå…¨æ²¡æœ‰å¯ç”¨çš„æ•°æ®ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„å…¥å£å—
  const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
}

document.getElementById('saveBtn').addEventListener('click', saveFlow);
loadFlowForEdit();
</script>
</body>
</html>
```
----- END FILE: static/blocks.html -----


----- BEGIN FILE: static/index.html -----
# Size: 62.4KB | Lines: 1422
```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bot ç®¡ç†å°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¤–</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    @keyframes fade-in-up {
      0% { opacity: 0; transform: translateY(16px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .animate-card { animation: fade-in-up 0.4s ease-out both; }
    .panel-tab {
      padding: 0.375rem 0.75rem;
      border-radius: 0.75rem;
      background-color: #f3f4f6;
      color: #4b5563;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.04);
    }
    .panel-tab:hover {
      background-color: #e5e7eb;
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(148,163,184,0.25);
    }
    .panel-tab.active {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: #fff;
      box-shadow: 0 12px 24px rgba(99,102,241,0.35);
    }
    .panel-surface {
      transition: opacity 0.2s ease;
    }
  </style>
</head>
<body class="bg-gray-50">
  <div class="max-w-5xl mx-auto p-6">
    <h1 class="text-2xl font-semibold mb-4">ðŸ¤– Bot ç®¡ç†å°ï¼ˆMVPï¼‰</h1>

    <!-- æœªç™»å½•è§†å›¾ -->
    <div id="auth" class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div class="bg-white rounded-xl shadow p-6">
        <h2 class="font-medium text-lg mb-2">ç™»å½•</h2>
        <div class="space-y-3">
          <input id="login_user" class="w-full border rounded-md px-3 py-2" placeholder="ç”¨æˆ·å" />
          <input id="login_pass" class="w-full border rounded-md px-3 py-2" placeholder="å¯†ç " type="password" />
          <button onclick="login()" class="px-4 py-2 rounded-md bg-black text-white">ç™»å½•</button>
          <div id="login_msg" class="text-sm text-red-500"></div>
        </div>
      </div>

      <div class="bg-white rounded-xl shadow p-6">
        <h2 class="font-medium text-lg mb-2">æ³¨å†Œ</h2>
        <div class="space-y-3">
          <input id="reg_user" class="w-full border rounded-md px-3 py-2" placeholder="ç”¨æˆ·å" />
          <input id="reg_pass" class="w-full border rounded-md px-3 py-2" placeholder="å¯†ç " type="password" />
          <button onclick="registerUser()" class="px-4 py-2 rounded-md bg-indigo-600 text-white">æ³¨å†Œ</button>
          <div id="reg_msg" class="text-sm text-red-500"></div>
        </div>
      </div>
    </div>

    <!-- å·²ç™»å½•è§†å›¾ -->
    <div id="app" class="hidden space-y-6">
      <div class="flex items-center justify-between">
        <div id="welcome" class="text-gray-700"></div>
        <button onclick="logout()" class="text-sm px-3 py-1.5 rounded-md bg-gray-200 hover:bg-gray-300">é€€å‡ºç™»å½•</button>
      </div>

      <!-- Bot åˆ—è¡¨ -->
      <div class="bg-white rounded-xl shadow p-6">
        <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between mb-4">
          <div>
            <h2 class="font-medium text-lg">æˆ‘çš„ Bots</h2>
            <p class="text-sm text-gray-500">ç‚¹å‡»å¡ç‰‡æŸ¥çœ‹è¯¦æƒ…ï¼Œå¯ç›´æŽ¥ä»Žåˆ—è¡¨å¯åŠ¨/åœæ­¢ã€‚</p>
          </div>
          <div class="grid grid-cols-1 md:grid-cols-3 gap-2 w-full md:w-auto">
            <input id="new_bot_name" class="border rounded-md px-3 py-1.5" placeholder="bot åç§°">
            <input id="new_bot_token" class="border rounded-md px-3 py-1.5" placeholder="BotFather token">
            <button onclick="addBot()" class="px-3 py-1.5 rounded-md bg-green-600 text-white transition-transform duration-200 hover:-translate-y-0.5 hover:shadow">æ·»åŠ </button>
          </div>
        </div>
        <div id="bot_cards" class="grid gap-4 md:grid-cols-2 xl:grid-cols-3"></div>
      </div>

      <!-- Bot æŽ§åˆ¶ä¸­å¿ƒ -->
      <div class="bg-white rounded-xl shadow p-6">
        <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between mb-4">
          <div>
            <h2 class="font-medium text-lg">Bot æŽ§åˆ¶ä¸­å¿ƒ <span id="current_bot" class="text-gray-500 text-sm"></span></h2>
            <p class="text-xs text-gray-400">æ‰€æœ‰å›ºå®šæŒ‡ä»¤ã€æµç¨‹ä¸Žä¼ªä»£ç é›†ä¸­ç®¡ç†ã€‚</p>
          </div>
          <div class="flex flex-wrap gap-2">
            <button onclick="startBot()" class="px-3 py-1.5 rounded-md bg-black text-white transition hover:-translate-y-0.5 hover:shadow">å¯åŠ¨/é‡è½½</button>
            <button onclick="stopBot()" class="px-3 py-1.5 rounded-md bg-gray-800 text-white transition hover:-translate-y-0.5 hover:shadow">åœæ­¢</button>
            <button onclick="syncMenu()" class="px-3 py-1.5 rounded-md bg-gray-200 transition hover:bg-gray-300">åŒæ­¥èœå•</button>
            <button onclick="openBlocks()" class="px-3 py-1.5 rounded-md bg-amber-500 text-white transition hover:-translate-y-0.5 hover:shadow">ç§¯æœ¨ç¼–æŽ’</button>
          </div>
        </div>
        <div class="flex flex-wrap gap-2 mb-4 border-b border-gray-100 pb-3">
          <button data-panel="commands" class="panel-tab active">å›ºå®šæŒ‡ä»¤</button>
          <button data-panel="flows" class="panel-tab">æµç¨‹ç¼–æŽ’</button>
          <button data-panel="pseudo" class="panel-tab">ä¸­æ–‡ä¼ªä»£ç </button>
          <button data-panel="pro" class="panel-tab">ä¸“ä¸šæ¨¡å¼</button>
        </div>

        <div id="panel-commands" class="panel-surface">
          <details class="rounded-xl border border-gray-200 bg-gray-50 p-4" open>
            <summary class="flex items-center justify-between cursor-pointer select-none text-sm font-medium text-gray-700">
              <span>æ·»åŠ æˆ–æ›´æ–°å›ºå®šæŒ‡ä»¤</span>
              <span class="text-xs text-gray-400">å¡«å†™åŽç‚¹å‡»ä¸‹æ–¹ä¿å­˜</span>
            </summary>
            <div class="grid md:grid-cols-6 gap-2 mt-3 items-center">
              <input id="cmd" class="border rounded-md px-3 py-2 w-full md:col-span-2" placeholder="/ping">
              <select id="kind" class="border rounded-md px-3 py-2">
                <option value="text">æ–‡æœ¬</option>
                <option value="photo">å›¾ç‰‡</option>
                <option value="document">æ–‡æ¡£</option>
                <option value="animation">åŠ¨ç”»/GIF</option>
              </select>
              <input id="reply" class="border rounded-md px-3 py-2 md:col-span-3" placeholder="æ–‡æœ¬ï¼šæ”¯æŒ {{args}} ç­‰å˜é‡ï¼›åª’ä½“ï¼šå¯åš caption">
              <input id="media_url" class="border rounded-md px-3 py-2 md:col-span-3 hidden" placeholder="åª’ä½“ URLï¼ˆphoto/document/animation ä½¿ç”¨ï¼‰">
              <select id="parse_mode" class="border rounded-md px-3 py-2">
                <option value="">ParseMode: None</option>
                <option value="MarkdownV2">MarkdownV2</option>
                <option value="HTML">HTML</option>
              </select>
              <label class="inline-flex items-center gap-2">
                <input id="no_preview" type="checkbox"> <span class="text-sm text-gray-600">ç¦ç”¨é“¾æŽ¥é¢„è§ˆ</span>
              </label>
              <button onclick="saveCmd()" class="px-3 py-2 rounded-md bg-indigo-600 text-white md:col-start-6">ä¿å­˜ / æ›´æ–°</button>
              <button onclick="eraseAll()" class="px-3 py-2 rounded-md bg-gray-200 md:col-start-6">æ¸…ç©ºå…¨éƒ¨</button>
            </div>
          </details>
          <div class="flex flex-col md:flex-row gap-2 mt-4 mb-2">
            <input id="cmd_ai_prompt" class="flex-1 border rounded-md px-3 py-2" placeholder="ç”¨ä¸€å¥è¯æè¿°æƒ³è¦çš„æŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼šæ¬¢è¿Žè®¿å®¢">
            <button onclick="aiGenerateCommand()" class="px-3 py-2 rounded-md bg-purple-600 text-white transition hover:-translate-y-0.5 hover:shadow">AI ç”ŸæˆæŒ‡ä»¤</button>
          </div>
          <p class="text-xs text-gray-400 mb-3">æç¤ºï¼šè‹¥å·²é…ç½® <code>DEEPSEEK_API_KEY</code> æˆ– <code>AI_API_KEY</code>ï¼Œå°†è°ƒç”¨ DeepSeek AIï¼›å¦åˆ™ä½¿ç”¨å†…ç½®æ¨¡æ¿ã€‚</p>
          <div id="cmd_cards" class="grid gap-3 md:grid-cols-2 xl:grid-cols-3"></div>
        </div>
         <div id="panel-pro" class="panel-surface hidden">
          <details class="rounded-xl border border-gray-200 bg-gray-50 p-4" open>
            <summary class="flex items-center justify-between cursor-pointer select-none text-sm font-medium text-gray-700">
              <span>ç¼–å†™ Python è„šæœ¬ (Pro)</span>
              <span class="text-xs text-gray-400">ç›´æŽ¥æŽ§åˆ¶ bot, update, context å¯¹è±¡</span>
            </summary>
            <div class="grid md:grid-cols-4 gap-3 mt-3">
              <input id="pro_name" class="border rounded-md px-3 py-2 md:col-span-2" placeholder="è„šæœ¬åç§°ï¼Œä¾‹å¦‚ï¼šæ¯æ—¥ç®€æŠ¥">
              <input id="pro_command" class="border rounded-md px-3 py-2 md:col-span-2" placeholder="è§¦å‘å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š/daily">
              <textarea id="pro_code" class="code-editor border rounded-md px-3 py-2 md:col-span-4 h-48" placeholder="# ä½ çš„ä»£ç ä¼šåŒ…è£…åœ¨ async def handler(bot, update, context, log) ä¸­&#10;# log('hello')&#10;await update.message.reply_text(f'Hello, {update.effective_user.first_name}')"></textarea>
              <input type="hidden" id="pro_id">
              <div class="flex items-center justify-between md:col-span-4">
                <label class="inline-flex items-center gap-2"><input id="pro_active" type="checkbox" checked> <span class="text-sm text-gray-600">å¯ç”¨</span></label>
                <div class="flex gap-2">
                  <button onclick="saveProScript()" class="px-4 py-2 rounded-md bg-indigo-600 text-white">ä¿å­˜è„šæœ¬</button>
                  <button onclick="resetProForm()" class="px-3 py-2 rounded-md bg-gray-200">æ¸…ç©ºè¡¨å•</button>
                </div>
              </div>
            </div>
          </details>
          <div id="pro_status" class="text-sm text-gray-600 my-3"></div>
          <table class="w-full text-sm">
            <thead><tr class="text-left text-gray-500"><th class="py-2 w-32">åç§°</th><th class="w-32">å‘½ä»¤</th><th>ä»£ç æ‘˜è¦</th><th class="w-24">çŠ¶æ€</th><th class="w-32">æ“ä½œ</th></tr></thead>
            <tbody id="pro_scripts_table"></tbody>
          </table>
        </div>
        <div id="panel-flows" class="panel-surface hidden">
          <details class="rounded-xl border border-gray-200 bg-gray-50 p-4" open>
            <summary class="flex items-center justify-between cursor-pointer select-none text-sm font-medium text-gray-700">
              <span>æµç¨‹æ“ä½œ</span>
              <span class="text-xs text-gray-400">ç®¡ç† Blockly æµç¨‹ç¼–æŽ’</span>
            </summary>
            <div class="flex flex-wrap gap-2 mt-3">
              <button onclick="openBlocks()" class="px-3 py-1.5 rounded-md bg-amber-500 text-white transition hover:-translate-y-0.5 hover:shadow">æ‰“å¼€ Blockly ç¼–è¾‘å™¨</button>
              <button onclick="publishFlows()" class="px-3 py-1.5 rounded-md bg-gray-800 text-white transition hover:-translate-y-0.5 hover:shadow">å‘å¸ƒ / é‡è½½</button>
            </div>
          </details>
          <p class="text-xs text-gray-400 mt-3 mb-3">æç¤ºï¼šBlockly ä¸­ä¿å­˜åŽä¼šå›žå†™åˆ°æ•°æ®åº“ï¼Œå†ç‚¹å‡»â€œå‘å¸ƒâ€å³å¯è®©è¿è¡Œä¸­çš„ Bot é‡è½½æœ€æ–°æµç¨‹ã€‚</p>
          <div id="flow_cards" class="grid gap-3 md:grid-cols-2 xl:grid-cols-3"></div>
        </div>

        <div id="panel-pseudo" class="panel-surface hidden">
          <details class="rounded-xl border border-gray-200 bg-gray-50 p-4" open>
            <summary class="flex items-center justify-between cursor-pointer select-none text-sm font-medium text-gray-700">
              <span>ç¼–å†™ / ç¼–è¾‘ä¸­æ–‡ä¼ªä»£ç </span>
              <span class="text-xs text-gray-400">æ”¯æŒ AI ç”Ÿæˆä¸Žæ²™ç›’æ¼”ç»ƒ</span>
            </summary>
            <div class="grid md:grid-cols-4 gap-3 mt-3">
              <input id="pseudo_title" class="border rounded-md px-3 py-2 md:col-span-1" placeholder="æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼šæ¬¢è¿Žæµç¨‹ä¼ªä»£ç ">
              <textarea id="pseudo_content" class="border rounded-md px-3 py-2 md:col-span-3 h-32" placeholder="ä½¿ç”¨ä¸­æ–‡ä¼ªä»£ç æè¿° Bot è¡Œä¸ºï¼Œä¾‹å¦‚ï¼š
1. ç”¨æˆ·å‘é€ /start
2. æœºå™¨äººå‘é€æ¬¢è¿Žæ–‡æœ¬..." ></textarea>
              <input type="hidden" id="pseudo_id">
              <div class="flex gap-2 md:col-start-4">
                <button onclick="savePseudocode()" class="flex-1 px-3 py-2 rounded-md bg-indigo-600 text-white">ä¿å­˜/æ›´æ–°ä¼ªä»£ç </button>
                <button onclick="resetPseudoForm()" class="px-3 py-2 rounded-md bg-gray-200">æ¸…ç©º</button>
              </div>
            </div>
          </details>
          <div class="flex flex-col md:flex-row gap-2 mb-3">
            <input id="pseudo_ai_prompt" class="flex-1 border rounded-md px-3 py-2" placeholder="è¾“å…¥éœ€æ±‚ï¼Œä¾‹å¦‚ï¼šç”Ÿæˆæ¬¢è¿Žæµç¨‹">
            <button onclick="aiGeneratePseudo()" class="px-3 py-2 rounded-md bg-purple-600 text-white transition hover:-translate-y-0.5 hover:shadow">AI ç”Ÿæˆä¼ªä»£ç </button>
          </div>
          <p class="text-xs text-gray-400 mb-3">æç¤ºï¼šè‹¥å·²é…ç½® <code>DEEPSEEK_API_KEY</code> æˆ– <code>AI_API_KEY</code>ï¼Œå°†è°ƒç”¨ DeepSeek AIï¼›å¦åˆ™ä½¿ç”¨ç¦»çº¿æ¨¡æ¿å¿«é€Ÿå¡«å……ã€‚</p>
          <div id="pseudo_status" class="text-sm text-gray-600 mb-3"></div>
          <div class="flex flex-col md:flex-row gap-2 mb-3">
            <input id="sandbox_input" class="flex-1 border rounded-md px-3 py-2" placeholder="æ²™ç›’æ¨¡æ‹Ÿè¾“å…¥ï¼Œä¾‹å¦‚ï¼š/start æˆ– 1">
            <button onclick="sandboxPseudo(document.getElementById('pseudo_id').value||null)" class="px-3 py-2 rounded-md bg-slate-800 text-white transition hover:-translate-y-0.5 hover:shadow">å¯¹å½“å‰å†…å®¹æ²™ç›’æ¼”ç»ƒ</button>
          </div>
          <table class="w-full text-sm">
            <thead><tr class="text-left text-gray-500"><th class="py-2 w-16">ID</th><th class="w-48">æ ‡é¢˜</th><th>å†…å®¹æ‘˜è¦</th><th class="w-48">æ“ä½œ</th></tr></thead>
            <tbody id="pseudocode_table"></tbody>
          </table>
          <div class="mt-4">
            <h4 class="text-sm font-medium text-gray-600 mb-2">æ²™ç›’æ¼”ç»ƒè¾“å‡º</h4>
            <pre id="sandbox_output" class="hidden bg-slate-900 text-sky-200 text-xs rounded-lg p-3 leading-5 whitespace-pre-wrap"></pre>
          </div>
        </div>

        <div id="status" class="text-sm text-gray-600 mt-4"></div>
      </div>

      <!-- ç¨‹åºæ€»è§ˆ -->
      <div class="bg-white rounded-xl shadow p-6">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-medium text-lg">ç¨‹åºæ€»è§ˆ</h2>
          <div class="flex items-center gap-2 text-sm">
            <span class="text-gray-400">å¿«é€Ÿå¤æŸ¥æŒ‡ä»¤ / æµç¨‹ / ä¼ªä»£ç </span>
            <button onclick="refreshOverview()" class="px-3 py-1.5 rounded-md bg-gray-200 hover:bg-gray-300">åˆ·æ–°</button>
          </div>
        </div>
        <div id="overview_content" class="space-y-4 text-sm text-gray-700">
          <div class="text-gray-500">æš‚æ— æ•°æ®ï¼Œè¯·å…ˆé€‰æ‹© Bot å¹¶åŠ è½½é…ç½®ã€‚</div>
        </div>
      </div>

      <!-- è¿è¡Œç›‘æŽ§ -->
      <div class="bg-white rounded-xl shadow p-6">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-medium text-lg">è¿è¡Œç›‘æŽ§</h2>
          <div class="space-x-2">
            <button onclick="refreshStatus()" class="px-3 py-1.5 rounded-md bg-gray-200">ç«‹å³åˆ·æ–°</button>
          </div>
        </div>
        <div id="runtime_summary" class="text-sm text-gray-700 mb-3"></div>
        <div class="grid md:grid-cols-2 gap-4">
          <div>
            <h3 class="font-medium text-gray-600 mb-2">å½“å‰ Bot çŠ¶æ€</h3>
            <table class="w-full text-sm">
              <tbody id="status_table"></tbody>
            </table>
          </div>
          <div>
            <h3 class="font-medium text-gray-600 mb-2">æœ€è¿‘æ—¥å¿—</h3>
            <pre id="log_box" class="bg-black text-green-200 text-xs p-3 rounded-md h-64 overflow-auto"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
let currentUser=null, currentBotId=null, pseudoCache={}, statusCache={};
let socket=null, socketReady=false, statusReconnectTimer=null;
let _logTimer=null;
let _loadBotsPending = false;
let commandsCache=[], flowsCache=[], pseudocodeCache=[];
let proScriptsCache = [];
const fmt = {
  time(seconds){
    const sec = Number(seconds||0);
    const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = Math.floor(sec%60);
    return `${h}h ${m}m ${s}s`;
  },
  date(ts){
    if(!ts) return '-';
    try{
      return new Date(ts).toLocaleString();
    }catch(e){
      return ts;
    }
  }
};

function escapeHtml(str=''){
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;');
}

function prettyJson(obj){
  try{
    if(typeof obj === 'string'){
      const parsed = JSON.parse(obj);
      return JSON.stringify(parsed, null, 2);
    }
    return JSON.stringify(obj, null, 2);
  }catch(e){
    return String(obj);
  }
}

function parseMaybeJson(raw){
  if(!raw) return null;
  if(typeof raw === 'object') return raw;
  try{ return JSON.parse(raw); }catch(e){ return null; }
}

function parseFlowCompiled(raw){
  if(!raw) return null;
  let data = raw;
  if(typeof data === 'string'){
    try { data = JSON.parse(data); } catch(e){ return null; }
    if(typeof data === 'string'){
      try { data = JSON.parse(data); } catch(e){ return null; }
    }
  }
  return (data && typeof data === 'object') ? data : null;
}

let botsCache=[];

function toggleDetails(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.classList.toggle('hidden');
  el.classList.toggle('animate-card');
}

const panelSections = {
  commands: () => document.getElementById('panel-commands'),
  flows: () => document.getElementById('panel-flows'),
  pro: () => document.getElementById('panel-pro'), // æ–°å¢ž
  pseudo: () => document.getElementById('panel-pseudo'),
};

const panelTabs = Array.from(document.querySelectorAll('[data-panel]'));
let activePanel = 'commands';

function setActivePanel(name){
  if(!panelSections[name]) return;
  activePanel = name;
  Object.keys(panelSections).forEach(key => {
    const section = panelSections[key]();
    if(!section) return;
    if(key === name){
      section.classList.remove('hidden');
      section.classList.add('animate-card');
    } else {
      section.classList.add('hidden');
    }
  });
  panelTabs.forEach(btn => {
    const target = btn.dataset.panel;
    if(target === name){
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

function commandPseudo(cmd){
  const lines = [];
  lines.push(`å½“ç”¨æˆ·å‘é€ ${cmd.command || ''}`);
  const kind = (cmd.kind || 'text').toLowerCase();
  if(kind === 'text'){
    const body = (cmd.reply || '').trim();
    lines.push(`  - æœºå™¨äººå›žå¤æ–‡æœ¬ã€Œ${body || '...'}ã€`);
    if(cmd.parse_mode){
      lines.push(`  - ä½¿ç”¨ ParseMode=${cmd.parse_mode}`);
    }
    if(cmd.disable_preview){
      lines.push('  - ç¦ç”¨é“¾æŽ¥é¢„è§ˆ');
    }
  } else if(['photo','document','animation','voice'].includes(kind)){
    const payload = parseMaybeJson(cmd.payload) || {};
    const url = payload.url || payload.file_id || '';
    const caption = payload.caption || cmd.reply || '';
    const mediaLabel = {photo:'å›¾ç‰‡', document:'æ–‡æ¡£', animation:'åŠ¨ç”»', voice:'è¯­éŸ³'}[kind] || kind;
    lines.push(`  - æœºå™¨äººå‘é€${mediaLabel} ${url ? `(${url})` : ''}`.trim());
    if(caption){
      lines.push(`  - é™„å¸¦è¯´æ˜Žã€Œ${caption}ã€`);
    }
  } else {
    lines.push(`  - æœºå™¨äººæ‰§è¡Œ ${kind} ç±»åž‹åŠ¨ä½œ`);
  }
  return lines.join('\n');
}

function describeFlowNode(node){
  if(!node) return '  - ...(æœªçŸ¥èŠ‚ç‚¹)';
  const t = node.type;
  switch(t){
    case 'send_text':
      return `  - å‘é€æ–‡æœ¬ã€Œ${(node.text||'').slice(0,32)}ã€`;
    case 'send_photo':
      return `  - å‘é€å›¾ç‰‡ ${node.url ? '('+node.url+')' : ''}`.trim();
    case 'send_document':
      return `  - å‘é€æ–‡æ¡£ ${node.url ? '('+node.url+')' : ''}`.trim();
    case 'send_animation':
      return `  - å‘é€åŠ¨ç”»/GIF ${node.url ? '('+node.url+')' : ''}`.trim();
    case 'send_voice':
      return `  - å‘é€è¯­éŸ³ ${node.url ? '('+node.url+')' : ''}`.trim();
    case 'send_sticker':
      return `  - å‘é€è´´çº¸ ${node.file_id ? '('+node.file_id+')' : ''}`.trim();
    case 'send_text_keyboard':
      return '  - å‘é€æ–‡æœ¬å¹¶é™„å¸¦æŒ‰é’®';
    case 'set_var':
      if((node.mode||'')==='random'){
        const r = node.random || {};
        const rMin = r.min != null ? r.min : 1;
        const rMax = r.max != null ? r.max : 100;
        return `  - è®¾ç½® ${node.scope||'chat'} å˜é‡ ${node.key||'k'} ä¸ºéšæœº ${rMin}~${rMax}`;
      }
      return `  - è®¾ç½® ${node.scope||'chat'} å˜é‡ ${node.key||'k'} = ${node.value||''}`;
    case 'inc_var':
      return `  - ${node.scope||'chat'} å˜é‡ ${node.key||'count'} += ${node.step||1}`;
    case 'get_var':
      return `  - è¯»å– ${node.scope||'chat'} å˜é‡ ${node.key||'k'} â†’ ${node.alias||'x'}`;
    case 'set_local_from_input':
      return `  - å°†è¾“å…¥æ–‡æœ¬ä¿å­˜åˆ°ä¸´æ—¶å˜é‡ ${node.alias||'x'}`;
    case 'if_var':
      const leftVar = (node.left && node.left.var) || 'x';
      const rightText = (node.right && node.right.text) || '';
      return `  - æ¡ä»¶åˆ¤æ–­ï¼šlocal.${leftVar} ${node.op||'eq'} ${rightText}`;
    case 'wait_next':
      return `  - ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆæœŸæœ›${node.expect==='number'?'æ•°å­—':'ä»»æ„'}ï¼‰ï¼Œæç¤ºã€Œ${node.prompt||''}ã€`;
    case 'http':
      return `  - è¯·æ±‚ ${node.method||'GET'} ${node.url||''}`;
    case 'delay':
      return `  - å»¶è¿Ÿ ${node.seconds||0} ç§’åŽç»§ç»­`;
    default:
      return `  - èŠ‚ç‚¹ ${t}`;
  }
}

function flowPseudo(compiled){
  if(!compiled || !Array.isArray(compiled.entries)) return 'æš‚æ— ä¼ªä»£ç ï¼Œè¯·å…ˆä¿å­˜æµç¨‹ã€‚';
  const lines = [];
  for(const entry of compiled.entries){
    const cmd = entry.command || entry.name || 'å…¥å£';
    lines.push(`å½“è§¦å‘ ${cmd}ï¼š`);
    const nodes = entry.nodes || [];
    if(!nodes.length){
      lines.push('  - ï¼ˆæ— åŠ¨ä½œï¼‰');
    } else {
      nodes.forEach(n => {
        lines.push(describeFlowNode(n));
        if(n.type === 'if_var'){
          (n.then||[]).forEach(child => lines.push('    THEN ' + describeFlowNode(child).replace(/^\s+-\s+/, '')));
          (n.else||[]).forEach(child => lines.push('    ELSE ' + describeFlowNode(child).replace(/^\s+-\s+/, '')));
        }
        if(n.type === 'wait_next'){
          (n.next||[]).forEach(child => lines.push('    NEXT ' + describeFlowNode(child).replace(/^\s+-\s+/, '')));
        }
      });
    }
    lines.push('');
  }
  return lines.join('\n');
}

async function me(){
  const res = await fetch('/api/me',{credentials:'same-origin'});
  const data = await res.json();
  currentUser = data.user;
  document.getElementById('auth').classList.toggle('hidden', !!currentUser);
  document.getElementById('app').classList.toggle('hidden', !currentUser);
  if(currentUser){
    document.getElementById('welcome').innerText = `ä½ å¥½ï¼Œ${currentUser.username}`;
    await loadBots();
    connectStatusSocket();
    refreshStatus();
    if(_logTimer) clearInterval(_logTimer);
    _logTimer = setInterval(refreshStatus, 5000);
  } else {
    disconnectStatusSocket();
    if(_logTimer){ clearInterval(_logTimer); _logTimer = null; }
  }
}
async function registerUser(){
  const username=document.getElementById('reg_user').value.trim();
  const password=document.getElementById('reg_pass').value;
  const r=await fetch('/api/register',{method:'POST',headers:{'Content-Type':'application/json'},credentials:'same-origin',body:JSON.stringify({username,password})});
  const j=await r.json(); document.getElementById('reg_msg').innerText=j.ok?'âœ… å·²æ³¨å†Œï¼ŒåŽ»ç™»å½•':'âŒ '+(j.error||'å¤±è´¥');
}
async function login(){
  const username=document.getElementById('login_user').value.trim();
  const password=document.getElementById('login_pass').value;
  const r=await fetch('/api/login',{method:'POST',headers:{'Content-Type':'application/json'},credentials:'same-origin',body:JSON.stringify({username,password})});
  const j=await r.json(); document.getElementById('login_msg').innerText=j.ok?'':'âŒ '+(j.error||'å¤±è´¥'); await me();
}
async function logout(){ await fetch('/api/logout',{method:'POST',credentials:'same-origin'}); location.reload(); }

function connectStatusSocket(){
  if(!currentUser) return;
  if(socket){
    if(!socket.connected){ socket.connect(); }
    return;
  }
  socket = io('/', {transports:['websocket'], withCredentials:true});
  socket.on('connect', () => {
    socketReady = true;
    socket.emit('subscribe_status');
  });
  socket.on('disconnect', () => {
    socketReady = false;
    scheduleSocketReconnect();
  });
  socket.on('connect_error', (err) => {
    console.warn('socket connect error', err);
    scheduleSocketReconnect();
  });
  socket.on('auth_error', (payload) => {
    console.warn('socket auth error', payload);
  });
  socket.on('bot_status', payload => {
    applyStatusPayload(payload);
  });
}

function scheduleSocketReconnect(){
  if(statusReconnectTimer || !currentUser) return;
  statusReconnectTimer = setTimeout(() => {
    statusReconnectTimer = null;
    if(!currentUser) return;
    if(socket){
      if(!socket.connected){
        try { socket.connect(); } catch (err) { console.warn('socket reconnect failed', err); }
      }
    } else {
      connectStatusSocket();
    }
  }, 4000);
}

function disconnectStatusSocket(){
  if(statusReconnectTimer){
    clearTimeout(statusReconnectTimer);
    statusReconnectTimer = null;
  }
  if(socket){
    try { socket.disconnect(); } catch (err) { console.warn('socket disconnect error', err); }
    socket = null;
  }
  socketReady = false;
}

function applyStatusPayload(payload){
  const items = (payload && payload.items) || [];
  const keep = new Set();
  items.forEach(item => {
    const id = Number(item.bot_id);
    keep.add(id);
    statusCache[id] = item;
    const existing = botsCache.find(b => Number(b.id) === id);
    if(existing){
      if(item.name) existing.name = item.name;
      if(item.token_mask) existing.token_mask = item.token_mask;
    } else {
      botsCache.push({ id, name: item.name || `Bot #${id}`, token_mask: item.token_mask || '' });
    }
  });
  Object.keys(statusCache).forEach(key => {
    const id = Number(key);
    if(!keep.has(id)) delete statusCache[id];
  });
  renderBotCards();
  updateRuntimeSummary();
  if(currentBotId && statusCache[currentBotId]){
    updateStatusTable(statusCache[currentBotId]);
  }
}

function updateRuntimeSummary(){
  const wrap = document.getElementById('runtime_summary');
  if(!wrap) return;
  const items = Object.values(statusCache).filter(item =>
    botsCache.some(bot => Number(bot.id) === Number(item.bot_id))
  );
  if(!items.length){
    wrap.innerHTML = '<span class="text-sm text-gray-400">æš‚æ— å®žæ—¶çŠ¶æ€</span>';
    return;
  }
  wrap.innerHTML = items.map(it => {
    const stats = it.stats || {};
    const label = escapeHtml(it.name || `Bot #${it.bot_id}`);
    const badgeClass = it.state === 'running' ? 'border-emerald-300' : 'border-gray-300';
    return `<span class="inline-block mr-2 mb-2 px-2 py-0.5 rounded border ${badgeClass}">${label} ${badge(it.state)} <span class="text-xs text-gray-500">m:${stats.messages||0}/e:${stats.errors||0}</span></span>`;
  }).join(' ');
}

function updateStatusTable(snapshot){
  const table = document.getElementById('status_table');
  if(!table) return;
  const stats = snapshot.stats || {};
  const lastErr = snapshot.last_error ? `<div class="text-red-600 truncate" title="${escapeHtml(snapshot.last_error)}">${escapeHtml(snapshot.last_error)}</div>` : '';
  table.innerHTML = `
    <tr class="border-t"><td class="py-1 pr-4 text-gray-500">State</td><td class="py-1">${badge(snapshot.state||'stopped')}</td></tr>
    <tr class="border-t"><td class="py-1 pr-4 text-gray-500">Uptime</td><td class="py-1">${fmt.time(snapshot.uptime||0)}</td></tr>
    <tr class="border-t"><td class="py-1 pr-4 text-gray-500">Messages</td><td class="py-1">${stats.messages||0}</td></tr>
    <tr class="border-t"><td class="py-1 pr-4 text-gray-500">Errors</td><td class="py-1">${stats.errors||0} ${lastErr}</td></tr>
    <tr class="border-t"><td class="py-1 pr-4 text-gray-500">Specs/Flows</td><td class="py-1">${snapshot.specs_count||0} / ${snapshot.flows_count||0}</td></tr>
  `;
}
async function loadBots(){
  if(_loadBotsPending) return botsCache;
  _loadBotsPending = true;
  try {
    const res = await fetch('/api/bots',{credentials:'same-origin'});
    const botsJson = await res.json();
    const bots = botsJson.items || [];
    botsCache = bots;
    const validIds = new Set(bots.map(b => Number(b.id)));
    Object.keys(statusCache).forEach(key => {
      if(!validIds.has(Number(key))) delete statusCache[key];
    });
    renderBotCards();
    updateRuntimeSummary();
    if(currentBotId && statusCache[currentBotId]){
      updateStatusTable(statusCache[currentBotId]);
    }
    if(bots.length){
      const existing = bots.find(b => Number(b.id) === Number(currentBotId));
      if(existing){
        document.getElementById('current_bot').innerText=`ï¼ˆå½“å‰ï¼š${existing.name} #${existing.id}ï¼‰`;
        highlightSelectedBot(existing.id);
      } else {
        selectBot(bots[0].id, bots[0].name);
      }
    } else {
      currentBotId = null;
      document.getElementById('current_bot').innerText='';
      document.getElementById('cmd_cards').innerHTML='';
      document.getElementById('flow_cards').innerHTML='';
      document.getElementById('runtime_summary').innerHTML='';
      document.getElementById('status_table').innerHTML='';
      commandsCache = [];
      flowsCache = [];
      pseudocodeCache = [];
      updateOverview();
    }
    return bots;
  } finally {
    _loadBotsPending = false;
  }
}

function renderBotCards(){
  const wrap = document.getElementById('bot_cards');
  if(!wrap) return;
  const bots = botsCache || [];
  wrap.innerHTML = '';
  if(!bots.length){
    wrap.innerHTML = '<div class="text-sm text-gray-500">æš‚æ—  Botï¼Œè¯·å…ˆåˆ›å»ºã€‚</div>';
    return;
  }
  bots.forEach(bot => {
    const snap = statusCache[bot.id] || {};
    const card = document.createElement('div');
    card.className = 'bot-card animate-card rounded-2xl border border-gray-100 bg-gradient-to-br from-white via-white to-gray-50 shadow transition-all duration-300 hover:-translate-y-1 hover:shadow-xl';
    card.dataset.botId = bot.id;
    const state = snap.state || 'stopped';
    const stats = snap.stats || {messages:0, errors:0};
    const tokenMask = snap.token_mask || bot.token_mask || '';
    const displayName = escapeHtml(bot.name || `Bot #${bot.id}`);
    const safeName = (bot.name || `Bot #${bot.id}`).replace(/'/g, "\'");
    card.innerHTML = `
      <div class="p-5 h-full flex flex-col gap-4" onclick="selectBot(${bot.id}, '${safeName}')">
        <div class="flex items-start justify-between gap-3">
          <div>
            <div class="flex items-center gap-2">
              <span class="text-lg font-semibold text-gray-800">${displayName}</span>
              <span class="text-xs px-2 py-0.5 rounded-full bg-gray-100 text-gray-500">ID ${bot.id}</span>
            </div>
            <p class="text-xs text-gray-400 mt-1">Token: ${escapeHtml(tokenMask)}</p>
          </div>
          <div class="text-sm">${badge(state)}</div>
        </div>
        <div class="grid grid-cols-2 gap-3 text-sm text-gray-600">
          <div>
            <div class="text-xs text-gray-400">è¿è¡Œæ—¶é•¿</div>
            <div class="font-medium">${fmt.time(snap.uptime||0)}</div>
          </div>
          <div>
            <div class="text-xs text-gray-400">æ¶ˆæ¯ / é”™è¯¯</div>
            <div class="font-medium">${stats.messages||0} / ${stats.errors||0}</div>
          </div>
          <div>
            <div class="text-xs text-gray-400">å›ºå®šæŒ‡ä»¤</div>
            <div class="font-medium">${snap.specs_count||0}</div>
          </div>
          <div>
            <div class="text-xs text-gray-400">æµç¨‹æ•°</div>
            <div class="font-medium">${snap.flows_count||0}</div>
          </div>
        </div>
        <div class="mt-auto flex flex-wrap gap-2 text-sm">
          <button class="px-3 py-1.5 rounded-md bg-indigo-600 text-white transition hover:opacity-90" onclick="event.stopPropagation(); selectBot(${bot.id}, '${safeName}')">è¯¦æƒ…</button>
          <button class="px-3 py-1.5 rounded-md bg-emerald-500 text-white transition hover:opacity-90" onclick="event.stopPropagation(); currentBotId=${bot.id}; startBot();">å¯åŠ¨</button>
          <button class="px-3 py-1.5 rounded-md bg-gray-700 text-white transition hover:opacity-90" onclick="event.stopPropagation(); currentBotId=${bot.id}; stopBot();">åœæ­¢</button>
          <button class="px-3 py-1.5 rounded-md bg-gray-200 transition hover:bg-gray-300" onclick="event.stopPropagation(); currentBotId=${bot.id}; syncMenu();">åŒæ­¥èœå•</button>
          <button class="px-3 py-1.5 rounded-md bg-red-50 text-red-600 transition hover:bg-red-100" onclick="event.stopPropagation(); delBot(${bot.id});">åˆ é™¤</button>
        </div>
      </div>
    `;
    wrap.appendChild(card);
  });
  highlightSelectedBot(currentBotId);
}
function updateOverview(){
  const wrap = document.getElementById('overview_content');
  if(!wrap) return;
  const total = commandsCache.length + flowsCache.length + pseudocodeCache.length;
  if(total === 0){
    wrap.innerHTML = '<div class="text-gray-500">æš‚æ— æ•°æ®ï¼Œè¯·å…ˆåŠ è½½ Bot é…ç½®ã€‚</div>';
    return;
  }
  const summary = `
    <div class="grid md:grid-cols-3 gap-3 text-xs text-gray-500 mb-3">
      <div class="rounded-lg border border-gray-200 bg-gray-50 p-3">
        <div class="text-xs uppercase tracking-wide text-gray-400">å›ºå®šæŒ‡ä»¤</div>
        <div class="text-lg font-semibold text-gray-800">${commandsCache.length}</div>
      </div>
      <div class="rounded-lg border border-gray-200 bg-gray-50 p-3">
        <div class="text-xs uppercase tracking-wide text-gray-400">æµç¨‹ç¼–æŽ’</div>
        <div class="text-lg font-semibold text-gray-800">${flowsCache.length}</div>
      </div>
      <div class="rounded-lg border border-gray-200 bg-gray-50 p-3">
        <div class="text-xs uppercase tracking-wide text-gray-400">ä¸­æ–‡ä¼ªä»£ç </div>
        <div class="text-lg font-semibold text-gray-800">${pseudocodeCache.length}</div>
      </div>
    </div>`;

  const sections = [summary];

  if(commandsCache.length){
    const cmdList = commandsCache.slice(0,5).map(cmd => {
      const pseudo = commandPseudo(cmd);
      const codeData = {
        command: cmd.command,
        kind: cmd.kind,
        reply: cmd.reply,
        parse_mode: cmd.parse_mode,
        disable_preview: cmd.disable_preview,
        payload: cmd.payload,
      };
      return `
        <details class="rounded-lg border border-gray-200 bg-white/70 p-3">
          <summary class="flex items-center justify-between text-sm font-medium text-gray-700 cursor-pointer select-none">
            <span>${escapeHtml(cmd.command)}</span>
            <span class="text-xs text-gray-400">${escapeHtml(cmd.kind || 'text')}</span>
          </summary>
          <div class="grid md:grid-cols-2 gap-3 mt-2 text-xs">
            <div>
              <div class="text-gray-400 mb-1">ä¼ªä»£ç </div>
              <pre class="bg-amber-50 text-amber-900 rounded-lg p-3 whitespace-pre-wrap">${escapeHtml(pseudo)}</pre>
            </div>
            <div>
              <div class="text-gray-400 mb-1">JSON</div>
              <pre class="bg-slate-900 text-emerald-300 rounded-lg p-3 overflow-auto max-h-44">${escapeHtml(prettyJson(codeData))}</pre>
            </div>
          </div>
        </details>`;
    }).join('');
    sections.push(`
      <section class="space-y-2">
        <h3 class="text-sm font-semibold text-gray-600">å›ºå®šæŒ‡ä»¤æ¦‚è§ˆ</h3>
        ${cmdList}
        ${commandsCache.length>5 ? '<p class="text-xs text-gray-400">ä»…å±•ç¤ºå‰ 5 æ¡ï¼Œå…¶ä½™è¯·åœ¨ä¸Šæ–¹é¢æ¿æŸ¥çœ‹ã€‚</p>' : ''}
      </section>`);
  }

  if(flowsCache.length){
    const flowList = flowsCache.slice(0,5).map(flow => {
      const pseudo = flowPseudo(flow.compiled || {});
      return `
        <details class="rounded-lg border border-gray-200 bg-white/70 p-3">
          <summary class="flex items-center justify-between text-sm font-medium text-gray-700 cursor-pointer select-none">
            <span>${escapeHtml(flow.name)}</span>
            <span class="text-xs text-gray-400">${flow.active ? 'å¯ç”¨' : 'åœç”¨'}</span>
          </summary>
          <div class="grid md:grid-cols-2 gap-3 mt-2 text-xs">
            <div>
              <div class="text-gray-400 mb-1">ä¼ªä»£ç </div>
              <pre class="bg-amber-50 text-amber-900 rounded-lg p-3 whitespace-pre-wrap">${escapeHtml(pseudo)}</pre>
            </div>
            <div>
              <div class="text-gray-400 mb-1">èŠ‚ç‚¹ JSON</div>
              <pre class="bg-slate-900 text-sky-200 rounded-lg p-3 overflow-auto max-h-44">${escapeHtml(prettyJson(flow.compiled || {}))}</pre>
            </div>
          </div>
        </details>`;
    }).join('');
    sections.push(`
      <section class="space-y-2">
        <h3 class="text-sm font-semibold text-gray-600">æµç¨‹ç¼–æŽ’æ¦‚è§ˆ</h3>
        ${flowList}
        ${flowsCache.length>5 ? '<p class="text-xs text-gray-400">ä»…å±•ç¤ºå‰ 5 æ¡ï¼Œå…¶ä½™è¯·åœ¨ä¸Šæ–¹é¢æ¿æŸ¥çœ‹ã€‚</p>' : ''}
      </section>`);
  }

  if(pseudocodeCache.length){
    const pseudoList = pseudocodeCache.slice(0,5).map(item => {
      const preview = (item.content || '').split('\n').slice(0,6).join('\n');
      return `
        <details class="rounded-lg border border-gray-200 bg-white/70 p-3">
          <summary class="flex items-center justify-between text-sm font-medium text-gray-700 cursor-pointer select-none">
            <span>${escapeHtml(item.title || 'æœªå‘½åä¼ªä»£ç ')}</span>
            <span class="text-xs text-gray-400">ID ${item.id}</span>
          </summary>
          <div class="mt-2 text-xs text-gray-600 whitespace-pre-wrap bg-amber-50 text-amber-900 rounded-lg p-3">${escapeHtml(preview)}</div>
        </details>`;
    }).join('');
    sections.push(`
      <section class="space-y-2">
        <h3 class="text-sm font-semibold text-gray-600">ä¸­æ–‡ä¼ªä»£ç æ¦‚è§ˆ</h3>
        ${pseudoList}
        ${pseudocodeCache.length>5 ? '<p class="text-xs text-gray-400">ä»…å±•ç¤ºå‰ 5 æ¡ï¼Œå…¶ä½™è¯·åœ¨ä¸Šæ–¹é¢æ¿æŸ¥çœ‹ã€‚</p>' : ''}
      </section>`);
  }

  wrap.innerHTML = sections.join('');
}

async function refreshOverview(){
  if(!currentBotId){
    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª Bot');
    return;
  }
  await Promise.all([loadCmds(), loadFlows(), loadPseudocode()]);
}


function highlightSelectedBot

function highlightSelectedBot(id){
  const cards = document.querySelectorAll('.bot-card');
  cards.forEach(card => {
    if(id != null && Number(card.dataset.botId) === Number(id)){
      card.classList.add('ring','ring-indigo-400','shadow-2xl');
    }else{
      card.classList.remove('ring','ring-indigo-400','shadow-2xl');
    }
  });
}

async function addBot(){
  const name=document.getElementById('new_bot_name').value.trim();
  const token=document.getElementById('new_bot_token').value.trim();
  if(!name||!token){alert('name/token å¿…å¡«');return;}
  const r=await fetch('/api/bots',{method:'POST',headers:{'Content-Type':'application/json'},credentials:'same-origin',body:JSON.stringify({name,token})});
  const j=await r.json(); if(!j.ok){alert(j.error||'å¤±è´¥');return;}
  document.getElementById('new_bot_name').value=''; document.getElementById('new_bot_token').value='';
  loadBots();
}

async function delBot(id){
  if(!confirm('ç¡®è®¤åˆ é™¤è¯¥ botï¼Ÿ')) return;
  const r=await fetch('/api/bots/'+id,{method:'DELETE',credentials:'same-origin'}); const j=await r.json();
  if(!j.ok) alert(j.error||'å¤±è´¥');
  currentBotId=null;
  document.getElementById('current_bot').innerText='';
  document.getElementById('cmd_cards').innerHTML='';
  document.getElementById('flow_cards').innerHTML='';
  loadBots();
}

/* --------- é€‰ä¸­ botï¼šåŠ è½½æ•°æ® + å¯åŠ¨è½®è¯¢ --------- */
function selectBot(id, name){
  currentBotId=id;
  document.getElementById('current_bot').innerText=`ï¼ˆå½“å‰ï¼š${name} #${id}ï¼‰`;
  highlightSelectedBot(id);
  loadCmds();
  loadFlows();
  loadProScripts(); // æ–°å¢ž
  resetPseudoForm();
  loadPseudocode();
  refreshStatus();
  if(_logTimer) clearInterval(_logTimer);
  _logTimer = setInterval(refreshStatus, 5000);
}
window.addEventListener('beforeunload', ()=>{
  if(_logTimer) clearInterval(_logTimer);
  disconnectStatusSocket();
});

/* ---------- æŒ‡ä»¤ ---------- */
function resetProForm(){
  document.getElementById('pro_id').value = '';
  document.getElementById('pro_name').value = '';
  document.getElementById('pro_command').value = '';
  document.getElementById('pro_code').value = '';
  document.getElementById('pro_active').checked = true;
  document.getElementById('pro_status').innerText = '';
}

async function loadProScripts() {
    if(!currentBotId) return;
    const r = await fetch(`/api/bots/${currentBotId}/pro_scripts`, { credentials: 'same-origin' });
    const j = await r.json();
    const tb = document.getElementById('pro_scripts_table');
    tb.innerHTML = '';
    proScriptsCache = j.items || [];

    proScriptsCache.forEach(it => {
        const tr = document.createElement('tr');
        tr.className = 'border-t';
        const excerpt = (it.code || '').split('\n')[0].slice(0, 50) + '...';
        tr.innerHTML = `<td class="py-2">${escapeHtml(it.name)}</td>
            <td><code>${escapeHtml(it.command)}</code></td>
            <td class="text-gray-500"><code>${escapeHtml(excerpt)}</code></td>
            <td><span class="text-xs px-2 py-0.5 rounded-full ${it.active ? 'bg-emerald-100 text-emerald-600' : 'bg-gray-100 text-gray-500'}">${it.active ? 'å¯ç”¨' : 'åœç”¨'}</span></td>
            <td class="space-x-2">
                <button class="text-sm text-indigo-600" onclick="editProScript(${it.id})">ç¼–è¾‘</button>
                <button class="text-sm text-red-600" onclick="deleteProScript(${it.id})">åˆ é™¤</button>
            </td>`;
        tb.appendChild(tr);
    });
}

function editProScript(id) {
    const script = proScriptsCache.find(s => s.id === id);
    if (!script) return;
    document.getElementById('pro_id').value = script.id;
    document.getElementById('pro_name').value = script.name;
    document.getElementById('pro_command').value = script.command;
    document.getElementById('pro_code').value = script.code;
    document.getElementById('pro_active').checked = !!script.active;
    document.getElementById('pro_status').innerText = `âœï¸ ç¼–è¾‘è„šæœ¬: ${script.name}`;
    setActivePanel('pro');
}

async function saveProScript() {
    if (!currentBotId) { alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª Bot'); return; }
    const id = document.getElementById('pro_id').value || undefined;
    const payload = {
        name: document.getElementById('pro_name').value,
        command: document.getElementById('pro_command').value,
        code: document.getElementById('pro_code').value,
        active: document.getElementById('pro_active').checked,
    };
    if (id) payload.id = Number(id);

    const r = await fetch(`/api/bots/${currentBotId}/pro_scripts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify(payload),
    });
    const j = await r.json();
    const statusEl = document.getElementById('pro_status');
    statusEl.innerText = j.ok ? 'âœ… è„šæœ¬å·²ä¿å­˜ã€‚é‡å¯/é‡è½½ Bot åŽç”Ÿæ•ˆã€‚' : `âŒ ä¿å­˜å¤±è´¥: ${j.error || 'æœªçŸ¥é”™è¯¯'}`;
    if (j.ok) {
        resetProForm();
        loadProScripts();
    }
}

async function deleteProScript(id) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè„šæœ¬å—ï¼Ÿ')) return;
    const r = await fetch(`/api/bots/${currentBotId}/pro_scripts/${id}`, {
        method: 'DELETE',
        credentials: 'same-origin',
    });
    const j = await r.json();
    const statusEl = document.getElementById('pro_status');
    statusEl.innerText = j.ok ? 'ðŸ—‘ï¸ è„šæœ¬å·²åˆ é™¤ã€‚' : `âŒ åˆ é™¤å¤±è´¥: ${j.error || 'æœªçŸ¥é”™è¯¯'}`;
    loadProScripts();
}
async function loadCmds(){
  if(!currentBotId) return;
  const r=await fetch(`/api/bots/${currentBotId}/commands`,{credentials:'same-origin'}); const j=await r.json();
  const wrap=document.getElementById('cmd_cards');
  wrap.innerHTML='';
  const items = j.items || [];
  commandsCache = items.map(it => ({...it}));
  if(!items.length){
    wrap.innerHTML = '<div class="text-sm text-gray-500">æš‚æ— å›ºå®šæŒ‡ä»¤ï¼Œå…ˆåœ¨ä¸Šæ–¹æ·»åŠ ä¸€ä¸ªå§ï½ž</div>';
    updateOverview();
    return;
  }
  items.forEach((it, idx)=>{
    const payloadParsed = parseMaybeJson(it.payload) || {};
    const card = document.createElement('div');
    const domId = `${it.id||idx}`;
    card.className='animate-card rounded-2xl border border-gray-100 bg-white shadow transition-all duration-300 hover:-translate-y-0.5 hover:shadow-xl';
    const pseudo = commandPseudo({...it, payload: payloadParsed});
    const codeJson = prettyJson({
      command: it.command,
      kind: it.kind,
      reply: it.reply,
      parse_mode: it.parse_mode,
      disable_preview: it.disable_preview,
      payload: payloadParsed
    });
    card.innerHTML = `
      <div class="p-4 flex flex-col gap-3">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h3 class="text-base font-semibold text-gray-800 flex items-center gap-2">
              ${escapeHtml(it.command)}
              <span class="text-xs px-2 py-0.5 rounded-full bg-indigo-50 text-indigo-600">${escapeHtml(it.kind||'text')}</span>
            </h3>
            <p class="text-xs text-gray-400 mt-1">ParseMode: ${it.parse_mode || 'None'} ï½œ é¢„è§ˆï¼š${it.disable_preview? 'å…³é—­':'å¼€å¯'}</p>
          </div>
          <button class="text-sm text-red-500 hover:text-red-600" onclick="delCmd('${it.command.replaceAll("'","\\'")}'); event.stopPropagation();">åˆ é™¤</button>
        </div>
        <div class="text-sm text-gray-600">
          ${(it.reply || payloadParsed.text || '').slice(0,80) || 'ï¼ˆæ— é»˜è®¤æ–‡æœ¬ï¼‰'}
        </div>
        <div class="flex flex-wrap gap-2 text-xs">
          <button class="px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200" onclick="toggleDetails('cmd-code-${domId}')">æŸ¥çœ‹ä»£ç </button>
          <button class="px-3 py-1.5 rounded-md bg-amber-100 hover:bg-amber-200" onclick="toggleDetails('cmd-pseudo-${domId}')">æŸ¥çœ‹ä¼ªä»£ç </button>
        </div>
        <pre id="cmd-code-${domId}" class="hidden bg-gray-900 text-emerald-200 rounded-lg p-3 text-xs overflow-auto max-h-48">${escapeHtml(codeJson)}</pre>
        <pre id="cmd-pseudo-${domId}" class="hidden bg-amber-50 text-amber-900 rounded-lg p-3 text-xs leading-5 whitespace-pre-wrap">${escapeHtml(pseudo)}</pre>
      </div>`;
    wrap.appendChild(card);
  });
  updateOverview();
}

async function saveCmd(){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  const command = document.getElementById('cmd').value.trim();
  const kind = document.getElementById('kind').value;
  const reply = document.getElementById('reply').value.trim();
  const parse_mode = document.getElementById('parse_mode').value || null;
  const disable_preview = document.getElementById('no_preview').checked;
  const media_url = document.getElementById('media_url').value.trim();

  let payload = null;
  if(kind === 'text'){
    payload = { text: reply || '' };
  } else {
    payload = { url: media_url || '', caption: reply || '' };
  }

  const r = await fetch(`/api/bots/${currentBotId}/commands`,{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    credentials:'same-origin',
    body: JSON.stringify({ command, kind, reply, payload, parse_mode, disable_preview })
  });
  const j = await r.json();
  document.getElementById('status').innerText = j.ok ? 'âœ… å·²ä¿å­˜' : ('âŒ '+(j.error||'å¤±è´¥'));
  loadCmds();
}

async function delCmd(command){
  const r=await fetch(`/api/bots/${currentBotId}/commands/`+encodeURIComponent(command.replace(/^\//,'')),{method:'DELETE',credentials:'same-origin'});
  const j=await r.json(); document.getElementById('status').innerText=j.ok?'ðŸ—‘ï¸ å·²åˆ ':'âŒ å¤±è´¥'; loadCmds();
}

async function eraseAll(){
  if(!confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰å‘½ä»¤ï¼Ÿ')) return;
  const r=await fetch(`/api/bots/${currentBotId}/commands`,{method:'DELETE',credentials:'same-origin'}); const j=await r.json();
  document.getElementById('status').innerText=j.ok?'ðŸ§¹ å·²æ¸…ç©º':'âŒ å¤±è´¥'; loadCmds();
}

async function aiGenerateCommand(){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  const prompt = document.getElementById('cmd_ai_prompt').value.trim();
  const r = await fetch('/api/ai/generate', {
    method:'POST',
    credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ mode:'command', prompt })
  });
  const j = await r.json();
  if(!j.ok){
    document.getElementById('status').innerText = 'âŒ '+(j.error||'AI ç”ŸæˆæŒ‡ä»¤å¤±è´¥');
    return;
  }
  const result = j.result || {};
  document.getElementById('cmd').value = result.command || '/auto';
  document.getElementById('kind').value = result.kind || 'text';
  document.getElementById('reply').value = result.reply || '';
  document.getElementById('parse_mode').value = result.parse_mode || '';
  document.getElementById('no_preview').checked = !!result.disable_preview;
  const meta = j.meta || {};
  let note = 'ðŸ¤– å·²æ ¹æ®æç¤ºç”ŸæˆæŒ‡ä»¤è‰ç¨¿ï¼Œç¡®è®¤åŽç‚¹å‡»ä¿å­˜ã€‚';
  if(meta.api_key_configured === false){
    note += 'ï¼ˆå½“å‰ä½¿ç”¨ç¦»çº¿æ¨¡æ¿ï¼Œå¦‚éœ€çœŸå®ž AIï¼Œè¯·é…ç½® AI_API_KEYã€‚ï¼‰';
  }
  document.getElementById('status').innerText = note;
  setActivePanel('commands');
}

/* ---------- è¿è¡ŒæŽ§åˆ¶ ---------- */
async function startBot(){
  const r=await fetch(`/api/bots/${currentBotId}/start`,{method:'POST',credentials:'same-origin'}); const j=await r.json();
  document.getElementById('status').innerText=j.ok?('ðŸš€ '+j.msg):('âŒ '+(j.error||j.msg));
  refreshStatus();
  loadBots();
}
async function stopBot(){
  const r=await fetch(`/api/bots/${currentBotId}/stop`,{method:'POST',credentials:'same-origin'}); const j=await r.json();
  document.getElementById('status').innerText=j.ok?('ðŸ›‘ '+j.msg):('âŒ '+(j.error||j.msg));
  refreshStatus();
  loadBots();
}
async function syncMenu(){
  const r=await fetch(`/api/bots/${currentBotId}/sync`,{method:'POST',credentials:'same-origin'}); const j=await r.json();
  document.getElementById('status').innerText=j.ok?('ðŸ”„ '+j.msg):('âŒ '+(j.error||j.msg));
}

/* ---------- Flow ç›¸å…³ ---------- */
function openBlocks(flowId){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  window.open(`/static/blocks.html?bot_id=${currentBotId}` + (flowId?`&flow_id=${flowId}`:''), '_blank');
}

async function loadFlows(){
  if(!currentBotId) return;
  const r = await fetch(`/api/bots/${currentBotId}/flows`, { credentials:'same-origin' });
  const j = await r.json();
  const wrap = document.getElementById('flow_cards');
  wrap.innerHTML = '';
  const rawItems = j.items || [];
  const items = rawItems.map(f => ({...f, compiled: f.blocks_compiled || parseFlowCompiled(f.blocks_json)}));
  flowsCache = items;
  if(!items.length){
    wrap.innerHTML = '<div class="text-sm text-gray-500">æš‚æ— æµç¨‹ï¼Œç‚¹å‡»å³ä¸Šè§’ã€Œæ–°å»º/ç¼–è¾‘ã€å¼€å§‹åˆ›å»ºã€‚</div>';
    updateOverview();
    return;
  }
  items.forEach((f, idx)=>{
    const pseudo = flowPseudo(f.compiled);
    const codeJson = f.compiled ? prettyJson(f.compiled) : prettyJson(f.blocks_json || {});
    const card = document.createElement('div');
    card.className = 'animate-card rounded-2xl border border-gray-100 bg-white shadow transition-all duration-300 hover:-translate-y-0.5 hover:shadow-xl';
    const domId = `${f.id||idx}`;
    card.innerHTML = `
      <div class="p-4 flex flex-col gap-3">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h3 class="text-base font-semibold text-gray-800 flex items-center gap-2">
              ${escapeHtml(f.name)}
              <span class="text-xs px-2 py-0.5 rounded-full ${f.active? 'bg-emerald-100 text-emerald-600':'bg-gray-100 text-gray-500'}">${f.active?'å¯ç”¨':'åœç”¨'}</span>
            </h3>
            <p class="text-xs text-gray-400 mt-1">æ›´æ–°ï¼š${fmt.date(f.updated_at || f.created_at)}</p>
          </div>
          <div class="flex flex-col gap-1 text-xs text-right text-gray-400">
            <button class="text-indigo-600 hover:text-indigo-700" onclick="openBlocks(${f.id}); event.stopPropagation();">ç¼–è¾‘</button>
            <button class="text-red-500 hover:text-red-600" onclick="deleteFlow(${f.id}); event.stopPropagation();">åˆ é™¤</button>
          </div>
        </div>
        <div class="text-sm text-gray-600 whitespace-pre-wrap max-h-24 overflow-hidden">
          ${escapeHtml(pseudo.split('\n').slice(0,4).join('\n'))}${pseudo.split('\n').length>4?'\n...':''}
        </div>
        <div class="flex flex-wrap gap-2 text-xs">
          <button class="px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200" onclick="toggleDetails('flow-code-${domId}')">æŸ¥çœ‹ä»£ç </button>
          <button class="px-3 py-1.5 rounded-md bg-amber-100 hover:bg-amber-200" onclick="toggleDetails('flow-pseudo-${domId}')">æŸ¥çœ‹ä¼ªä»£ç </button>
        </div>
        <pre id="flow-code-${domId}" class="hidden bg-gray-900 text-sky-200 rounded-lg p-3 text-xs overflow-auto max-h-56">${escapeHtml(codeJson)}</pre>
        <pre id="flow-pseudo-${domId}" class="hidden bg-amber-50 text-amber-900 rounded-lg p-3 text-xs leading-5 whitespace-pre-wrap">${escapeHtml(pseudo)}</pre>
      </div>`;
    wrap.appendChild(card);
  });
  updateOverview();
}


async function deleteFlow(flowId){
  if(!confirm('ç¡®è®¤åˆ é™¤è¯¥æµç¨‹ï¼Ÿ')) return;
  const r = await fetch(`/api/bots/${currentBotId}/flows/${flowId}`, { method:'DELETE', credentials:'same-origin' });
  const j = await r.json();
  document.getElementById('status').innerText = j.ok ? 'ðŸ—‘ï¸ å·²åˆ é™¤æµç¨‹' : 'âŒ åˆ é™¤å¤±è´¥';
  loadFlows();
}

async function publishFlows(){
  const r = await fetch(`/api/bots/${currentBotId}/start`, { method:'POST', credentials:'same-origin' });
  const j = await r.json();
  document.getElementById('status').innerText = j.ok ? 'ðŸš€ å·²å‘å¸ƒï¼ˆé‡è½½ï¼‰' : ('âŒ '+(j.error||j.msg));
  refreshStatus();
  loadBots();
}

/* ---------- ä¼ªä»£ç ï¼ˆä¸­æ–‡ï¼‰ ---------- */
function resetPseudoForm(){
  document.getElementById('pseudo_id').value='';
  document.getElementById('pseudo_title').value='';
  document.getElementById('pseudo_content').value='';
  document.getElementById('pseudo_status').innerText='';
}

async function loadPseudocode(){
  if(!currentBotId) return;
  const r = await fetch(`/api/bots/${currentBotId}/pseudocode`, { credentials:'same-origin' });
  const j = await r.json();
  const tb = document.getElementById('pseudocode_table');
  tb.innerHTML='';
  pseudoCache = {};
  const sandboxBox = document.getElementById('sandbox_output');
  if(sandboxBox){ sandboxBox.classList.add('hidden'); sandboxBox.textContent=''; }
  const items = (j.items||[]).map(it => ({...it}));
  pseudocodeCache = items;
  items.forEach(it=>{
    pseudoCache[it.id] = it;
    const tr = document.createElement('tr'); tr.className='border-t';
    // ä¿®å¤ï¼šå°†éžæ³•çš„æ¢è¡Œç¬¦æ›¿æ¢ä¸º \n
    const excerpt = (it.content||'').split('\n').slice(0,2).join(' / ');
    tr.innerHTML = `<td class="py-2">${it.id}</td>
      <td>${it.title}</td>
      <td class="text-gray-500">${escapeHtml(excerpt)}</td>
      <td class="space-x-2">
        <button class="text-indigo-600" onclick="editPseudocode(${it.id}); event.stopPropagation();">ç¼–è¾‘</button>
        <button class="text-emerald-600" onclick="generateFlowFromPseudo(${it.id}); event.stopPropagation();">ç”Ÿæˆæµç¨‹</button>
        <button class="text-amber-600" onclick="sandboxPseudo(${it.id}); event.stopPropagation();">æ²™ç›’</button>
        <button class="text-red-600" onclick="deletePseudocode(${it.id}); event.stopPropagation();">åˆ é™¤</button>
      </td>`;
    tb.appendChild(tr);
  });
  updateOverview();
}


function editPseudocode(id){
  const data = pseudoCache && pseudoCache[id];
  if(!data) return;
  document.getElementById('pseudo_id').value = data.id;
  document.getElementById('pseudo_title').value = data.title || '';
  document.getElementById('pseudo_content').value = data.content || '';
  document.getElementById('pseudo_status').innerText = 'âœï¸ å½“å‰ç¼–è¾‘ï¼š' + data.title;
}

async function savePseudocode(){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  const id = document.getElementById('pseudo_id').value || undefined;
  const title = document.getElementById('pseudo_title').value.trim();
  const content = document.getElementById('pseudo_content').value.trim();
  if(!title || !content){
    document.getElementById('pseudo_status').innerText = 'âŒ è¯·å¡«å†™æ ‡é¢˜å’Œå†…å®¹ï¼ˆä¸­æ–‡ä¼ªä»£ç ï¼‰ã€‚';
    return;
  }
  const payload = { title, content };
  if(id) payload.id = Number(id);
  const r = await fetch(`/api/bots/${currentBotId}/pseudocode`, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    credentials:'same-origin',
    body: JSON.stringify(payload),
  });
  const j = await r.json();
  document.getElementById('pseudo_status').innerText = j.ok ? 'âœ… ä¼ªä»£ç å·²ä¿å­˜' : ('âŒ '+(j.error||'ä¿å­˜å¤±è´¥'));
  if(j.ok){
    resetPseudoForm();
    loadPseudocode();
  }
}

async function deletePseudocode(id){
  if(!confirm('ç¡®å®šåˆ é™¤è¯¥ä¼ªä»£ç ï¼Ÿ')) return;
  const r = await fetch(`/api/bots/${currentBotId}/pseudocode/${id}`, { method:'DELETE', credentials:'same-origin' });
  const j = await r.json();
  document.getElementById('pseudo_status').innerText = j.ok ? 'ðŸ—‘ï¸ å·²åˆ é™¤ä¼ªä»£ç ' : ('âŒ '+(j.error||'åˆ é™¤å¤±è´¥'));
  loadPseudocode();
}

async function generateFlowFromPseudo(id){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  const targetId = id || document.getElementById('pseudo_id').value;
  if(!targetId){
    document.getElementById('pseudo_status').innerText = 'âŒ è¯·å…ˆé€‰æ‹©æˆ–ä¿å­˜ä¼ªä»£ç ã€‚';
    return;
  }
  const r = await fetch(`/api/bots/${currentBotId}/pseudocode/${targetId}/generate_flow`, {
    method:'POST',
    credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({})
  });
  const j = await r.json();
  if(!j.ok){
    document.getElementById('pseudo_status').innerText = 'âŒ '+(j.error||'ç”Ÿæˆæµç¨‹å¤±è´¥');
    return;
  }
  document.getElementById('pseudo_status').innerText = `âœ… å·²ç”Ÿæˆæµç¨‹ã€Œ${j.name}ã€ï¼Œå‘½ä»¤ ${j.command}`;
  loadFlows();
  setActivePanel('flows');
}

async function sandboxPseudo(id){
  if(!currentBotId){ alert('å…ˆé€‰æ‹©ä¸€ä¸ª bot'); return; }
  const targetId = id || document.getElementById('pseudo_id').value;
  if(!targetId){
    document.getElementById('pseudo_status').innerText = 'âŒ è¯·å…ˆé€‰æ‹©æˆ–ä¿å­˜ä¼ªä»£ç ã€‚';
    return;
  }
  const sandboxInputEl = document.getElementById('sandbox_input');
  const sandboxInputVal = sandboxInputEl ? sandboxInputEl.value : '';
  const r = await fetch(`/api/bots/${currentBotId}/pseudocode/${targetId}/sandbox`, {
    method:'POST',
    credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ input: sandboxInputVal || '/demo' })
  });
  const j = await r.json();
  const box = document.getElementById('sandbox_output');
  if(!j.ok){
    box.classList.remove('hidden');
    box.textContent = 'âŒ '+(j.error||'æ²™ç›’è¿è¡Œå¤±è´¥');
    return;
  }
  const lines = [];
  lines.push(`å‘½ä»¤: ${j.command}`);
  lines.push(j.summary || '');
  (j.actions||[]).forEach((act, idx)=>{
    lines.push(`${idx+1}. [${act.type}] ${act.text || act.url || act.prompt || JSON.stringify(act)}`);
  });
  if(j.analysis){
    lines.push('\nè§£æž:');
    lines.push(j.analysis);
  }
  box.classList.remove('hidden');
  box.textContent = lines.join('\n');
  setActivePanel('pseudo');
}

async function aiGeneratePseudo(){
  const prompt = document.getElementById('pseudo_ai_prompt').value.trim();
  const r = await fetch('/api/ai/generate', {
    method:'POST',
    credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ mode:'pseudocode', prompt })
  });
  const j = await r.json();
  if(!j.ok){
    document.getElementById('pseudo_status').innerText = 'âŒ '+(j.error||'AI ç”Ÿæˆå¤±è´¥');
    return;
  }
  const result = j.result || {};
  document.getElementById('pseudo_title').value = result.title || '';
  document.getElementById('pseudo_content').value = result.content || '';
  const meta = j.meta || {};
  let note = 'ðŸ¤– å·²æ ¹æ®æç¤ºç”Ÿæˆä¼ªä»£ç ï¼Œè®°å¾—ä¿å­˜ã€‚';
  if(meta.api_key_configured === false){
    note += 'ï¼ˆå½“å‰ä½¿ç”¨å†…ç½®æ¨¡æ¿ï¼Œå¦‚éœ€æŽ¥å…¥çœŸå®ž AIï¼Œè¯·åœ¨çŽ¯å¢ƒå˜é‡ AI_API_KEY ä¸­é…ç½®å¯†é’¥ã€‚ï¼‰';
  }
  document.getElementById('pseudo_status').innerText = note;
  setActivePanel('pseudo');
}

/* ---------- ç›‘æŽ§ & æ—¥å¿— ---------- */
function fmtUptime(sec){
  return fmt.time(sec);
}
function badge(state){
  const map = { running:'bg-emerald-100 text-emerald-700', stopped:'bg-gray-100 text-gray-700', errored:'bg-red-100 text-red-700', starting:'bg-amber-100 text-amber-700' };
  const cls = map[state] || 'bg-gray-100 text-gray-700';
  return `<span class="px-2 py-0.5 rounded ${cls}">${state}</span>`;
}
async function refreshStatus(){
  if(!currentBotId) return;
  try {
    if(statusCache[currentBotId]){
      updateStatusTable(statusCache[currentBotId]);
    }
    const res = await fetch(`/api/bots/${currentBotId}/status`, { credentials:'same-origin' });
    const data = await res.json();
    const status = data.status || {};
    const prior = statusCache[currentBotId] || {};
    statusCache[currentBotId] = Object.assign({}, prior, status, { bot_id: currentBotId, name: prior.name || status.name });
    updateStatusTable(statusCache[currentBotId]);
  } catch (err) {
    console.warn('refresh status failed', err);
  }

  try {
    const logRes = await fetch(`/api/bots/${currentBotId}/logs?lines=150`, { credentials:'same-origin' });
    const logs = (await logRes.json()).items || [];
    const box = document.getElementById('log_box');
    box.textContent = logs.map(entry => {
      const ts = new Date((entry.ts||0)*1000).toLocaleTimeString();
      return `[${ts}] ${entry.level||'info'}: ${entry.msg}`;
    }).join('
');
    box.scrollTop = box.scrollHeight;
  } catch (err) {
    console.warn('refresh logs failed', err);
  }

  updateRuntimeSummary();
}

panelTabs.forEach(btn => {


panelTabs.forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    setActivePanel(btn.dataset.panel);
  });
});
setActivePanel(activePanel);

const kindSel = document.getElementById('kind');
const mediaUrl = document.getElementById('media_url');
if(kindSel && mediaUrl){
  const syncMediaField = () => {
    mediaUrl.classList.toggle('hidden', kindSel.value === 'text');
  };
  kindSel.addEventListener('change', syncMediaField);
  syncMediaField();
}

me();
</script>
</body>
</html>
```
----- END FILE: static/index.html -----


## Summary
Total files: 33
Total size: 188.0KB
Total lines: 4797
