<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ç§¯æœ¨ç¼–æ’</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body class="bg-gray-50">
  <div class="max-w-6xl mx-auto p-4 space-y-3">
    <div class="flex items-center justify-between">
      <h1 class="text-xl font-semibold">ğŸ§± ç§¯æœ¨ç¼–æ’</h1>
      <div class="space-x-2">
        <button id="saveBtn" class="px-3 py-1.5 rounded-md bg-amber-500 text-white">ä¿å­˜å¹¶å‘å¸ƒ</button>
        <button onclick="window.close()" class="px-3 py-1.5 rounded-md bg-gray-200">å…³é—­</button>
      </div>
    </div>
    <div id="hint" class="text-sm text-gray-500"></div>
    <div id="blocklyArea" class="h-[72vh] bg-white rounded-xl shadow"></div>
  </div>

<script>
// ---------------- URL å‚æ•° ----------------
const params = new URLSearchParams(location.search);
const botId = params.get('bot_id');
const flowId = params.get('flow_id');
document.getElementById('hint').innerText = botId ? `ç›®æ ‡ Bot: #${botId}${flowId? 'ï¼Œç¼–è¾‘ Flow #'+flowId : 'ï¼Œæ–°å»º Flow'}` : 'ç¼ºå°‘ bot_id å‚æ•°';

// ---------------- è‡ªå®šä¹‰å—ï¼ˆå…ˆå®šä¹‰ï¼Œå†æ³¨å…¥ï¼‰ ----------------
Blockly.defineBlocksWithJsonArray([
  // å…¥å£
  {"type":"on_command","message0":"å½“æ”¶åˆ°å‘½ä»¤ /%1","args0":[{"type":"field_input","name":"CMD","text":"guess"}],
   "nextStatement":null, "colour":210, "tooltip":"å…¥å£å—ï¼ˆä¸€ä¸ªå‘½ä»¤ä¸€ä¸ªå…¥å£ï¼‰"},

  // å‘é€æ–‡æœ¬ï¼ˆå¸¦ ParseMode & é¢„è§ˆï¼‰
  {"type":"send_text","message0":"å‘é€æ–‡æœ¬ %1","args0":[{"type":"field_input","name":"TEXT","text":"ä½ å¥½ï¼Œ{{user.first_name}}"}],
   "message1":"ParseMode %1  ç¦ç”¨é“¾æ¥é¢„è§ˆ %2",
   "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},
            {"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
   "previousStatement":null, "nextStatement":null, "colour":160},

  // åª’ä½“
  {"type":"send_photo","message0":"å‘é€å›¾ç‰‡ URL %1 è¯´æ˜ %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_document","message0":"å‘é€æ–‡æ¡£ URL %1 è¯´æ˜ %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_animation","message0":"å‘é€åŠ¨ç”»/GIF URL %1 è¯´æ˜ %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_voice","message0":"å‘é€è¯­éŸ³ URL %1 è¯´æ˜ %2",
   "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
   "message1":"ParseMode %1",
   "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_sticker","message0":"å‘é€è´´çº¸ file_id %1",
   "args0":[{"type":"field_input","name":"FILE","text":"CAACAgUAAxkBAAIDlmT63..."}],
   "previousStatement":null, "nextStatement":null, "colour":160},
  {"type":"send_text_keyboard","message0":"å‘é€æ–‡æœ¬+æŒ‰é’® %1",
   "args0":[{"type":"field_input","name":"TEXT","text":"è¯·é€‰æ‹©æ“ä½œ"}],
   "message1":"æŒ‰é’® JSON %1",
   "args1":[{"type":"field_input","name":"KB","text":"[[{\"text\":\"æŒ‰é’®\",\"callback_data\":\"ping\"}]]"}],
   "message2":"ParseMode %1  ç¦ç”¨é¢„è§ˆ %2",
   "args2":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},
            {"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
   "previousStatement":null, "nextStatement":null, "colour":160},

  // å˜é‡ï¼šå†™å…¥ï¼ˆéšæœº/æ–‡æœ¬ï¼‰ã€è¯»å–åˆ°ä¸´æ—¶å˜é‡ã€è‡ªå¢
  {"type":"set_var_rand","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = éšæœº %3 åˆ° %4",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"secret"},
            {"type":"field_number","name":"MIN","value":1},
            {"type":"field_number","name":"MAX","value":100}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"set_var_val","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = æ–‡æœ¬ %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"name"},
            {"type":"field_input","name":"VAL","text":"{{user.username}}"}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"inc_var","message0":"è‡ªå¢ ä½œç”¨åŸŸ %1 å˜é‡ %2 æ­¥é•¿ %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"count"},
            {"type":"field_number","name":"STEP","value":1}],
   "previousStatement":null, "nextStatement":null, "colour":60},
  {"type":"get_var","message0":"è¯»å– ä½œç”¨åŸŸ %1 å˜é‡ %2 â†’ ä¸´æ—¶å %3",
   "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"secret"},
            {"type":"field_input","name":"ALIAS","text":"x"}],
   "previousStatement":null, "nextStatement":null, "colour":200},
  {"type":"set_local_from_input","message0":"ä»¤ ä¸´æ—¶å˜é‡ %1 = å½“å‰æ¶ˆæ¯æ–‡æœ¬",
   "args0":[{"type":"field_input","name":"ALIAS","text":"guess"}],
   "previousStatement":null, "nextStatement":null, "colour":200},

  // æ¡ä»¶ï¼ˆç”¨ä¸´æ—¶å˜é‡ï¼‰
  {"type":"if_var","message0":"å¦‚æœ ä¸´æ—¶å˜é‡ %1 %2 %3",
   "args0":[{"type":"field_input","name":"LHS","text":"x"},
            {"type":"field_dropdown","name":"OP","options":[["=","eq"],["â‰ ","ne"],["åŒ…å«","contains"],[">","gt"],["<","lt"]]},
            {"type":"field_input","name":"RHS","text":"42"}],
   "message1":"é‚£ä¹ˆ %1","args1":[{"type":"input_statement","name":"THEN"}],
   "message2":"å¦åˆ™ %1","args2":[{"type":"input_statement","name":"ELSE"}],
   "previousStatement":null, "nextStatement":null, "colour":20},

  // ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯
  {"type":"wait_next","message0":"ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆ%1ï¼‰ å¹¶æç¤º %2",
   "args0":[{"type":"field_dropdown","name":"EXPECT","options":[["ä»»æ„","any"],["æ•°å­—","number"]]},
            {"type":"field_input","name":"PROMPT","text":"è¯·è¾“å…¥â€¦"}],
   "previousStatement":null, "nextStatement":null, "colour":290},

  // å»¶è¿Ÿæ‰§è¡Œ
  {"type":"delay_seconds","message0":"ç­‰å¾… %1 ç§’",
   "args0":[{"type":"field_number","name":"SEC","value":3,"min":0,"max":300,"precision":0.5}],
   "previousStatement":null, "nextStatement":null, "colour":290},

  // HTTPï¼ˆheaders/body + ä¿å­˜ JSON è·¯å¾„ï¼‰
  {"type":"http_block","message0":"HTTP %1 %2",
   "args0":[{"type":"field_dropdown","name":"METHOD","options":[["GET","GET"],["POST","POST"]]},
            {"type":"field_input","name":"URL","text":"https://api.github.com/zen"}],
   "message1":"Headers(JSON) %1","args1":[{"type":"field_input","name":"HEAD","text":"{}"}],
   "message2":"Body(JSON) %1","args2":[{"type":"field_input","name":"BODY","text":""}],
   "message3":"ä¿å­˜åˆ° %1.%2ï¼ˆJSONè·¯å¾„å¯é€‰ %3 ï¼‰",
   "args3":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},
            {"type":"field_input","name":"KEY","text":"resp"},
            {"type":"field_input","name":"JPATH","text":""}],
   "previousStatement":null, "nextStatement":null, "colour":300}
]);

// ---------------- æ³¨å…¥ ----------------
const workspace = Blockly.inject('blocklyArea', {
  toolbox: {
    "kind": "flyoutToolbox",
    "contents": [
      { "kind":"label","text":"è§¦å‘" },
      { "kind":"block","type":"on_command" },

      { "kind":"label","text":"åŠ¨ä½œ" },
      { "kind":"block","type":"send_text" },
      { "kind":"block","type":"send_photo" },
      { "kind":"block","type":"send_document" },
      { "kind":"block","type":"send_animation" },
      { "kind":"block","type":"send_voice" },
      { "kind":"block","type":"send_sticker" },
      { "kind":"block","type":"send_text_keyboard" },

      { "kind":"label","text":"å˜é‡" },
      { "kind":"block","type":"set_var_val" },
      { "kind":"block","type":"set_var_rand" },
      { "kind":"block","type":"inc_var" },
      { "kind":"block","type":"get_var" },
      { "kind":"block","type":"set_local_from_input" },

      { "kind":"label","text":"é€»è¾‘" },
      { "kind":"block","type":"if_var" },
      { "kind":"block","type":"wait_next" },
      { "kind":"block","type":"delay_seconds" },

      { "kind":"label","text":"ç½‘ç»œ" },
      { "kind":"block","type":"http_block" }
    ]
  },
  scrollbars: true,
  trashcan: true,
});

// ---------------- å·¥å…·ï¼šç¨³å¥è§£æ & æ—§æ•°æ®é‡å»º ----------------
function safeParseBlocksJson(raw) {
  try {
    let x = raw;
    if (typeof x === 'string') {
      x = JSON.parse(x);
      if (typeof x === 'string') x = JSON.parse(x);
    }
    return (x && typeof x === 'object') ? x : null;
  } catch(e) {
    console.warn('safeParseBlocksJson failed:', e);
    return null;
  }
}

function rebuildFromCompiled(compiled){
  if(!compiled || !Array.isArray(compiled.entries)) return;
  workspace.clear();

  let offsetX = 20;
  const chainTo = (prev, block) => {
    block.initSvg(); block.render();
    if(prev && prev.nextConnection && block.previousConnection){
      prev.nextConnection.connect(block.previousConnection);
    }
    return block;
  };

  compiled.entries.forEach((entry)=>{
    // å…¥å£
    const on = workspace.newBlock('on_command');
    on.setFieldValue((entry.command||'/cmd').replace(/^\//,''), 'CMD');
    on.initSvg(); on.render(); on.moveBy(offsetX, 20);

    let prev = on;

    const applyBasicSend = (node) => {
      let b = null;
      if(node.type==='send_text'){
        b = workspace.newBlock('send_text');
        b.setFieldValue(node.text || '', 'TEXT');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
        b.setFieldValue(node.disable_preview ? 'TRUE' : 'FALSE', 'NOPREVIEW');
      } else if(node.type==='send_photo'){
        b = workspace.newBlock('send_photo');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_document'){
        b = workspace.newBlock('send_document');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_animation'){
        b = workspace.newBlock('send_animation');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
      } else if(node.type==='send_voice'){
        b = workspace.newBlock('send_voice');
        b.setFieldValue(node.url || '', 'URL');
        b.setFieldValue(node.caption || '', 'CAP');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
      } else if(node.type==='send_sticker'){
        b = workspace.newBlock('send_sticker');
        b.setFieldValue(node.file_id || node.sticker || '', 'FILE');
      } else if(node.type==='send_text_keyboard'){
        b = workspace.newBlock('send_text_keyboard');
        b.setFieldValue(node.text || '', 'TEXT');
        const kbRaw = node.keyboard || node.keyboard_json || node.buttons;
        b.setFieldValue(typeof kbRaw === 'string' ? kbRaw : (kbRaw ? JSON.stringify(kbRaw) : ''), 'KB');
        b.setFieldValue(node.parse_mode || '', 'PARSE');
        b.setFieldValue(node.disable_preview ? 'TRUE' : 'FALSE', 'NOPREVIEW');
      } else if(node.type==='delay'){
        b = workspace.newBlock('delay_seconds');
        b.setFieldValue(String(node.seconds || 0), 'SEC');
      }
      if (b) {
        prev = chainTo(prev, b);
      }
    };

    const nodes = entry.nodes || [];
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      switch(n.type){
        case 'send_text':
        case 'send_photo':
        case 'send_document':
        case 'send_animation':
        case 'send_voice':
        case 'send_sticker':
        case 'send_text_keyboard':
        case 'delay':
          applyBasicSend(n);
          break;

        case 'set_var': {
          const mode = n.mode || (n.random ? 'random' : 'text');
          if(mode==='random'){
            const b = workspace.newBlock('set_var_rand');
            b.setFieldValue(n.scope || 'chat', 'SCOPE');
            b.setFieldValue(n.key || 'k', 'KEY');
            const rr = n.random || {};
            b.setFieldValue(String(rr.min ?? 1), 'MIN');
            b.setFieldValue(String(rr.max ?? 100), 'MAX');
            prev = chainTo(prev, b);
          }else{
            const b = workspace.newBlock('set_var_val');
            b.setFieldValue(n.scope || 'chat', 'SCOPE');
            b.setFieldValue(n.key || 'k', 'KEY');
            b.setFieldValue(n.value || '', 'VAL');
            prev = chainTo(prev, b);
          }
          break;
        }

        case 'inc_var': {
          const b = workspace.newBlock('inc_var');
          b.setFieldValue(n.scope || 'chat', 'SCOPE');
          b.setFieldValue(n.key || 'count', 'KEY');
          b.setFieldValue(String(n.step ?? 1), 'STEP');
          prev = chainTo(prev, b);
          break;
        }

        case 'get_var': {
          const b = workspace.newBlock('get_var');
          b.setFieldValue(n.scope || 'chat', 'SCOPE');
          b.setFieldValue(n.key || 'k', 'KEY');
          b.setFieldValue(n.alias || 'x', 'ALIAS');
          prev = chainTo(prev, b);
          break;
        }

        case 'set_local_from_input': {
          const b = workspace.newBlock('set_local_from_input');
          b.setFieldValue(n.alias || 'x', 'ALIAS');
          prev = chainTo(prev, b);
          break;
        }

        // æ—§ç‰ˆ ifï¼ˆæ— å˜é‡ï¼‰ï¼Œå°½åŠ›æ˜ å°„æˆ if_varï¼ˆç”¨ä¸´æ—¶å˜é‡ xï¼‰
        case 'if':
        case 'if_var': {
          const b = workspace.newBlock('if_var');
          if (n.type === 'if_var') {
             b.setFieldValue((n.left && n.left.var) || 'x', 'LHS');
             b.setFieldValue(n.op || 'eq', 'OP');
             b.setFieldValue((n.right && n.right.text) || '', 'RHS');
          } else { // 'if'
            b.setFieldValue('x', 'LHS');
            b.setFieldValue(n.op || 'eq', 'OP');
            b.setFieldValue((n.right && (n.right.text||'')) || '', 'RHS');
          }

          const buildBranch = (branchNodes, inputName) => {
              let branchPrev = null;
              (branchNodes||[]).forEach(nn=>{
                let nb=null;
                if(nn.type==='send_text'){ nb=workspace.newBlock('send_text'); nb.setFieldValue(nn.text||'','TEXT'); }
                else if(nn.type==='send_photo'){ nb=workspace.newBlock('send_photo'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_document'){ nb=workspace.newBlock('send_document'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_animation'){ nb=workspace.newBlock('send_animation'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); }
                else if(nn.type==='send_voice'){ nb=workspace.newBlock('send_voice'); nb.setFieldValue(nn.url||'','URL'); nb.setFieldValue(nn.caption||'','CAP'); nb.setFieldValue(nn.parse_mode||'','PARSE'); }
                else if(nn.type==='send_sticker'){ nb=workspace.newBlock('send_sticker'); nb.setFieldValue(nn.file_id||nn.sticker||'','FILE'); }
                else if(nn.type==='send_text_keyboard'){ nb=workspace.newBlock('send_text_keyboard'); nb.setFieldValue(nn.text||'','TEXT'); nb.setFieldValue(typeof nn.keyboard==='string'?nn.keyboard:(nn.keyboard?JSON.stringify(nn.keyboard): (nn.keyboard_json||'')),'KB'); nb.setFieldValue(nn.parse_mode||'','PARSE'); nb.setFieldValue(nn.disable_preview?'TRUE':'FALSE','NOPREVIEW'); }
                else if(nn.type==='delay'){ nb=workspace.newBlock('delay_seconds'); nb.setFieldValue(String(nn.seconds||0),'SEC'); }
                if(nb){
                  nb.initSvg(); nb.render();
                  if(!branchPrev){ b.getInput(inputName).connection.connect(nb.previousConnection); }
                  else{ branchPrev.nextConnection.connect(nb.previousConnection); }
                  branchPrev = nb;
                }
              });
          };

          buildBranch(n.then, 'THEN');
          buildBranch(n.else, 'ELSE');

          prev = chainTo(prev, b);
          break;
        }

        case 'http': {
          const b = workspace.newBlock('http_block');
          b.setFieldValue(n.method || 'GET', 'METHOD');
          b.setFieldValue(n.url || '', 'URL');
          b.setFieldValue(
            (typeof n.headers==='string') ? n.headers : (n.headers? JSON.stringify(n.headers):''),
            'HEAD'
          );
          b.setFieldValue(
            (typeof n.body==='string') ? n.body : (n.body? JSON.stringify(n.body):''),
            'BODY'
          );
          b.setFieldValue((n.save_to && n.save_to.scope) || 'chat', 'SCOPE');
          b.setFieldValue((n.save_to && n.save_to.key) || 'resp', 'KEY');
          b.setFieldValue(n.json_path || '', 'JPATH');
          prev = chainTo(prev, b);
          break;
        }

        case 'wait_next': {
          const b = workspace.newBlock('wait_next');
          // ä¿®å¤ï¼šä¸‹æ‹‰èœå•çš„å€¼æ˜¯ 'any' æˆ– 'number'ï¼Œè€Œä¸æ˜¯ä¸­æ–‡
          b.setFieldValue(n.expect === 'number' ? 'number' : 'any', 'EXPECT');
          b.setFieldValue(n.prompt || '', 'PROMPT');
          prev = chainTo(prev, b);

          // ç­‰å¾…åçš„ next é¡ºç€ä¸»é“¾æ‹¼ä¸Šï¼ˆç¼–è¾‘æ€å¯è§æ€§æ›´å¥½ï¼‰
          (n.next||[]).forEach(nn => applyBasicSend(nn));

          // å…³é”®ä¿®å¤ï¼šåœ¨è¿™é‡Œè·³å‡ºä¸»å¾ªç¯ï¼Œå› ä¸ºåç»­èŠ‚ç‚¹éƒ½å±äº next çš„èŒƒç•´
          i = nodes.length; // è®¾ç½® i åˆ°æœ«å°¾æ¥ç»ˆæ­¢å¾ªç¯
          break;
        }

        default:
          console.warn('Unknown node type in rebuild:', n.type, n);
      }
    }

    offsetX += 340;
  });

  try{
    const hint = document.getElementById('hint');
    if(hint && !hint.innerText.includes('è¿‘ä¼¼è¿˜åŸ')) {
        hint.innerHTML += ' ï½œ æœ¬æ¬¡ä» <code>entries</code> è¿‘ä¼¼è¿˜åŸï¼Œä¿å­˜ä¸€æ¬¡åå°†ç²¾ç¡®è¿˜åŸã€‚';
    }
  }catch(e){}
}

// ---------------- ç¼–è¯‘ JSON ----------------
function toFlowJSON() {
  const blocks = workspace.getTopBlocks(true);
  const entries = [];
  blocks.forEach((b, bi)=>{
    if(b.type!=='on_command') return;
    const cmd = b.getFieldValue('CMD') || ('cmd'+(bi+1));
    const nodes = [];
    let cur = b; // ä»å…¥å£å—å¼€å§‹

    // Helper to process a chain of blocks
    const processChain = (startBlock) => {
        let chainNodes = [];
        let current = startBlock;
        while(current){
            switch(current.type){
                case 'send_text':
                  chainNodes.push({type:'send_text', text: current.getFieldValue('TEXT'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'send_photo':
                  chainNodes.push({type:'send_photo', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_document':
                  chainNodes.push({type:'send_document', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_animation':
                  chainNodes.push({type:'send_animation', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_voice':
                  chainNodes.push({type:'send_voice', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP'), parse_mode: current.getFieldValue('PARSE') || ''});
                  break;
                case 'send_sticker':
                  chainNodes.push({type:'send_sticker', file_id: current.getFieldValue('FILE')});
                  break;
                case 'send_text_keyboard':
                  chainNodes.push({type:'send_text_keyboard', text: current.getFieldValue('TEXT'), keyboard: current.getFieldValue('KB'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'set_var_rand':
                  chainNodes.push({type:'set_var', mode:'random', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), random:{min:Number(current.getFieldValue('MIN')), max:Number(current.getFieldValue('MAX'))}});
                  break;
                case 'set_var_val':
                  chainNodes.push({type:'set_var', mode:'text', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), value: current.getFieldValue('VAL')});
                  break;
                case 'inc_var':
                  chainNodes.push({type:'inc_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), step: Number(current.getFieldValue('STEP')||1)});
                  break;
                case 'get_var':
                  chainNodes.push({type:'get_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), alias: current.getFieldValue('ALIAS')});
                  break;
                case 'set_local_from_input':
                  chainNodes.push({type:'set_local_from_input', alias: current.getFieldValue('ALIAS')});
                  break;
                case 'if_var':
                  const thenBranch = processChain(current.getInputTargetBlock('THEN'));
                  const elseBranch = processChain(current.getInputTargetBlock('ELSE'));
                  chainNodes.push({type:'if_var', op: current.getFieldValue('OP'), left:{var:current.getFieldValue('LHS')}, right:{text:current.getFieldValue('RHS')}, then: thenBranch, else: elseBranch});
                  break;
                case 'wait_next':
                  // This is a terminal block for this chain
                  const nextBranch = processChain(current.getNextBlock());
                  chainNodes.push({type:'wait_next', expect: (current.getFieldValue('EXPECT')==='number'?'number':'any'), prompt: current.getFieldValue('PROMPT'), next: nextBranch});
                  return chainNodes; // End the chain here
                case 'http_block':
                  chainNodes.push({type:'http', method:current.getFieldValue('METHOD'), url:current.getFieldValue('URL'), headers:current.getFieldValue('HEAD'), body:current.getFieldValue('BODY'), save_to:{scope:current.getFieldValue('SCOPE'), key:current.getFieldValue('KEY')}, json_path:current.getFieldValue('JPATH')});
                  break;
                case 'delay_seconds':
                  chainNodes.push({type:'delay', seconds: Number(current.getFieldValue('SEC')||0)});
                  break;
            }
            current = current.getNextBlock();
        }
        return chainNodes;
    };

    const nodes_list = processChain(b.getNextBlock());

    entries.push({id:`e${entries.length+1}`, type:'on_command', command:`/${cmd}`, nodes: nodes_list});
  });

  // å…³é”®ä¿®å¤ï¼šä½¿ç”¨æ–°çš„JSONåºåˆ—åŒ–APIæ¥ä¿å­˜å·¥ä½œåŒºçŠ¶æ€
  const workspaceState = Blockly.serialization.workspaces.save(workspace);
  return {version:1, entries, __workspaceState: workspaceState};
}


// ---------------- ä¿å­˜ & å‘å¸ƒ ----------------
async function saveFlow(){
  if(!botId){ alert('ç¼ºå°‘ bot_id'); return; }
  const name = prompt('æµç¨‹åç§°ï¼š', 'è‡ªå®šä¹‰æµç¨‹');
  if(!name) return;

  const compiled = toFlowJSON();
  const r = await fetch(`/api/bots/${botId}/flows`,{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    credentials:'same-origin',
    body: JSON.stringify({ id: flowId ? Number(flowId) : undefined, name, blocks_json: JSON.stringify(compiled) })
  });
  const j = await r.json();
  if(!j.ok){ alert('ä¿å­˜å¤±è´¥: ' + (j.error || 'æœªçŸ¥é”™è¯¯')); return; }

  await fetch(`/api/bots/${botId}/start`, { method:'POST', credentials:'same-origin' });
  alert('å·²ä¿å­˜å¹¶å‘å¸ƒ');
  if(window.opener && !window.opener.closed){
    try{ window.opener.loadFlows && window.opener.loadFlows(); }catch(e){}
  }
}

// ---------------- æ‰“å¼€æ—¶å›å¡« ----------------
async function loadFlowForEdit(){
  if(!botId) {
     const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
     return;
  }
  if(!flowId){
    const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
    return;
  }

  const r = await fetch(`/api/bots/${botId}/flows`, { credentials:'same-origin' });
  const j = await r.json();
  const item = (j.items||[]).find(x=>String(x.id)===String(flowId));
  if(!item){
     console.warn('æ‰¾ä¸åˆ° flow è®°å½•');
     const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
     return;
  }

  let compiled = item.blocks_compiled || safeParseBlocksJson(item.blocks_json);

  // å…³é”®ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨æ–°çš„ __workspaceState (JSON) æ¥åŠ è½½
  if(compiled && compiled.__workspaceState){
    try{
      Blockly.serialization.workspaces.load(compiled.__workspaceState, workspace);
      return;
    } catch(e){
      console.warn('JSONå·¥ä½œåŒºçŠ¶æ€è¿˜åŸå¤±è´¥ï¼Œé€€å› entries è¿‘ä¼¼è¿˜åŸï¼š', e);
    }
  }

  // åå¤‡æ–¹æ¡ˆï¼šå¦‚æœåªæœ‰æ—§çš„ entries æ•°æ®ï¼Œåˆ™å°è¯•è¿‘ä¼¼é‡å»º
  if(compiled && compiled.entries){
    rebuildFromCompiled(compiled);
    return;
  }

  // å¦‚æœå®Œå…¨æ²¡æœ‰å¯ç”¨çš„æ•°æ®ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„å…¥å£å—
  const on = workspace.newBlock('on_command'); on.initSvg(); on.render(); on.moveBy(20,20);
}

document.getElementById('saveBtn').addEventListener('click', saveFlow);
loadFlowForEdit();
</script>
</body>
</html>