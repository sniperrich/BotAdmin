<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>æ²™ç›’æ¼”ç»ƒåœº</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§ª</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body { background-color: #f8fafc; }
    .editor-pane,
    .output-pane {
      border-radius: 0.75rem;
      box-shadow: 0 10px 15px -3px rgb(15 23 42 / 0.12), 0 4px 6px -4px rgb(15 23 42 / 0.08);
      transition: all 0.3s ease-in-out;
    }
    .editor-pane {
      background: white;
    }
    .output-pane {
      background: linear-gradient(145deg, #0f172a 0%, #111c34 40%, #0b1222 100%);
      color: #e2e8f0;
    }
    .panel-tab {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background-color: #f1f5f9;
      color: #475569;
      font-weight: 500;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .panel-tab:hover {
      background-color: #e2e8f0;
      transform: translateY(-2px);
    }
    .panel-tab.active {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: #fff;
      box-shadow: 0 8px 16px rgba(99,102,241,0.3);
    }
    .mono-font {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    #blockly-editor {
        height: calc(100vh - 200px);
    }
    #pro-editor, #pseudo-editor {
        height: calc(100vh - 240px);
        border-radius: 0.5rem;
        overflow: hidden;
    }
  </style>
</head>
<body class="p-4 lg:p-6">

  <div class="grid grid-cols-1 xl:grid-cols-5 gap-6 h-full min-h-[calc(100vh-3rem)]">
    <!-- Left: Editor Pane -->
    <div class="editor-pane flex flex-col p-4 lg:p-6 xl:col-span-3">
      <div class="flex items-center justify-between mb-4">
        <h1 class="text-xl font-semibold text-gray-800" data-i18n="sandbox.title">ğŸ§ª æ²™ç›’æ¼”ç»ƒåœº</h1>
        <div class="flex items-center gap-2">
            <button id="save-item" class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm" data-i18n="sandbox.save">ä¿å­˜</button>
            <button id="clear-editor" class="px-3 py-1.5 rounded-md bg-gray-200 text-sm" data-i18n="sandbox.clear">æ¸…ç©º/æ–°å»º</button>
            <button onclick="window.close()" class="px-3 py-1.5 rounded-md bg-gray-200 text-sm" data-i18n="sandbox.close">å…³é—­</button>
        </div>
      </div>
      <div class="flex justify-end gap-2 mb-4 lang-switch">
        <button type="button" class="lang-toggle" data-lang-btn="zh">ä¸­æ–‡</button>
        <button type="button" class="lang-toggle" data-lang-btn="en">English</button>
      </div>
      
      <div class="flex items-center gap-2 mb-4 border-b pb-3">
        <div id="tabs" class="flex flex-wrap gap-2">
          <button data-tab="pseudo" class="panel-tab active" data-i18n="sandbox.tab.pseudo">ä¸­æ–‡ä¼ªä»£ç </button>
          <button data-tab="pro" class="panel-tab" data-i18n="sandbox.tab.pro">ä¸“ä¸šè„šæœ¬ (Pro)</button>
          <button data-tab="flow" class="panel-tab" data-i18n="sandbox.tab.flow">æµç¨‹ç¼–æ’ (Blockly)</button>
        </div>
      </div>

      <h2 id="editing-item-title" class="text-sm font-semibold text-gray-500 mb-2">æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®</h2>

      <!-- Editor Content -->
      <div class="flex-grow">
        <div id="panel-pseudo" class="tab-panel">
          <textarea id="pseudo-editor" class="w-full h-full border rounded-md p-3" placeholder="è¾“å…¥ä¸­æ–‡ä¼ªä»£ç ..."></textarea>
        </div>
        <div id="panel-pro" class="tab-panel hidden">
          <div id="pro-editor" class="border"></div>
        </div>
        <div id="panel-flow" class="tab-panel hidden">
          <div id="blockly-editor" class="w-full h-full bg-gray-50 rounded-md"></div>
        </div>
      </div>
    </div>

    <!-- Right: Output Pane -->
    <div class="output-pane flex flex-col p-5 space-y-5 xl:col-span-2">
        <div class="flex-shrink-0">
            <h2 class="text-lg font-medium text-slate-200 mb-3" data-i18n="sandbox.output.title">è¿è¡Œä¸è¾“å‡º</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="bot-selector" class="text-sm font-medium text-slate-400 block mb-1" data-i18n="sandbox.output.select_bot">é€‰æ‹© Bot</label>
                    <select id="bot-selector" class="w-full bg-slate-700 border-slate-600 rounded-md px-3 py-2 text-white"></select>
                </div>
                <div>
                    <label for="item-selector" class="text-sm font-medium text-slate-400 block mb-1" data-i18n="sandbox.output.select_item">é€‰æ‹©é¡¹ç›®</label>
                    <select id="item-selector" class="w-full bg-slate-700 border-slate-600 rounded-md px-3 py-2 text-white"></select>
                </div>
            </div>
            <div class="mb-4">
                <label for="sandbox-input" class="text-sm font-medium text-slate-400 block mb-1" data-i18n="sandbox.output.mock_input">æ¨¡æ‹Ÿè¾“å…¥</label>
                <input id="sandbox-input" class="w-full bg-slate-800 border-slate-600 rounded-md px-3 py-2" placeholder="ä¾‹å¦‚ /start æˆ–ä»»æ„æ–‡æœ¬">
            </div>
            <button id="run-sandbox" class="w-full px-4 py-2.5 rounded-lg bg-emerald-500 text-white font-semibold transition hover:bg-emerald-600">
                â–¶ï¸ <span data-i18n="sandbox.output.run">è¿è¡Œæ²™ç›’</span>
            </button>
        </div>
        
        <div class="flex-grow mt-4 space-y-5 overflow-y-auto">
            <div>
                <h3 class="text-base font-medium text-slate-300 mb-2" data-i18n="sandbox.output.log_title">è¾“å‡ºæ—¥å¿—</h3>
                <pre id="sandbox-output" class="mono-font text-sm p-4 bg-slate-900 rounded-lg whitespace-pre-wrap min-h-[200px]"></pre>
            </div>
            <div>
                <h3 class="text-base font-medium text-slate-300 mb-2">è°ƒè¯•ä¸è­¦å‘Š</h3>
                <pre id="sandbox-stderr" class="mono-font text-sm p-4 bg-slate-900 rounded-lg whitespace-pre-wrap text-amber-200 min-h-[140px]"></pre>
            </div>
        </div>
    </div>
  </div>

<script>
const I18N = {
  zh: {
    'sandbox.title': 'ğŸ§ª æ²™ç›’æ¼”ç»ƒåœº',
    'sandbox.save': 'ä¿å­˜',
    'sandbox.clear': 'æ¸…ç©º/æ–°å»º',
    'sandbox.close': 'å…³é—­',
    'sandbox.tab.pseudo': 'ä¸­æ–‡ä¼ªä»£ç ',
    'sandbox.tab.pro': 'ä¸“ä¸šè„šæœ¬ (Pro)',
    'sandbox.tab.flow': 'æµç¨‹ç¼–æ’ (Blockly)',
    'sandbox.output.title': 'è¿è¡Œä¸è¾“å‡º',
    'sandbox.output.select_bot': 'é€‰æ‹© Bot',
    'sandbox.output.select_item': 'é€‰æ‹©é¡¹ç›®',
    'sandbox.output.mock_input': 'æ¨¡æ‹Ÿè¾“å…¥',
    'sandbox.output.run': 'è¿è¡Œæ²™ç›’',
    'sandbox.output.log_title': 'è¾“å‡ºæ—¥å¿—',
    'sandbox.status.creating': 'æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®',
    'sandbox.status.editing': 'æ­£åœ¨ç¼–è¾‘: {{name}}',
    'sandbox.error.no_bot': 'é”™è¯¯ï¼šè¯·å…ˆé€‰æ‹©ä¸€ä¸ª Botã€‚',
    'sandbox.error.no_item_pseudo': 'é”™è¯¯ï¼šè¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¦è¿è¡Œçš„ä¼ªä»£ç é¡¹ç›®ã€‚',
    'sandbox.error.empty_pseudo': 'é”™è¯¯ï¼šä¼ªä»£ç å†…å®¹ä¸èƒ½ä¸ºç©ºã€‚',
    'sandbox.error.empty_pro': 'é”™è¯¯ï¼šä¸“ä¸šè„šæœ¬ä»£ç ä¸èƒ½ä¸ºç©ºã€‚',
    'sandbox.error.not_supported_flow': 'æ­¤åŠŸèƒ½æš‚æœªå¯¹æµç¨‹ç¼–æ’å¼€æ”¾ã€‚',
    'sandbox.prompt.pseudo_title': 'è¯·è¾“å…¥ä¼ªä»£ç æ ‡é¢˜ï¼š',
    'sandbox.prompt.pro_name': 'è¯·è¾“å…¥è„šæœ¬åç§°ï¼š',
    'sandbox.prompt.pro_command': 'è¯·è¾“å…¥è§¦å‘å‘½ä»¤ (ä¾‹å¦‚ /my_script)ï¼š',
    'sandbox.prompt.flow_name': 'è¯·è¾“å…¥æµç¨‹åç§°ï¼š',
    'sandbox.alert.save_ok': 'ä¿å­˜æˆåŠŸï¼',
    'sandbox.alert.save_fail': 'ä¿å­˜å¤±è´¥ï¼š{{error}}',
  },
};

let proEditor;
let blocklyWorkspace;
let currentTab = 'pseudo';
let botsCache = [];
let itemsCache = { pseudo: [], pro: [], flow: [] };

let monacoPromise = null;
let blocklyPromise = null;

function loadScript(src) {
    return new Promise((resolve, reject) => {
        const existing = document.querySelector(`script[data-src="${src}"]`) || document.querySelector(`script[src="${src}"]`);
        if (existing) {
            if (existing.dataset.loaded === "true") {
                resolve();
            } else {
                existing.addEventListener("load", () => resolve());
                existing.addEventListener("error", () => reject(new Error(`Script load error for ${src}`)));
            }
            return;
        }
        const script = document.createElement("script");
        script.src = src;
        script.dataset.src = src;
        script.addEventListener("load", () => {
            script.dataset.loaded = "true";
            resolve();
        });
        script.addEventListener("error", () => reject(new Error(`Script load error for ${src}`)));
        document.head.appendChild(script);
    });
}

// --- Editor Initialization ---
function initMonaco() {
    if (monacoPromise) return monacoPromise;
    monacoPromise = new Promise(async (resolve, reject) => {
        try {
            await loadScript('https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js');
            const ensureRequire = () => {
                if (typeof require === 'undefined') {
                    setTimeout(ensureRequire, 100);
                    return;
                }
                require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
                require(['vs/editor/editor.main'], () => {
                    if (!proEditor) {
                        proEditor = monaco.editor.create(document.getElementById('pro-editor'), {
                            value: "# åœ¨è¿™é‡Œè¾“å…¥ä½ çš„ Python ä¸“ä¸šè„šæœ¬...",
                            language: 'python',
                            theme: 'vs-dark',
                            automaticLayout: true,
                            minimap: { enabled: false }
                        });
                    }
                    resolve(proEditor);
                });
            };
            ensureRequire();
        } catch (error) {
            reject(error);
        }
    });
    return monacoPromise;
}

function initBlockly() {
    if (blocklyPromise) return blocklyPromise;
    blocklyPromise = new Promise(async (resolve, reject) => {
        try {
            await loadScript('https://unpkg.com/blockly/blockly.min.js');
            const ensureBlockly = () => {
                if (typeof Blockly === 'undefined') {
                    setTimeout(ensureBlockly, 100);
                    return;
                }
                if (!blocklyWorkspace) {
                    Blockly.defineBlocksWithJsonArray([
      {"type":"on_command","message0":"å½“æ”¶åˆ°å‘½ä»¤ /%1","args0":[{"type":"field_input","name":"CMD","text":"guess"}],
       "nextStatement":null, "colour":210, "tooltip":"å…¥å£å—ï¼ˆä¸€ä¸ªå‘½ä»¤ä¸€ä¸ªå…¥å£ï¼‰"},
      {"type":"send_text","message0":"å‘é€æ–‡æœ¬ %1","args0":[{"type":"field_input","name":"TEXT","text":"ä½ å¥½ï¼Œ{{user.first_name}}"}],
       "message1":"ParseMode %1  ç¦ç”¨é“¾æ¥é¢„è§ˆ %2",
       "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},{"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_photo","message0":"å‘é€å›¾ç‰‡ URL %1 è¯´æ˜ %2",
       "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_document","message0":"å‘é€æ–‡æ¡£ URL %1 è¯´æ˜ %2",
       "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_animation","message0":"å‘é€åŠ¨ç”»/GIF URL %1 è¯´æ˜ %2",
       "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_voice","message0":"å‘é€è¯­éŸ³ URL %1 è¯´æ˜ %2",
       "args0":[{"type":"field_input","name":"URL","text":"https://..."},{"type":"field_input","name":"CAP","text":""}],
       "message1":"ParseMode %1",
       "args1":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]] }],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_sticker","message0":"å‘é€è´´çº¸ file_id %1",
       "args0":[{"type":"field_input","name":"FILE","text":"CAACAgUAAxkBAAIDlmT63..."}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"send_text_keyboard","message0":"å‘é€æ–‡æœ¬+æŒ‰é’® %1",
       "args0":[{"type":"field_input","name":"TEXT","text":"è¯·é€‰æ‹©æ“ä½œ"}],
       "message1":"æŒ‰é’® JSON %1",
       "args1":[{"type":"field_input","name":"KB","text":"[[{\"text\":\"æŒ‰é’®\",\"callback_data\":\"ping\"}]]"}],
       "message2":"ParseMode %1  ç¦ç”¨é¢„è§ˆ %2",
       "args2":[{"type":"field_dropdown","name":"PARSE","options":[["None",""],["HTML","HTML"],["MarkdownV2","MarkdownV2"]]},{"type":"field_checkbox","name":"NOPREVIEW","checked":false}],
       "previousStatement":null, "nextStatement":null, "colour":160},
      {"type":"set_var_rand","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = éšæœº %3 åˆ° %4",
       "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},{"type":"field_input","name":"KEY","text":"secret"},{"type":"field_number","name":"MIN","value":1},{"type":"field_number","name":"MAX","value":100}],
       "previousStatement":null, "nextStatement":null, "colour":60},
      {"type":"set_var_val","message0":"è®¾ç½® ä½œç”¨åŸŸ %1 å˜é‡ %2 = æ–‡æœ¬ %3",
       "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},{"type":"field_input","name":"KEY","text":"name"},{"type":"field_input","name":"VAL","text":"{{user.username}}"}],
       "previousStatement":null, "nextStatement":null, "colour":60},
      {"type":"inc_var","message0":"è‡ªå¢ ä½œç”¨åŸŸ %1 å˜é‡ %2 æ­¥é•¿ %3",
       "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},{"type":"field_input","name":"KEY","text":"count"},{"type":"field_number","name":"STEP","value":1}],
       "previousStatement":null, "nextStatement":null, "colour":60},
      {"type":"get_var","message0":"è¯»å– ä½œç”¨åŸŸ %1 å˜é‡ %2 â†’ ä¸´æ—¶å %3",
       "args0":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot","bot"]]},{"type":"field_input","name":"KEY","text":"secret"},{"type":"field_input","name":"ALIAS","text":"x"}],
       "previousStatement":null, "nextStatement":null, "colour":200},
      {"type":"set_local_from_input","message0":"ä»¤ ä¸´æ—¶å˜é‡ %1 = å½“å‰æ¶ˆæ¯æ–‡æœ¬",
       "args0":[{"type":"field_input","name":"ALIAS","text":"guess"}],
       "previousStatement":null, "nextStatement":null, "colour":200},
      {"type":"if_var","message0":"å¦‚æœ ä¸´æ—¶å˜é‡ %1 %2 %3",
       "args0":[{"type":"field_input","name":"LHS","text":"x"},{"type":"field_dropdown","name":"OP","options":[["=","eq"],["â‰ ","ne"],["åŒ…å«","contains"],[">","gt"],["<","lt"]]},{"type":"field_input","name":"RHS","text":"42"}],
       "message1":"é‚£ä¹ˆ %1","args1":[{"type":"input_statement","name":"THEN"}],
       "message2":"å¦åˆ™ %1","args2":[{"type":"input_statement","name":"ELSE"}],
       "previousStatement":null, "nextStatement":null, "colour":20},
      {"type":"wait_next","message0":"ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆ%1ï¼‰ å¹¶æç¤º %2",
       "args0":[{"type":"field_dropdown","name":"EXPECT","options":[["ä»»æ„","any"],["æ•°å­—","number"]]},{"type":"field_input","name":"PROMPT","text":"è¯·è¾“å…¥â€¦"}],
       "previousStatement":null, "nextStatement":null, "colour":290},
      {"type":"delay_seconds","message0":"ç­‰å¾… %1 ç§’",
       "args0":[{"type":"field_number","name":"SEC","value":3,"min":0,"max":300,"precision":0.5}],
       "previousStatement":null, "nextStatement":null, "colour":290},
      {"type":"http_block","message0":"HTTP %1 %2",
       "args0":[{"type":"field_dropdown","name":"METHOD","options":[["GET","GET"],["POST","POST"]]},{"type":"field_input","name":"URL","text":"https://api.github.com/zen"}],
       "message1":"Headers(JSON) %1","args1":[{"type":"field_input","name":"HEAD","text":"{}"}],
       "message2":"Body(JSON) %1","args2":[{"type":"field_input","name":"BODY","text":""}],
      "message3":"ä¿å­˜åˆ° %1.%2ï¼ˆJSONè·¯å¾„å¯é€‰ %3 ï¼‰",
      "args3":[{"type":"field_dropdown","name":"SCOPE","options":[["chat","chat"],["user","user"],["bot"]]},{"type":"field_input","name":"KEY","text":"resp"},{"type":"field_input","name":"JPATH","text":""}],
      "previousStatement":null, "nextStatement":null, "colour":300}
    ]);

                    blocklyWorkspace = Blockly.inject('blockly-editor', {
      toolbox: {
        "kind": "flyoutToolbox",
        "contents": [
          { "kind":"label","text":"è§¦å‘" },
          { "kind":"block","type":"on_command" },
          { "kind":"label","text":"åŠ¨ä½œ" },
          { "kind":"block","type":"send_text" },
          { "kind":"block","type":"send_photo" },
          { "kind":"block","type":"send_document" },
          { "kind":"block","type":"send_animation" },
          { "kind":"block","type":"send_voice" },
          { "kind":"block","type":"send_sticker" },
          { "kind":"block","type":"send_text_keyboard" },
          { "kind":"label","text":"å˜é‡" },
          { "kind":"block","type":"set_var_val" },
          { "kind":"block","type":"set_var_rand" },
          { "kind":"block","type":"inc_var" },
          { "kind":"block","type":"get_var" },
          { "kind":"block","type":"set_local_from_input" },
          { "kind":"label","text":"é€»è¾‘" },
          { "kind":"block","type":"if_var" },
          { "kind":"block","type":"wait_next" },
          { "kind":"block","type":"delay_seconds" },
          { "kind":"label","text":"ç½‘ç»œ" },
          { "kind":"block","type":"http_block" }
        ]
      },
      scrollbars: true,
      trashcan: true,
    });
                } else {
                    setTimeout(() => Blockly.svgResize(blocklyWorkspace), 50);
                }
                resolve(blocklyWorkspace);
            };
            ensureBlockly();
        } catch (error) {
            reject(error);
        }
    });
    return blocklyPromise;
}

function toFlowJSON() {
  if (!blocklyWorkspace) return {};
  const blocks = blocklyWorkspace.getTopBlocks(true);
  const entries = [];
  blocks.forEach((b, bi)=>{
    if(b.type!=='on_command') return;
    const cmd = b.getFieldValue('CMD') || ('cmd'+(bi+1));
    const processChain = (startBlock) => {
        let chainNodes = [];
        let current = startBlock;
        while(current){
            switch(current.type){
                case 'send_text':
                  chainNodes.push({type:'send_text', text: current.getFieldValue('TEXT'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'send_photo':
                  chainNodes.push({type:'send_photo', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_document':
                  chainNodes.push({type:'send_document', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_animation':
                  chainNodes.push({type:'send_animation', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP')});
                  break;
                case 'send_voice':
                  chainNodes.push({type:'send_voice', url: current.getFieldValue('URL'), caption: current.getFieldValue('CAP'), parse_mode: current.getFieldValue('PARSE') || ''});
                  break;
                case 'send_sticker':
                  chainNodes.push({type:'send_sticker', file_id: current.getFieldValue('FILE')});
                  break;
                case 'send_text_keyboard':
                  chainNodes.push({type:'send_text_keyboard', text: current.getFieldValue('TEXT'), keyboard: current.getFieldValue('KB'), parse_mode: current.getFieldValue('PARSE') || '', disable_preview: (current.getFieldValue('NOPREVIEW') === 'TRUE')});
                  break;
                case 'set_var_rand':
                  chainNodes.push({type:'set_var', mode:'random', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), random:{min:Number(current.getFieldValue('MIN')), max:Number(current.getFieldValue('MAX'))}});
                  break;
                case 'set_var_val':
                  chainNodes.push({type:'set_var', mode:'text', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), value: current.getFieldValue('VAL')});
                  break;
                case 'inc_var':
                  chainNodes.push({type:'inc_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), step: Number(current.getFieldValue('STEP')||1)});
                  break;
                case 'get_var':
                  chainNodes.push({type:'get_var', scope: current.getFieldValue('SCOPE'), key: current.getFieldValue('KEY'), alias: current.getFieldValue('ALIAS')});
                  break;
                case 'set_local_from_input':
                  chainNodes.push({type:'set_local_from_input', alias: current.getFieldValue('ALIAS')});
                  break;
                case 'if_var':
                  const thenBranch = processChain(current.getInputTargetBlock('THEN'));
                  const elseBranch = processChain(current.getInputTargetBlock('ELSE'));
                  chainNodes.push({type:'if_var', op: current.getFieldValue('OP'), left:{var:current.getFieldValue('LHS')}, right:{text:current.getFieldValue('RHS')}, then: thenBranch, else: elseBranch});
                  break;
                case 'wait_next':
                  const nextBranch = processChain(current.getNextBlock());
                  chainNodes.push({type:'wait_next', expect: (current.getFieldValue('EXPECT')==='number'?'number':'any'), prompt: current.getFieldValue('PROMPT'), next: nextBranch});
                  return chainNodes;
                case 'http_block':
                  chainNodes.push({type:'http', method:current.getFieldValue('METHOD'), url:current.getFieldValue('URL'), headers:current.getFieldValue('HEAD'), body:current.getFieldValue('BODY'), save_to:{scope:current.getFieldValue('SCOPE'), key:current.getFieldValue('KEY')}, json_path:current.getFieldValue('JPATH')});
                  break;
                case 'delay_seconds':
                  chainNodes.push({type:'delay', seconds: Number(current.getFieldValue('SEC')||0)});
                  break;
            }
            current = current.getNextBlock();
        }
        return chainNodes;
    };
    const nodes_list = processChain(b.getNextBlock());
    entries.push({id:`e${entries.length+1}`, type:'on_command', command:`/${cmd}`, nodes: nodes_list});
  });
  const workspaceState = Blockly.serialization.workspaces.save(blocklyWorkspace);
  return {version:1, entries, __workspaceState: workspaceState};
}

// --- UI & Tab Logic ---
async function switchTab(tabName) {
    currentTab = tabName;
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
    document.getElementById(`panel-${tabName}`).classList.remove('hidden');

    document.querySelectorAll('[data-tab]').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tabName);
    });

    if (tabName === 'pro' && !proEditor) initMonaco();
    if (tabName === 'flow' && !blocklyWorkspace) initBlockly();
    
    await loadItemsForCurrentBot();
}

// --- Data Fetching ---
async function loadBots() {
    try {
        const response = await fetch('/api/bots', { credentials: 'same-origin' });
        const data = await response.json();
        if (!data.items) throw new Error('Failed to load bots');
        botsCache = data.items;
        const selector = document.getElementById('bot-selector');
        selector.innerHTML = botsCache.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
        if (botsCache.length > 0) {
            selector.dispatchEvent(new Event('change'));
        }
    } catch (e) {
        console.error("Error loading bots:", e);
        document.getElementById('sandbox-output').textContent = `é”™è¯¯ï¼šæ— æ³•åŠ è½½ Bot åˆ—è¡¨ã€‚è¯·ç¡®ä¿æ‚¨å·²ç™»å½•ã€‚`;
    }
}

async function loadItemsForCurrentBot() {
    const botId = document.getElementById('bot-selector').value;
    if (!botId) return;

    const endpoints = {
        pseudo: `/api/bots/${botId}/pseudocode`,
        pro: `/api/bots/${botId}/pro_scripts`,
        flow: `/api/bots/${botId}/flows`
    };

    try {
        const response = await fetch(endpoints[currentTab], { credentials: 'same-origin' });
        const data = await response.json();
        itemsCache[currentTab] = data.items || [];
        
        populateItemSelector();

    } catch (e) {
        console.error(`Error loading ${currentTab} items:`, e);
    }
}

function loadContentForItem() {
    const itemId = document.getElementById('item-selector').value;
    const items = itemsCache[currentTab];
    const item = items.find(i => String(i.id) === String(itemId));
    const titleEl = document.getElementById('editing-item-title');

    if (!item) {
        titleEl.textContent = 'æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®';
        clearEditor(false); // false to prevent recursion
        return;
    }

    titleEl.textContent = `æ­£åœ¨ç¼–è¾‘: ${item.title || item.name}`;

    if (currentTab === 'pseudo') {
        document.getElementById('pseudo-editor').value = item.content || '';
    } else if (currentTab === 'pro') {
        if (proEditor) proEditor.setValue(item.code || '');
    } else if (currentTab === 'flow') {
        if (blocklyWorkspace) {
            blocklyWorkspace.clear();
            try {
                const flowJson = JSON.parse(item.blocks_json);
                if (flowJson && flowJson.__workspaceState) {
                    Blockly.serialization.workspaces.load(flowJson.__workspaceState, blocklyWorkspace);
                }
            } catch (e) {
                console.error("Failed to load blockly workspace:", e);
            }
        }
    }
}

function populateItemSelector() {
    const selector = document.getElementById('item-selector');
    const items = itemsCache[currentTab] || [];
    let options = '<option value="">-- æ–°å»º --</option>';
    if (items.length > 0) {
        options += items.map(item => `<option value="${item.id}">${item.title || item.name}</option>`).join('');
    }
    selector.innerHTML = options;
    loadContentForItem();
}

function clearEditor(resetSelector = true) {
    if(resetSelector) document.getElementById('item-selector').value = '';
    document.getElementById('editing-item-title').textContent = 'æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®';

    if (currentTab === 'pseudo') {
        document.getElementById('pseudo-editor').value = '';
    } else if (currentTab === 'pro' && proEditor) {
        proEditor.setValue('# åœ¨è¿™é‡Œè¾“å…¥ä½ çš„ Python ä¸“ä¸šè„šæœ¬...');
    } else if (currentTab === 'flow' && blocklyWorkspace) {
        blocklyWorkspace.clear();
    }
}

async function saveItem() {
    const botId = document.getElementById('bot-selector').value;
    if (!botId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª Botã€‚');
        return;
    }

    const itemId = document.getElementById('item-selector').value || undefined;
    const items = itemsCache[currentTab];
    const currentItem = itemId ? items.find(i => String(i.id) === String(itemId)) : null;

    let content, endpoint;
    let payload = { id: itemId ? Number(itemId) : undefined };

    if (currentTab === 'pseudo') {
        content = document.getElementById('pseudo-editor').value;
        const currentTitle = currentItem ? currentItem.title : 'æ–°çš„ä¼ªä»£ç ';
        const title = prompt("è¯·è¾“å…¥ä¼ªä»£ç æ ‡é¢˜ï¼š", currentTitle);
        if (!title) return;
        payload.title = title;
        payload.content = content;
        endpoint = `/api/bots/${botId}/pseudocode`;
    } else if (currentTab === 'pro') {
        content = proEditor.getValue();
        const currentName = currentItem ? currentItem.name : 'æ–°çš„ä¸“ä¸šè„šæœ¬';
        const name = prompt("è¯·è¾“å…¥è„šæœ¬åç§°ï¼š", currentName);
        if (!name) return;
        const currentCommand = currentItem ? currentItem.command : ''
        const command = prompt("è¯·è¾“å…¥è§¦å‘å‘½ä»¤ (ä¾‹å¦‚ /my_script)ï¼š", currentCommand);
        payload.name = name;
        payload.command = command;
        payload.code = content;
        endpoint = `/api/bots/${botId}/pro_scripts`;
    } else if (currentTab === 'flow') {
        const currentName = currentItem ? currentItem.name : 'æ–°çš„æµç¨‹';
        const name = prompt("è¯·è¾“å…¥æµç¨‹åç§°ï¼š", currentName);
        if (!name) return;
        payload.name = name;
        payload.blocks_json = JSON.stringify(toFlowJSON());
        endpoint = `/api/bots/${botId}/flows`;
    } else {
        return;
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'credentials': 'same-origin' },
            body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.ok) {
            alert('ä¿å­˜æˆåŠŸï¼');
            await loadItemsForCurrentBot();
            if(result.id) {
                document.getElementById('item-selector').value = result.id;
            }
        } else {
            alert(`ä¿å­˜å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
        }
    } catch (e) {
        alert(`ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`);
    }
}

// --- Sandbox Execution ---
async function runSandbox() {
    const botId = document.getElementById('bot-selector').value;
    const input = document.getElementById('sandbox-input').value;
    const outputEl = document.getElementById('sandbox-output');
    const stderrEl = document.getElementById('sandbox-stderr');

    if (!botId) {
        outputEl.textContent = 'é”™è¯¯ï¼šè¯·å…ˆé€‰æ‹©ä¸€ä¸ª Botã€‚';
        if (stderrEl) stderrEl.textContent = '';
        return;
    }

    outputEl.textContent = 'æ­£åœ¨æ‰§è¡Œ...';
    if (stderrEl) stderrEl.textContent = '';

    if (currentTab === 'pro') {
        const code = proEditor.getValue();
        if (!code.trim()) {
            outputEl.textContent = 'é”™è¯¯ï¼šä¸“ä¸šè„šæœ¬ä»£ç ä¸èƒ½ä¸ºç©ºã€‚';
            if (stderrEl) stderrEl.textContent = '';
            return;
        }
        try {
            const response = await fetch(`/api/sandbox/execute`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'credentials': 'same-origin' },
                body: JSON.stringify({ code: code })
            });
            const result = await response.json();
            let output = `âœ… æ‰§è¡Œå®Œæˆ\n\n`;
            if (result.stdout) {
                output += `â–¶ï¸ æ ‡å‡†è¾“å‡º (stdout):\n${result.stdout}\n\n`;
            }
            if (stderrEl) {
                stderrEl.textContent = result.stderr || '';
            } else if (result.stderr) {
                output += `â–¶ï¸ æ ‡å‡†é”™è¯¯ (stderr):\n${result.stderr}\n\n`;
            }
            if (result.error) {
                output += `â–¶ï¸ æ²™ç›’é”™è¯¯:\n${result.error}`;
                if (stderrEl) {
                    stderrEl.textContent = `${stderrEl.textContent || ''}\n${result.error}`.trim();
                }
            }
            outputEl.textContent = output;
        } catch (e) {
            outputEl.textContent = `ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`;
            if (stderrEl) stderrEl.textContent = `ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`;
            console.error("Sandbox execution error:", e);
        }

    } else if (currentTab === 'pseudo') {
        const content = document.getElementById('pseudo-editor').value;
        if (!content.trim()) {
            outputEl.textContent = 'é”™è¯¯ï¼šä¼ªä»£ç å†…å®¹ä¸èƒ½ä¸ºç©ºã€‚';
            if (stderrEl) stderrEl.textContent = '';
            return;
        }
        try {
            const response = await fetch(`/api/sandbox/pseudo/execute`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'credentials': 'same-origin' },
                body: JSON.stringify({ content: content, input: input })
            });
            const result = await response.json();
            
            if (!result.ok) {
                outputEl.textContent = `æ‰§è¡Œå¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`;
                if (stderrEl) stderrEl.textContent = result.error || 'æœªçŸ¥é”™è¯¯';
                return;
            }

            let output = `âœ… æ‰§è¡ŒæˆåŠŸ\n\n`;
            output += `â–¶ï¸ åˆ†æ:\n${result.analysis || 'æ— '}\n\n`;
            output += `â–¶ï¸ æ¨¡æ‹Ÿè¾“å…¥:\n${input}\n\n`;
            output += `â–¶ï¸ æ¨¡æ‹ŸåŠ¨ä½œ:\n`;
            if (result.actions && result.actions.length > 0) {
                output += result.actions.map(a => `  - ${a.type}: ${a.text || ''}`).join('\n');
            } else {
                output += "  (æ— åŠ¨ä½œ)";
            }
            output += `\n\nâ–¶ï¸ æ‘˜è¦:\n${result.summary || 'æ— '}`;
            if (stderrEl) stderrEl.textContent = '';
            
            outputEl.textContent = output;

        } catch (e) {
            outputEl.textContent = `ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`;
            if (stderrEl) stderrEl.textContent = `ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`;
            console.error("Sandbox execution error:", e);
        }
    } else {
        outputEl.textContent = 'æ­¤åŠŸèƒ½æš‚æœªå¯¹æµç¨‹ç¼–æ’å¼€æ”¾ã€‚';
        if (stderrEl) stderrEl.textContent = 'æ­¤åŠŸèƒ½æš‚æœªå¯¹æµç¨‹ç¼–æ’å¼€æ”¾ã€‚';
    }
}


// --- Event Listeners ---
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('[data-tab]').forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    document.getElementById('bot-selector').addEventListener('change', loadItemsForCurrentBot);
    document.getElementById('item-selector').addEventListener('change', loadContentForItem);
    document.getElementById('run-sandbox').addEventListener('click', runSandbox);
    document.getElementById('save-item').addEventListener('click', saveItem);
    document.getElementById('clear-editor').addEventListener('click', clearEditor);
    
    loadBots();
});
</script>
</script>
</body>
</html>
