<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>æ²™ç›’æ¼”ç»ƒåœº</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§ª</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body { background-color: #f8fafc; }
    .editor-pane,
    .output-pane {
      border-radius: 0.75rem;
      box-shadow: 0 10px 15px -3px rgb(15 23 42 / 0.12), 0 4px 6px -4px rgb(15 23 42 / 0.08);
      transition: all 0.3s ease-in-out;
    }
    .editor-pane {
      background: white;
    }
    .output-pane {
      background: linear-gradient(145deg, #0f172a 0%, #111c34 40%, #0b1222 100%);
      color: #e2e8f0;
    }
    .panel-tab {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background-color: #f1f5f9;
      color: #475569;
      font-weight: 500;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .panel-tab:hover {
      background-color: #e2e8f0;
      transform: translateY(-2px);
    }
    .panel-tab.active {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: #fff;
      box-shadow: 0 8px 16px rgba(99,102,241,0.3);
    }
    .mono-font {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    #blockly-editor {
        height: calc(100vh - 200px);
    }
    #pro-editor, #pseudo-editor {
        height: calc(100vh - 240px);
        border-radius: 0.5rem;
        overflow: hidden;
    }
  </style>
</head>
<body class="p-4 lg:p-6">

  <div class="grid grid-cols-1 xl:grid-cols-5 gap-6 h-full min-h-[calc(100vh-3rem)]">
    <!-- Left: Editor Pane -->
    <div class="editor-pane flex flex-col p-4 lg:p-6 xl:col-span-3">
      <div class="flex items-center justify-between mb-4">
        <h1 class="text-xl font-semibold text-gray-800">ğŸ§ª æ²™ç›’æ¼”ç»ƒåœº</h1>
        <div class="flex items-center gap-2">
            <button id="save-item" class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm">ä¿å­˜</button>
            <button id="clear-editor" class="px-3 py-1.5 rounded-md bg-gray-200 text-sm">æ¸…ç©º/æ–°å»º</button>
            <button onclick="window.close()" class="px-3 py-1.5 rounded-md bg-gray-200 text-sm">å…³é—­</button>
        </div>
      </div>
      
      <div class="flex items-center gap-2 mb-4 border-b pb-3">
        <div id="tabs" class="flex flex-wrap gap-2">
          <button data-tab="pseudo" class="panel-tab active">ä¸­æ–‡ä¼ªä»£ç </button>
          <button data-tab="pro" class="panel-tab">ä¸“ä¸šè„šæœ¬ (Pro)</button>
          <button data-tab="flow" class="panel-tab">æµç¨‹ç¼–æ’ (Blockly)</button>
        </div>
      </div>

      <h2 id="editing-item-title" class="text-sm font-semibold text-gray-500 mb-2">æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®</h2>

      <!-- Editor Content -->
      <div class="flex-grow">
        <div id="panel-pseudo" class="tab-panel">
          <textarea id="pseudo-editor" class="w-full h-full border rounded-md p-3" placeholder="è¾“å…¥ä¸­æ–‡ä¼ªä»£ç ..."></textarea>
        </div>
        <div id="panel-pro" class="tab-panel hidden">
          <div id="pro-editor" class="border"></div>
        </div>
        <div id="panel-flow" class="tab-panel hidden">
          <div id="blockly-editor" class="w-full h-full bg-gray-50 rounded-md"></div>
        </div>
      </div>
    </div>

    <!-- Right: Output Pane -->
    <div class="output-pane flex flex-col p-5 space-y-5 xl:col-span-2">
        <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="space-y-2">
                <h2 class="text-lg font-semibold text-slate-100">è¿è¡Œä¸è¾“å‡º</h2>
                <div class="flex flex-wrap items-center gap-3 text-xs text-slate-400">
                    <span id="sandbox-status" class="inline-flex items-center gap-1 rounded-full px-3 py-1 bg-slate-700 text-slate-100">
                        <span class="w-1.5 h-1.5 rounded-full bg-slate-300"></span>
                        å¾…æ‰§è¡Œ
                    </span>
                    <span id="sandbox-duration">è€—æ—¶ --</span>
                    <span id="sandbox-timestamp">ä¸Šæ¬¡è¿è¡Œ --</span>
                </div>
            </div>
            <div class="hidden md:flex flex-col items-end text-xs text-slate-400 gap-2">
                <span class="inline-flex items-center gap-2">
                    <span class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse"></span>
                    è¿æ¥å°±ç»ª
                </span>
                <span id="sandbox-summary" class="text-slate-200 font-medium">ç­‰å¾…æ‰§è¡Œ...</span>
            </div>
        </div>

        <div class="grid grid-cols-1 xl:grid-cols-4 gap-5">
            <div class="xl:col-span-3 bg-slate-900/50 border border-slate-800/60 rounded-2xl p-5 space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="bot-selector" class="text-sm font-medium text-slate-400 block mb-1">é€‰æ‹© Bot</label>
                        <select id="bot-selector" class="w-full bg-slate-800/70 border border-slate-700 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-400/60 transition"></select>
                    </div>
                    <div>
                        <label for="item-selector" class="text-sm font-medium text-slate-400 block mb-1">é€‰æ‹©é¡¹ç›®</label>
                        <select id="item-selector" class="w-full bg-slate-800/70 border border-slate-700 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-400/60 transition"></select>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-6 gap-4 items-end">
                    <div class="md:col-span-4">
                        <label for="sandbox-input" class="text-sm font-medium text-slate-400 block mb-1">æ¨¡æ‹Ÿè¾“å…¥</label>
                        <input id="sandbox-input" class="w-full bg-slate-900 border border-slate-700 rounded-lg px-3 py-2 text-slate-100 focus:outline-none focus:ring-2 focus:ring-emerald-400/60 transition" placeholder="ä¾‹å¦‚ /start æˆ–ä»»æ„æ–‡æœ¬">
                    </div>
                    <div class="md:col-span-2 flex items-center md:justify-end">
                        <button id="run-sandbox" class="w-full md:w-auto px-5 py-2.5 rounded-xl bg-emerald-500 text-white font-semibold shadow-lg shadow-emerald-500/30 transition hover:-translate-y-0.5 hover:bg-emerald-400">
                            â–¶ï¸ è¿è¡Œæ²™ç›’
                        </button>
                    </div>
                </div>
                <div class="flex flex-wrap gap-3 text-xs text-slate-400">
                    <span>æ¨¡å¼ï¼š<span id="sandbox-mode-label" class="text-slate-100 font-medium">ä¸­æ–‡ä¼ªä»£ç </span></span>
                    <span>å½“å‰ Botï¼š<span id="sandbox-active-bot" class="text-slate-100 font-medium">æœªé€‰æ‹©</span></span>
                    <span>è¶…æ—¶ï¼š<span class="text-slate-100 font-medium">5s</span></span>
                </div>
            </div>
            <div class="bg-slate-900/50 border border-slate-800/60 rounded-2xl p-5 space-y-4 xl:col-span-1">
                <h3 class="text-sm font-semibold text-slate-100 uppercase tracking-wide">è¿è¡Œæç¤º</h3>
                <ul class="text-xs text-slate-400 space-y-2 leading-relaxed">
                    <li>â€¢ è¾“å…¥æ¡†æ”¯æŒå®Œæ•´æŒ‡ä»¤ï¼Œä¾‹ï¼š<code class="bg-slate-800/70 px-1.5 py-0.5 rounded text-slate-200">/crypto bitcoin</code></li>
                    <li>â€¢ è¿è¡Œå‰è¯·ç¡®ä¿å·¦ä¾§å†…å®¹å·²ä¿å­˜å¹¶é€‰æ‹©å¯¹åº”é¡¹ç›®ã€‚</li>
                    <li>â€¢ æ¯æ¬¡è¿è¡Œä¼šè®°å½•è€—æ—¶ä¸æ—¶é—´æˆ³ï¼Œæ–¹ä¾¿å›æº¯ã€‚</li>
                </ul>
                <div class="rounded-xl border border-slate-700/60 bg-slate-900/70 p-3 text-xs text-slate-300 space-y-1">
                    <div class="flex items-center justify-between">
                        <span>çŠ¶æ€</span>
                        <span id="sandbox-mini-status" class="text-emerald-300">å¾…æ‰§è¡Œ</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>è¾“å…¥æ‘˜è¦</span>
                        <span id="sandbox-input-preview" class="text-slate-200 truncate max-w-[8rem]">ï¼ˆç©ºï¼‰</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>è¾“å‡ºè¡Œæ•°</span>
                        <span id="sandbox-line-count" class="text-slate-200">0</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-5 flex-grow">
            <div class="bg-slate-900/60 border border-slate-800/70 rounded-2xl p-5 flex flex-col">
                <h3 class="text-sm font-semibold text-slate-100 mb-3 uppercase tracking-wide">æ ‡å‡†è¾“å‡º</h3>
                <pre id="sandbox-output" class="mono-font text-sm flex-1 bg-slate-950/70 rounded-xl p-4 whitespace-pre-wrap overflow-y-auto"></pre>
            </div>
            <div class="bg-slate-900/60 border border-slate-800/70 rounded-2xl p-5 flex flex-col">
                <h3 class="text-sm font-semibold text-slate-100 mb-3 uppercase tracking-wide">è°ƒè¯•ä¸è­¦å‘Š</h3>
                <pre id="sandbox-stderr" class="mono-font text-sm flex-1 bg-slate-950/70 rounded-xl p-4 whitespace-pre-wrap overflow-y-auto text-rose-200"></pre>
            </div>
        </div>
    </div>
  </div>

<script>
let proEditor;
let blocklyWorkspace;
let currentTab = 'pseudo';
let botsCache = [];
let itemsCache = { pseudo: [], pro: [], flow: [] };

let monacoPromise = null;
let blocklyPromise = null;

const STATUS_BASE =
    "inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-medium shadow-sm transition";
const STATUS_STYLE = {
    idle: "bg-slate-700 text-slate-100",
    running: "bg-amber-400/90 text-amber-950",
    success: "bg-emerald-400/90 text-emerald-950",
    error: "bg-rose-500 text-rose-50",
};
const STATUS_DOT = {
    idle: "bg-slate-200",
    running: "bg-amber-200",
    success: "bg-emerald-200",
    error: "bg-rose-200",
};
const MODE_LABEL_MAP = {
    pseudo: "ä¸­æ–‡ä¼ªä»£ç ",
    pro: "ä¸“ä¸šè„šæœ¬",
    flow: "æµç¨‹ç¼–æ’",
};

function setSandboxStatus(state = "idle", label = "å¾…æ‰§è¡Œ") {
    const badge = document.getElementById("sandbox-status");
    const mini = document.getElementById("sandbox-mini-status");
    const cls = `${STATUS_BASE} ${STATUS_STYLE[state] || STATUS_STYLE.idle}`;
    const dot = STATUS_DOT[state] || STATUS_DOT.idle;
    if (badge) {
        badge.className = cls;
        badge.innerHTML = `<span class="w-1.5 h-1.5 rounded-full ${dot}"></span>${label}`;
    }
    if (mini) {
        mini.textContent = label;
        mini.className =
            state === "success"
                ? "text-emerald-300"
                : state === "running"
                ? "text-amber-300"
                : state === "error"
                ? "text-rose-300"
                : "text-slate-300";
    }
}

function setSandboxMeta({ duration, timestamp, summary, input, lines }) {
    const durationEl = document.getElementById("sandbox-duration");
    const timestampEl = document.getElementById("sandbox-timestamp");
    const summaryEl = document.getElementById("sandbox-summary");
    const inputPreviewEl = document.getElementById("sandbox-input-preview");
    const lineCountEl = document.getElementById("sandbox-line-count");
    if (durationEl && duration) durationEl.textContent = `è€—æ—¶ ${duration}`;
    if (timestampEl && timestamp) timestampEl.textContent = `ä¸Šæ¬¡è¿è¡Œ ${timestamp}`;
    if (summaryEl && summary) summaryEl.textContent = summary;
    if (inputPreviewEl && input !== undefined)
        inputPreviewEl.textContent = input || "ï¼ˆç©ºï¼‰";
    if (lineCountEl && typeof lines === "number") lineCountEl.textContent = lines;
}

function countOutputLines(text) {
    if (!text) return 0;
    return text
        .split(/\r?\n/)
        .map((line) => line.trim())
        .filter(Boolean).length;
}

function updateActiveBotLabel() {
    const selector = document.getElementById("bot-selector");
    const activeEl = document.getElementById("sandbox-active-bot");
    if (!selector || !activeEl) return;
    const selected = selector.options[selector.selectedIndex];
    activeEl.textContent = selected ? selected.textContent : "æœªé€‰æ‹©";
}

function loadScript(src) {
    return new Promise((resolve, reject) => {
        const existingScript = document.querySelector(`script[src="${src}"]`);
        if (existingScript) {
            // If script is already loading/loaded, wait for it to complete
            if (existingScript.dataset.loaded) {
                resolve();
            } else {
                existingScript.addEventListener('load', () => resolve());
                existingScript.addEventListener('error', () => reject(new Error(`Script load error for ${src}`)));
            }
            return;
        }
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => {
            script.dataset.loaded = true;
            resolve();
        };
        script.onerror = () => reject(new Error(`Script load error for ${src}`));
        document.head.appendChild(script);
    });
}

// --- Editor Initialization with Promises ---
function initMonaco() {
    if (monacoPromise) return monacoPromise;
    monacoPromise = new Promise(async (resolve, reject) => {
        try {
            await loadScript('https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js');
            if (typeof require === 'undefined') {
                // Retry if loader is not immediately available
                setTimeout(() => resolve(initMonaco()), 100);
                return;
            }
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
            require(['vs/editor/editor.main'], () => {
                const editor = monaco.editor.create(document.getElementById('pro-editor'), {
                    value: "# åœ¨è¿™é‡Œè¾“å…¥ä½ çš„ Python ä¸“ä¸šè„šæœ¬...",
                    language: 'python',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: false }
                });
                resolve(editor);
            });
        } catch (error) {
            reject(error);
        }
    });
    return monacoPromise;
}

function initBlockly() {
    if (blocklyPromise) return blocklyPromise;
    blocklyPromise = new Promise(async (resolve, reject) => {
        try {
            await loadScript('https://unpkg.com/blockly/blockly.min.js');
            if (typeof Blockly === 'undefined') {
                 setTimeout(() => resolve(initBlockly()), 100);
                 return;
            }
            Blockly.defineBlocksWithJsonArray([
                {"type":"on_command","message0":"å½“æ”¶åˆ°å‘½ä»¤ /%1","args0":[{"type":"field_input","name":"CMD","text":"guess"}], "nextStatement":null, "colour":210},
                {"type":"send_text","message0":"å‘é€æ–‡æœ¬ %1","args0":[{"type":"field_input","name":"TEXT","text":"ä½ å¥½"}], "previousStatement":null, "nextStatement":null, "colour":160},
                // Add all other block definitions here...
            ]);
            const workspace = Blockly.inject('blockly-editor', {
                toolbox: {
                    "kind": "flyoutToolbox",
                    "contents": [
                        { "kind":"label","text":"è§¦å‘" },
                        { "kind":"block","type":"on_command" },
                        { "kind":"label","text":"åŠ¨ä½œ" },
                        { "kind":"block","type":"send_text" }
                    ]
                },
                scrollbars: true,
                trashcan: true,
            });
            resolve(workspace);
        } catch (error) {
            reject(error);
        }
    });
    return blocklyPromise;
}

function toFlowJSON() {
  if (!blocklyWorkspace) return {};
  const workspaceState = Blockly.serialization.workspaces.save(blocklyWorkspace);
  // This is a simplified serialization. A full one would parse the blocks into the custom JSON structure.
  return { __workspaceState: workspaceState };
}

// --- UI & Tab Logic ---
async function switchTab(tabName) {
    currentTab = tabName;
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
    document.getElementById(`panel-${tabName}`).classList.remove('hidden');

    document.querySelectorAll('[data-tab]').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tabName);
    });
    const modeLabelEl = document.getElementById('sandbox-mode-label');
    if (modeLabelEl) {
        modeLabelEl.textContent = MODE_LABEL_MAP[tabName] || tabName;
    }
    setSandboxStatus('idle', 'å¾…æ‰§è¡Œ');
    setSandboxMeta({
        summary: `ç­‰å¾…æ‰§è¡Œ Â· ${MODE_LABEL_MAP[tabName] || tabName}`,
        input: document.getElementById('sandbox-input')?.value || '',
        lines: 0,
    });

    try {
        if (tabName === 'pro') {
            proEditor = await initMonaco();
            proEditor.layout();
        }
        if (tabName === 'flow') {
            blocklyWorkspace = await initBlockly();
            // Blockly might need a resize event after the container becomes visible
            setTimeout(() => Blockly.svgResize(blocklyWorkspace), 50);
        }
    } catch (error) {
        console.error("Editor initialization failed:", error);
        document.getElementById('sandbox-output').textContent = `é”™è¯¯ï¼šæ— æ³•åŠ è½½ç¼–è¾‘å™¨ã€‚\n${error.message}`;
        return;
    }
    
    await loadItemsForCurrentBot();
}

// --- Data Fetching & Content Loading ---
async function loadBots() {
    try {
        const response = await fetch('/api/bots', { credentials: 'same-origin' });
        const data = await response.json();
        if (!data.items) throw new Error('Failed to load bots');
        botsCache = data.items;
        const selector = document.getElementById('bot-selector');
        selector.innerHTML = botsCache.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
        if (botsCache.length > 0) {
            selector.dispatchEvent(new Event('change'));
        } else {
            updateActiveBotLabel();
        }
        updateActiveBotLabel();
    } catch (e) {
        console.error("Error loading bots:", e);
        document.getElementById('sandbox-output').textContent = `é”™è¯¯ï¼šæ— æ³•åŠ è½½ Bot åˆ—è¡¨ã€‚è¯·ç¡®ä¿æ‚¨å·²ç™»å½•ã€‚`;
    }
}

async function loadItemsForCurrentBot() {
    const botId = document.getElementById('bot-selector').value;
    if (!botId) return;

    const endpoints = {
        pseudo: `/api/bots/${botId}/pseudocode`,
        pro: `/api/bots/${botId}/pro_scripts`,
        flow: `/api/bots/${botId}/flows`
    };

    try {
        const response = await fetch(endpoints[currentTab], { credentials: 'same-origin' });
        const data = await response.json();
        itemsCache[currentTab] = data.items || [];
        populateItemSelector();
    } catch (e) {
        console.error(`Error loading ${currentTab} items:`, e);
    }
}

function populateItemSelector() {
    const selector = document.getElementById('item-selector');
    const items = itemsCache[currentTab] || [];
    let options = '<option value="">-- æ–°å»º --</option>';
    if (items.length > 0) {
        options += items.map(item => `<option value="${item.id}">${item.title || item.name}</option>`).join('');
    }
    selector.innerHTML = options;
    // Clear the editor to reflect the new state (nothing selected yet)
    clearEditor(false);
}

async function loadContentForItem() {
    const itemId = document.getElementById('item-selector').value;
    const items = itemsCache[currentTab];
    const item = items.find(i => String(i.id) === String(itemId));
    const titleEl = document.getElementById('editing-item-title');

    if (!item) {
        titleEl.textContent = 'æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®';
        clearEditor(false);
        return;
    }

    titleEl.textContent = `æ­£åœ¨ç¼–è¾‘: ${item.title || item.name}`;

    if (currentTab === 'pseudo') {
        document.getElementById('pseudo-editor').value = item.content || '';
    } else if (currentTab === 'pro') {
        if (!proEditor) proEditor = await initMonaco();
        proEditor.setValue(item.code || '');
    } else if (currentTab === 'flow') {
        if (!blocklyWorkspace) blocklyWorkspace = await initBlockly();
        blocklyWorkspace.clear();
        try {
            // The full block definition is needed here for proper deserialization
            const flowJson = JSON.parse(item.blocks_json);
            if (flowJson && flowJson.__workspaceState) {
                Blockly.serialization.workspaces.load(flowJson.__workspaceState, blocklyWorkspace);
            }
        } catch (e) {
            console.error("Failed to load blockly workspace:", e);
        }
    }
}

function clearEditor(resetSelector = true) {
    if(resetSelector) document.getElementById('item-selector').value = '';
    document.getElementById('editing-item-title').textContent = 'æ­£åœ¨åˆ›å»ºæ–°é¡¹ç›®';

    if (currentTab === 'pseudo') {
        document.getElementById('pseudo-editor').value = '';
    } else if (currentTab === 'pro' && proEditor) {
        proEditor.setValue('# åœ¨è¿™é‡Œè¾“å…¥ä½ çš„ Python ä¸“ä¸šè„šæœ¬...');
    } else if (currentTab === 'flow' && blocklyWorkspace) {
        blocklyWorkspace.clear();
    }
}

// --- Save & Run Logic ---
async function saveItem() {
    const botId = document.getElementById('bot-selector').value;
    if (!botId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª Botã€‚');
        return;
    }

    const itemId = document.getElementById('item-selector').value || undefined;
    const items = itemsCache[currentTab];
    const currentItem = itemId ? items.find(i => String(i.id) === String(itemId)) : null;

    let endpoint;
    let payload = { id: itemId ? Number(itemId) : undefined };

    if (currentTab === 'pseudo') {
        payload.content = document.getElementById('pseudo-editor').value;
        const currentTitle = currentItem ? currentItem.title : 'æ–°çš„ä¼ªä»£ç ';
        payload.title = prompt("è¯·è¾“å…¥ä¼ªä»£ç æ ‡é¢˜ï¼š", currentTitle);
        if (!payload.title) return;
        endpoint = `/api/bots/${botId}/pseudocode`;
    } else if (currentTab === 'pro') {
        payload.code = proEditor.getValue();
        const currentName = currentItem ? currentItem.name : 'æ–°çš„ä¸“ä¸šè„šæœ¬';
        payload.name = prompt("è¯·è¾“å…¥è„šæœ¬åç§°ï¼š", currentName);
        if (!payload.name) return;
        const currentCommand = currentItem ? currentItem.command : '';
        payload.command = prompt("è¯·è¾“å…¥è§¦å‘å‘½ä»¤ (ä¾‹å¦‚ /my_script)ï¼š", currentCommand);
        endpoint = `/api/bots/${botId}/pro_scripts`;
    } else if (currentTab === 'flow') {
        const currentName = currentItem ? currentItem.name : 'æ–°çš„æµç¨‹';
        payload.name = prompt("è¯·è¾“å…¥æµç¨‹åç§°ï¼š", currentName);
        if (!payload.name) return;
        payload.blocks_json = JSON.stringify(toFlowJSON());
        endpoint = `/api/bots/${botId}/flows`;
    } else {
        return;
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'credentials': 'same-origin' },
            body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.ok) {
            alert('ä¿å­˜æˆåŠŸï¼');
            await loadItemsForCurrentBot();
            if(result.id) {
                // Wait for DOM to update
                setTimeout(() => {
                    document.getElementById('item-selector').value = result.id;
                }, 100);
            }
        } else {
            alert(`ä¿å­˜å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
        }
    } catch (e) {
        alert(`ç½‘ç»œæˆ–æœåŠ¡å™¨é”™è¯¯: ${e.message}`);
    }
}

async function runSandbox() {
    const botId = document.getElementById('bot-selector').value;
    const input = document.getElementById('sandbox-input').value;
    const stdoutEl = document.getElementById('sandbox-output');
    const stderrEl = document.getElementById('sandbox-stderr');
    const modeLabel = document.getElementById('sandbox-mode-label');
    const startedAt = performance.now();
    const modeText = modeLabel ? modeLabel.textContent : '';

    stdoutEl.textContent = '';
    stderrEl.textContent = '';
    setSandboxStatus('running', 'æ‰§è¡Œä¸­');
    setSandboxMeta({
        duration: '--',
        timestamp: null,
        summary: `æ‰§è¡Œä¸­ Â· ${modeText || 'æ²™ç›’'}`,
        input,
        lines: 0,
    });

    const friendlyInput = input || 'ï¼ˆç©ºï¼‰';

    if (!botId) {
        setSandboxStatus('error', 'ç¼ºå°‘ Bot');
        stderrEl.textContent = 'é”™è¯¯ï¼šè¯·å…ˆé€‰æ‹©ä¸€ä¸ª Botã€‚';
        setSandboxMeta({
            duration: '--',
            timestamp: new Date().toLocaleTimeString(),
            summary: 'å¤±è´¥ Â· ç¼ºå°‘ Bot',
            input,
            lines: 0,
        });
        return;
    }

    if (currentTab === 'pro') {
        const code = proEditor ? proEditor.getValue() : '';
        if (!code.trim()) {
            setSandboxStatus('error', 'ç¼ºå°‘ä»£ç ');
            stderrEl.textContent = 'é”™è¯¯ï¼šä¸“ä¸šè„šæœ¬ä»£ç ä¸èƒ½ä¸ºç©ºã€‚';
            setSandboxMeta({
                duration: '--',
                timestamp: new Date().toLocaleTimeString(),
                summary: 'å¤±è´¥ Â· ç¼ºå°‘ä¸“ä¸šè„šæœ¬',
                input,
                lines: 0,
            });
            return;
        }
        try {
            const response = await fetch('/api/sandbox/execute', {
                method: 'POST',
                credentials: 'same-origin',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ code, timeout: 5, input: input || '' })
            });
            const contentType = response.headers.get('content-type') || '';
            const isJson = contentType.includes('application/json');
            const payload = isJson ? await response.json() : await response.text();
            if (!isJson) {
                setSandboxStatus('error', 'å“åº”å¼‚å¸¸');
                stderrEl.textContent = `æ²™ç›’æ‰§è¡Œå¤±è´¥ï¼šæœåŠ¡å™¨è¿”å›é JSON å“åº”ã€‚\n${payload}`;
                setSandboxMeta({
                    duration: '--',
                    timestamp: new Date().toLocaleTimeString(),
                    summary: 'å¤±è´¥ Â· é JSON å“åº”',
                    input,
                    lines: 0,
                });
                return;
            }
            const result = payload;
            if (!response.ok || !result.ok) {
                setSandboxStatus('error', 'æ‰§è¡Œå¤±è´¥');
                stderrEl.textContent = result.error || result.stderr || 'æœªçŸ¥é”™è¯¯';
                setSandboxMeta({
                    duration: '--',
                    timestamp: new Date().toLocaleTimeString(),
                    summary: `å¤±è´¥ Â· ${result.error || 'æ‰§è¡Œé”™è¯¯'}`,
                    input,
                    lines: 0,
                });
                return;
            }
            const stdoutText = (result.stdout || '').trim();
            const stderrText = (result.stderr || '').trim();
            stdoutEl.textContent = stdoutText || 'âœ… æ‰§è¡Œå®Œæˆï¼ˆæ— æ ‡å‡†è¾“å‡ºï¼‰';
            stderrEl.textContent = stderrText || 'æ— è­¦å‘Š';
            const elapsed = `${((performance.now() - startedAt) / 1000).toFixed(2)}s`;
            setSandboxStatus('success', 'æ‰§è¡Œå®Œæˆ');
            setSandboxMeta({
                duration: elapsed,
                timestamp: new Date().toLocaleTimeString(),
                summary: `å®Œæˆ Â· ${modeText || 'ä¸“ä¸šè„šæœ¬'} Â· è¾“å…¥ ${friendlyInput}`,
                input,
                lines: countOutputLines(stdoutText),
            });
        } catch (error) {
            console.error('Pro sandbox execution failed:', error);
            setSandboxStatus('error', 'æ‰§è¡Œå¤±è´¥');
            stderrEl.textContent = `æ²™ç›’æ‰§è¡Œå¤±è´¥ï¼š${error.message}`;
            setSandboxMeta({
                duration: '--',
                timestamp: new Date().toLocaleTimeString(),
                summary: `å¤±è´¥ Â· ${error.message}`,
                input,
                lines: 0,
            });
        }
    } else if (currentTab === 'pseudo') {
        const content = document.getElementById('pseudo-editor').value;
        if (!content.trim()) {
            setSandboxStatus('error', 'ç¼ºå°‘ä¼ªä»£ç ');
            stderrEl.textContent = 'é”™è¯¯ï¼šä¼ªä»£ç å†…å®¹ä¸èƒ½ä¸ºç©ºã€‚';
            setSandboxMeta({
                duration: '--',
                timestamp: new Date().toLocaleTimeString(),
                summary: 'å¤±è´¥ Â· ç¼ºå°‘ä¼ªä»£ç ',
                input,
                lines: 0,
            });
            return;
        }
        try {
            const response = await fetch('/api/sandbox/pseudo/execute', {
                method: 'POST',
                credentials: 'same-origin',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content, input: input || '/demo' })
            });
            const contentType = response.headers.get('content-type') || '';
            const isJson = contentType.includes('application/json');
            const payload = isJson ? await response.json() : await response.text();
            if (!isJson) {
                setSandboxStatus('error', 'å“åº”å¼‚å¸¸');
                stderrEl.textContent = `ä¼ªä»£ç æ¼”ç»ƒå¤±è´¥ï¼šæœåŠ¡å™¨è¿”å›é JSON å“åº”ã€‚\n${payload}`;
                setSandboxMeta({
                    duration: '--',
                    timestamp: new Date().toLocaleTimeString(),
                    summary: 'å¤±è´¥ Â· é JSON å“åº”',
                    input,
                    lines: 0,
                });
                return;
            }
            const result = payload;
            if (!response.ok || !result.ok) {
                setSandboxStatus('error', 'æ‰§è¡Œå¤±è´¥');
                stderrEl.textContent = result.error || 'ä¼ªä»£ç æ¼”ç»ƒå¤±è´¥ï¼šæœªçŸ¥é”™è¯¯';
                setSandboxMeta({
                    duration: '--',
                    timestamp: new Date().toLocaleTimeString(),
                    summary: `å¤±è´¥ Â· ${result.error || 'æ‰§è¡Œé”™è¯¯'}`,
                    input,
                    lines: 0,
                });
                return;
            }
            const segments = [];
            segments.push(`å‘½ä»¤: ${result.command || 'ï¼ˆæœªç”Ÿæˆå‘½ä»¤ï¼‰'}`);
            if (result.summary) segments.push(result.summary);
            (result.actions || []).forEach((act, idx) => {
                const payload = act.text || act.url || act.prompt || JSON.stringify(act);
                segments.push(`${idx + 1}. [${act.type}] ${payload}`);
            });
            if (result.analysis) {
                segments.push('\nè§£æ:');
                segments.push(result.analysis);
            }
            const stdoutText = segments.join('\n');
            stdoutEl.textContent = stdoutText;
            stderrEl.textContent = 'æ— è­¦å‘Š';
            const elapsed = `${((performance.now() - startedAt) / 1000).toFixed(2)}s`;
            setSandboxStatus('success', 'æ¼”ç»ƒå®Œæˆ');
            setSandboxMeta({
                duration: elapsed,
                timestamp: new Date().toLocaleTimeString(),
                summary: `å®Œæˆ Â· ${modeText || 'ä¼ªä»£ç '} Â· è¾“å…¥ ${friendlyInput}`,
                input,
                lines: countOutputLines(stdoutText),
            });
        } catch (error) {
            console.error('Pseudo sandbox execution failed:', error);
            setSandboxStatus('error', 'æ‰§è¡Œå¤±è´¥');
            stderrEl.textContent = `ä¼ªä»£ç æ¼”ç»ƒå¤±è´¥ï¼š${error.message}`;
            setSandboxMeta({
                duration: '--',
                timestamp: new Date().toLocaleTimeString(),
                summary: `å¤±è´¥ Â· ${error.message}`,
                input,
                lines: 0,
            });
        }
    } else {
        setSandboxStatus('error', 'æš‚ä¸æ”¯æŒ');
        stdoutEl.textContent = '';
        stderrEl.textContent = 'æ­¤åŠŸèƒ½æš‚æœªå¯¹æµç¨‹ç¼–æ’å¼€æ”¾ã€‚';
        setSandboxMeta({
            duration: '--',
            timestamp: new Date().toLocaleTimeString(),
            summary: 'å¤±è´¥ Â· æµç¨‹ç¼–æ’æš‚æœªå¼€æ”¾',
            input,
            lines: 0,
        });
    }
}

// --- Event Listeners ---
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('[data-tab]').forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    document.getElementById('bot-selector').addEventListener('change', () => {
        updateActiveBotLabel();
        loadItemsForCurrentBot();
    });
    document.getElementById('item-selector').addEventListener('change', loadContentForItem);
    document.getElementById('run-sandbox').addEventListener('click', runSandbox);
    document.getElementById('save-item').addEventListener('click', saveItem);
    document.getElementById('clear-editor').addEventListener('click', () => clearEditor(true));
    document.getElementById('sandbox-input').addEventListener('input', (event) => {
        const previewEl = document.getElementById('sandbox-input-preview');
        if (previewEl) {
            previewEl.textContent = event.target.value.trim() || 'ï¼ˆç©ºï¼‰';
        }
    });
    
    setSandboxStatus('idle', 'å¾…æ‰§è¡Œ');
    setSandboxMeta({
        summary: `ç­‰å¾…æ‰§è¡Œ Â· ${MODE_LABEL_MAP[currentTab]}`,
        input: document.getElementById('sandbox-input')?.value || '',
        lines: 0,
    });
    loadBots();
    // Pre-init the first tab's editor if it's not pseudo
    // switchTab(currentTab); // Initial call
});
</script>
</script>
</body>
</html>
